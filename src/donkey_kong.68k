
ROM_START = 0
ROM_END = 0x4000
RAM_START = 0x6000
RAM_END	= 0x7000

	* read register to var, little endian
	.macro	MOVE_TO_VAR	reg,var
	move.b	\reg,\var
	ror.w	#8,\reg
	move.b	\reg,\var+1
	ror.w	#8,\reg	
	.endm
	
	* read var to register, little endian
	.macro	MOVE_TO_REG	var,reg
	move.b	\var+1,\reg	
	ror.w	#8,\reg
	move.b	\var,\reg
	.endm
	
	.macro CLEAR_XC_FLAGS
	move.w	d7,-(a7)
	moveq	#0,d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm
	
	.macro SET_XC_FLAGS
	move.w	d7,-(a7)
	st	d7
	roxl.b	#1,d7
	movem.w	(a7)+,d7
	.endm
	
	.macro	INVERT_XC_FLAGS
	jcs	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
	.endm
	.macro	SET_X_FROM_C
	jcc	0f
	SET_XC_FLAGS
	bra.b	1f
0:
	CLEAR_XC_FLAGS
1:
    .endm

	.macro	SET_C_FROM_X
	move.w	d7,-(a7)
	roxl.b	#1,d7
	roxr.b	#1,d7
	movem.w	(a7)+,d7
    .endm


	.macro	LOAD_D1_16_FROM_D1D2
	and.l	#0xFFFF,d1
	lsl.w	#8,d1
	move.b	d2,d1
	.endm
	
	.macro	LOAD_D3_16_FROM_D3D4
	and.l	#0xFFFF,d3
	lsl.w	#8,d3
	move.b	d4,d3
	.endm
	.macro	LOAD_D5_16_FROM_D5D6
	and.l	#0xFFFF,d5
	lsl.w	#8,d5
	move.b	d6,d5
	.endm
	.macro	LOAD_D1D2_FROM_D1_16
	move.b	d1,d2
	lsr.w	#8,d1
	.endm
	.macro	LOAD_D5D6_FROM_D5_16
	move.b	d5,d6
	lsr.w	#8,d5
	.endm
	.macro	LOAD_D3D4_FROM_D3_16
	move.b	d3,d4
	lsr.w	#8,d3
	.endm

	* load/store 16-bit words as big and little endian
	*
	* as always it appeared a goooood idea to use big endian for
	* all words, but as always it fails miserably because game ROM
	* data contains tables with little endian addresses for various
	* RAM & ROM locations. Fortunately, if wrong endianness is set it
	* trips the non-release range checks!
	*
	* big endian is only used to load/store to/from a 16 bit HL-like register
	* like D5
	
	.macro	LOAD_ROM_ADDRESS_BE	var_16bit,reg
	move.w	d7,-(a7)
	move.w	\var_16bit,d7
	.ifndef		RELEASE
	cmp.w	#ROM_END,d7
	bcs.b	110f
	lea		load_rom_address_be_error(pc),a0
	jbsr	osd_break
110:
	.endif
	lea		game_rom,\reg
	add.w	d7,\reg
	move.w	(a7)+,d7
	.endm
	
	.macro	LOAD_ROM_ADDRESS_LE	var_16bit,reg
	move.w	d7,-(a7)
	move.w	\var_16bit,d7
	rol.w	#8,d7		| little endian
	.ifndef		RELEASE
	cmp.w	#ROM_END,d7
	bcs.b	110f
	lea		load_rom_address_le_error(pc),a0
	jbsr	osd_break
110:
	.endif
	lea		game_rom,\reg
	add.w	d7,\reg
	move.w	(a7)+,d7
	.endm
	
	* this is big endian
	.macro	LOAD_ANY_ADDRESS_BE	var_16bit,reg
	move.w	d7,-(a7)
	move.w	\var_16bit,d7
	
	cmp.w	#ROM_END,d7
	bcs.b	110f
	* maybe RAM
	sub.w	#0x6000,d7
	.ifndef		RELEASE
	bpl.b	111f
	add.w	#0x6000,d7
	lea		load_any_address_be_error(pc),a0
	jbsr	osd_break
111:
	* > 0x6000, is that < ram end?
	cmp.w	#0x900,d7
	bcs.b	112f
	add.w	#0x6000,d7
	lea		load_any_address_be_error(pc),a0
	jbsr	osd_break
	.endif
112:
	* RAM
	lea		ram_6000,\reg
	bra.b	113f
110:
	lea		game_rom,\reg
113:
	add.w	d7,\reg
	move.w	(a7)+,d7
	.endm
	
	.macro	STORE_ROM_ADDRESS_LE	reg,var_16bit
	move.w	d7,-(a7)
	move.l	\reg,d7
	sub.l	#game_rom,d7
	.ifndef		RELEASE
	cmp.w	#ROM_END,d7
	bcs.b	110f
	lea		store_rom_address_le_error(pc),a0
	jbsr	osd_break
110:
	.endif
	
	rol.w	#8,d7		| little endian
	move.w	d7,\var_16bit
	move.w	(a7)+,d7
	.endm
	
	.macro	STORE_ROM_ADDRESS_BE	reg,var_16bit
	move.w	d7,-(a7)
	move.l	\reg,d7
	sub.l	#game_rom,d7
	.ifndef		RELEASE
	cmp.w	#ROM_END,d7
	bcs.b	110f
	lea		store_rom_address_be_error(pc),a0
	jbsr	osd_break
110:
	.endif
	
	move.w	d7,\var_16bit
	move.w	(a7)+,d7
	.endm
	
	.macro	LOAD_RAM_ADDRESS_LE	var_16bit,reg
	move.w	d7,-(a7)
	move.w	\var_16bit,d7
	rol.w	#8,d7		| little endian
	.ifndef		RELEASE
	cmp.w	#RAM_END,d7
	bcs.b	110f
	lea		load_rom_address_le_error(pc),a0
	jbsr	osd_break
110:
	.endif
	sub.w	#RAM_START,d7
	.ifndef		RELEASE
	bcc.b	111f
	add.w	#RAM_START,d7
	lea		load_rom_address_le_error(pc),a0
	jbsr	osd_break
111:
	.endif
	
	lea		ram_6000,\reg
	add.w	d7,\reg
	move.w	(a7)+,d7
	.endm
	
	.macro	STORE_RAM_ADDRESS_LE	reg,var_16bit
	move.w	d7,-(a7)
	move.l	\reg,d7
	sub.l	#ram_6000,d7
	.ifndef		RELEASE
	bmi.b	1110f
	cmp.w	#RAM_END-RAM_START,d7
	bcs.b	110f
1110:
	lea		store_ram_address_le_error(pc),a0
	jbsr	osd_break
110:
	.endif
	add.w	#RAM_START,d7
	rol.w	#8,d7		| little endian
	move.w	d7,\var_16bit
	move.w	(a7)+,d7
	.endm
	
	.macro	WRITE_TO_SCREEN	addr
	move.w	d7,-(a7)
	move.w	#\addr,d7
	jbsr	osd_w_videoram
	move.w	(a7)+,d7
	.endm
	
	.ifndef	RELEASE
load_any_address_be_error:
	.asciz	"LOAD_ANY_ADDRESS_BE out of range"
store_rom_address_le_error:
	.asciz	"STORE_ROM_ADDRESS_LE out of range"
store_rom_address_be_error:
	.asciz	"STORE_ROM_ADDRESS_BE out of range"
store_ram_address_le_error:
	.asciz	"STORE_RAM_ADDRESS_LE out of range"
load_rom_address_le_error:
	.asciz	"LOAD_ROM_ADDRESS_LE out of range"
load_rom_address_be_error:
	.asciz	"LOAD_ROM_ADDRESS_BE out of range"

	.align	2
	.endif
	
*
*
* Originally disassembled with dZ80 v1.31
*
* Z80 code contributors:
* * Jeff Willms (phase 1)
* * Kef Schecter (phase 2)
* * An anonymous contributor (most of the initial work on phase 1)
*
* reworked by JOTD mainly to de-anonymize RAM variables
*
* Memory map:
*   $0000-3fff ROM
*   $6000-6fff RAM
*   $6900-6A7f sprites
*   $7000-73ff unknown| probably not used
*   $7400-77ff Video RAM
*       top left corner:      $77A0
*       bottom left corner:   $77BF
*       top right corner:     $7440
*       bottom right corner:  $745F
*
*   Note that the monitor is rotated 90 degrees, so $77A1 is the tile under
*   $77A0, not the tile to the right of it.


* I/O ports
IN0         = 0x7c00       | player 1 joystick and jump button
IN1         = 0x7c80       | player 2 joystick and jump button
IN2         = 0x7d00       | coins| start buttons
DSW1        = 0x7d80       | DIP switches

* IN0 and IN1:
*   bit 7 : ?
*   bit 6 : reset
*   bit 5 : ?
*   bit 4 : JUMP
*   bit 3 : DOWN
*   bit 2 : UP
*   bit 1 : LEFT
*   bit 0 : RIGHT
*
* (IN0 is read on player 1's turn| IN1 is read on player 2's turn)

* IN2:
*   bit 7: COIN
*   bit 6: ? Radarscope does some wizardry with this bit
*   bit 5 : ?
*   bit 4 : ?
*   bit 3 : START 2
*   bit 2 : START 1
*   bit 1 : ?
*   bit 0 : ? if this is 1, the code jumps to $4000, outside the rom space

* DSW1:
*   bit 7 : COCKTAIL or UPRIGHT cabinet (1 = UPRIGHT)
*   bit 6 : \ 000 = 1 coin 1 play   001 = 2 coins 1 play  010 = 1 coin 2 plays
*   bit 5 :                             	| 011 = 3 coins 1 play  100 = 1 coin 3 plays  101 = 4 coins 1 play
*   bit 4 : / 110 = 1 coin 4 plays  111 = 5 coins 1 play
*   bit 3 : \bonus at
*   bit 2 : / 00 = 7000  01 = 10000  10 = 15000  11 = 20000
*   bit 1 : \ 00 = 3 lives  01 = 4 lives
*   bit 0 : / 10 = 5 lives  11 = 6 lives

* 7800-780F P8257 Control registers
* @TODO@ -- define constants for this



REG_MUSIC       = 0x7c00

* Values written to REG_MUSIC
* @TODO@ -- update code to use these
MUS_NONE        = 0x00
MUS_INTRO       = 0x01     | Music when DK climbs ladder
MUS_HOWHIGH     = 0x02     | How high can you get?
MUS_OUTATIME    = 0x03     | Running out of time
MUS_HAMMER      = 0x04     | Hammer music
MUS_ENDING1     = 0x05     | Music after beating even-numbered rivet levels
MUS_HAMMERHIT   = 0x06     | Hammer hit
MUS_FANFARE     = 0x07     | Music for completing a non-rivet stage
MUS_25M         = 0x08     | Music for barrel stage
MUS_50M         = 0x09     | Music for pie factory
MUS_75M         = 0x0a     | Music for elevator stage (or lack thereof)
MUS_100M        = 0x0b     | Music for rivet stage
MUS_ENDING2     = 0x0c     | Music after beating odd-numbered rivet levels
MUS_RM_RIVET    = 0x0d     | Used when rivet removed
MUS_DK_FALLS    = 0x0e     | Music when DK is about to fall in rivet stage
MUS_DK_ROAR     = 0x0f     | Zerbert. Zerbert. Zerbert.

* Sound effects get their own registers
REG_SFX         = 0x7d00   | The first of 8 sound registers, but only the first 6 are used

* These are added to REG_SFX to produce the register to write to
* These are also used by RAM (@TODO@ -- what variable?) to queue sounds
SFX_WALK        = 0
SFX_JUMP        = 1
SFX_BOOM        = 2       | DK pounds ground| barrel hits Mario
SFX_SPRING      = 3       | (writes to i8035's P1)
SFX_FALL        = 4       | (writes to i8035's P2)
SFX_POINTS      = 5       | Got points, grabbed the hammer, etc.

REG_SFX_DEATH   = 0x7d80   | plays when Mario dies (triggers i8035's interrupt)

* Some other hardware registers
REG_FLIPSCREEN      = 0x7d82
REG_SPRITE          = 0x7d83   | cleared at program start and never used
REG_VBLANK_ENABLE   = 0x7d84
REG_DMA             = 0x7d85   | @TODO@ -- what does this do, exactly?

*
* Background palette selectors
*
* These registers each store 1 bit. Only the least-significant bit
* matters when writing. The two values together determine the palette
* for the whole screen. Note that the colors can change from row to row
* in each palette. For example, in the high score screen palette, the
* first row of tiles shows red text| the second and third rows have
* white text| the fourth row has blue text| etc. You can see this in
* MAME by looking at the 0's on the screen while the game is booting up.
*
* Palettes:
* A                                     	| B
* -----
* 0                                     	| 0     high score screen
* 0                                     	| 1     barrel and elevator stages
* 1                                     	| 0     pie factory stage
* 1                                     	| 1     rivet stage
*
REG_PALETTE_A       = 0x7d86
REG_PALETTE_B       = 0x7d87


* Machine accepts no more than 90 credits (this is a BCD value)
max_credits     = 0x90

RAM = 0x6000
SPRITE_RAM      = 0x7000
VIDEO_RAM       = 0x7400

*
* Notes on variables (READ THIS)
*
* Donkey Kong's code is a little nutty and often depends on variables
* being stored in a certain way. For instance, if there's a variable at
* RAM+$a, it may do "DEC HL" to get at the variable at RAM+9, even
* if these variables are loosely related at best. If you're making a
* hack, we strongly suggest you keep the addresses of existing variables
* intact!
*
* For the same reason, it's hard to be 100% sure that every variable has
* been documented. It's easy to miss a variable if it's never directly
* referenced by address.
*
* Finally, be aware that, intentionally or not, some variables may have
* been used for more than one purpose.
*

* those equates are the same in lower case, suffixed by their RAM address
* Number of credits in BCD. Can't go over MAX_CREDITS.
NumCredits      = RAM+1

* Counts number of coins inserted until next credit is reached
* E.g., if the machine is set to 4 coins/credit, this starts at 0 and counts up to 4 with each coin.
* When it's 4, it'll be reset to 0 and a credit will be added.
CoinCounter     = RAM+2

* Usually 1. When a coin is inserted, it changes to 0 momentarily.
* (In MAME, this value will be 0 while the coin key is held down.)
CoinSwitch      = RAM+3

* 1 when in attract mode, 2 when credits in waiting for start, 3 when playing game
GameMode1       = RAM+5

* 1 when no credits have been inserted, 0 if any credits exist or a game is being played
NoCredits       = RAM+7

* General-purpose timer. 16-bit. The code uses the MSB rather than the LSB for 8-bit timers.
WaitTimer       = RAM+8
WaitTimerLSB    = RAM+8
WaitTimerMSB    = RAM+9

* Attract mode: $1
* Intro: $7
* How High Can You Get?: $a
* Right before play: $b
* During play: $c
* Dead: $d
* Game over: $10
* Rivets cleared: $16
* @TODO@ -- list is not complete. Range is [0..$17], and most, possibly all, values seem to be used
GameMode2       = RAM+$a

* Both of these are 0 if it's player 1's turn, and 1 if it's player 2's turn.
* @TODO@ -- try to find why these are two variables and give them better names.
PlayerTurnA     = RAM+$d
PlayerTurnB     = RAM+$e

* 0 if 1-player game, 1 if 2-player game
TwoPlayerGame   = RAM+$f

* The same as RawInput below, except when jump is pressed, bit 7 is set momentarily
InputState      = RAM+$10

* Right sets bit 0, left sets bit 1, up sets bit 2, down sets bit 3, jump sets bit 4
RawInput        = RAM+$11

* constantly changing ... timer of some sort? (@TODO@ -- better name?)
RngTimer1       = RAM+$18

* RngTimer2 - constantly changing timer - very fast (@TODO@ -- better name?)
RngTimer2       = RAM+$19

* Constantly counts down from FF to 00 and then FF to 00 again and again, once per frame
FrameCounter    = RAM+$1a

* Initial number of lives (set with dip switches)
StartingLives   = RAM+$20

* score needed for bonus life in thousands
ExtraLifeThreshold  = RAM+$21

CoinsPerCredit  = RAM+$22

* Coins needed for a two-player game (always CoinsPerCredit*2)
CoinsPer2Credits    = RAM+$23

* Seems to be used for the same purpose as CoinsPerCredit (@TODO@ -- why is this a distinct variable?)
CoinsPerCredit2 = RAM+$24

CreditsPerCoin  = RAM+$25

* 0 = cocktail, 1 = upright cabinet
UprightCab      = RAM+$26

* Timer counting delay before cursor can move. Keeps the cursor from moving too fast.
* (@XXX@ -- verify this is this variable's function!!)
HSCursorDelay   = RAM+$30

* Toggles between 0 and 1 as the player's high score in the table blinks
HSBlinkToggle   = RAM+$31

* Toggles HSBlinkToggle in table whenever it's zero
HSBlinkTimer    = RAM+$32

* Time left to register name in seconds
HSRegiTime      = RAM+$33

* Decrements HSRegiTime when zero
HSTimer         = RAM+$34

* Which character the cursor is highlighting when entering high score
HSCursorPos     = RAM+$35

* Address of screen RAM for current initial being entered (16-bit variable)
HSInitialPos    = RAM+$36

* Something to do with high score entry.
* Changing this value to FF in the debugger on high score screen causes the
* game to prompt for another name after entering the first.
Unk6038         = RAM+$38

* Number of lives remaining for player 1
P1NumLives      = RAM+$40

* #6041-6047 = ???
Unk6041         = RAM+$41

* Number of lives for player 2
P2NumLives      = RAM+$48

* #6049-604f probably serve the same purpose as 6041-6047, but for player 2
Unk6049         = RAM+$49

NumObstaclesJumped  = RAM+$60

* #6080 - #608F are used for sounds - they are a buffer to set up a sound to be played on the hardware

* #6080 = 1 or 3 when mario is walking, makes the walking sound

* #6081 counts down 3, 2, 1, 0 when mario jumps

* #6082 = boom sound

* #6083 counts down 3,2,1,0 when the springs bounce on the elevator level

* #6084 used for falling sounds

* #6085 = 1 when the bonus sound is played

* #6086 =

* #6089 = used to determine which music is played: (not all used during play?)
* #608A is used for same?

* #60B0 and #60B1 are some sort of counter.  counts from #C0 192 (decimal) to #FE (256) by twos, then again and again.  Related to #60C0 - #60FF ?

* #60B2, #60B3, #60B4 - player 1 score

* #60B5, #60B6, #60B7 - player 2 score

* #60B8 = ???

* #60C0 - #60FF - loaded with #FF, used for a timer, in conjunction with #60B0 ?

* #6100 - #61A5 - high score table

* #61C6, #61C7 = ???

* #6200 is 1 when mario is alive, 0 when dead

* #6202 varies from 0, 2, 4, 1 when mario is walking left or right

* #6203 = Mario's X position

* #6204 = varies between 80 and 0 when mario jumping left or right

* #6205 = Mario's Y position

* #6206 = left 4 bits vary when mario jumping

* #6207 = a movement indicator. when moving right, 128 bit is set. (bit 7) move left, 128 bit is cleared
* #6207 continuted.  walking, bits 0  and 1 flip around.  jump sets bits 1,2,3 on.  when climbing a ladder,
* #6207 cont.  bit 7 flips on and off, and bits 0,1,2 flip around

* #6208 = ?

* #620C = mario's jump height?

* #620F is movement indicator.  when still it is on 0, 1, or 2.  when moving it moves between 2,1,0,2,1,0... when on a ladder it goes to counts down from 4.  when it reaches zero, it animates mario climbing.

* #620E is set whenever mario jumps, it holds marios Y value when he jumped.

* #6210 = FF when jumping to the left and afterwards until another jump, 0 otherwise

* #6211 = 0 when jumping straight up, #80 when jumping left or right

* #6212 =

* #6214 = is counted from 0 while mario is jumping.

* #6215 is 1 when mario is on ladder, 0 otherwise

* #6216 is 1 while mario is jumping, 0 otherwise

* #6217 is 1 when hammer is active, 0 otherwise

* #6218 = 0, turns to 1 while mario is grabbing the hammer until he lands

* #6219 = 0, turns to 1 when mario is moving on a moving or broken ladder, [but this is never checked ???]

* #621B,C = the top and bottom locations of a ladder mario is on or near

* #621E = counts down from 4 when mario is landing from a jump.  0 otherwise

* #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.

* #6220 = set to 1 when mario falls too far, 0 otherwise

* #6221

* #6222 = toggles between 0 and 1 when mario on ladder.  otherwise 0

* #6224 = toggles between 0 and 1 when mario on ladder.  used for sounds while on ladder

* #6225 = 1 when a bonus sound is to be played, 0 otherwise

* #6227 is screen #:  1-girders, 2-pie, 3-elevator, 4-rivets

* #6228 is the number of lives remaining for current player

* #6229  is the level #

* #622C = game start flag.  1 when game begins, 0 after mario has died ?

* #622D = 0, changed to 1 when player is awarded extra life

* #6280 to #6287 = left side retractable ladder on conveyors?

* #6288, 6289, 628A = ???

* #6290 = counts down how many rivets are left from 8

* #62A0 = top conveyor direction reverse counter

* #62A1 = master direction for top conveyor, 01 = right, FF = left

* #62A2 = middle conveyor direction reverse counter

* #62A3 = master direction for middle conveyor, 01 = outwards, FF = inwards

* #62A5 = bottom conveyor direction reverse counter

* #62A6 = master direction for bottom conveyor, 01 = right, FF = left

* #62A7 = counts down from #34 to zero on elevators

* #62A8

* #62AA

* #62AC -

* #62AF = some sort of timer connected with the barrels counts down from 18 to 00 , then kong moves position for next barrel grab  See #638F
* continued  also used for counter during game intro, used for kong animation

* #62B1 - Bonus timer

* #62B2 controls the timer for blue barrels

* #62B3 = controls the timers for all levels except girders.  Is #78 (120), #64 (100), #50,(80) or #3C (60) depending on level.
* level 1 rivets 5000 bonus lasts 99 seconds (say 100) =  100 bonus every 2 seconds
* level 2 rivets 6000 bonus lasts 99 seconds = 100 bonus every 5/3 (1.66666...) seconds
* level 3 rivets 7000 bonus lasts 92 seconds = 100 bonus every 4/3 (1.3333...) seconds
* level 4 rivets 8000 bonus lasts 80 seconds = 100 bonus every 1 seconds

* level 1 barrels 4700 bonus lasts 94 seconds = 100 bonus every 2 seconds
* level 2 barrels 5700 bonus lasts 105 seconds = 100 bonus every 1.842 seconds ???
* level 3 barrels 6700 bonus lasts 93 seconds = 100 bonus every 1.388 seconds
* level 4 barrels 7700 bonus lasts 130 seconds = 100 bonus every 5/3 seconds 1.666 ?
*

* #62B4 a timer used on conveyors ?

* #62B8 = a timer used on conveyors and girders ?

* #62B9 - used for fire release on conveyors and girders ?  0 when no fires onscreen, 1 when fires are onscreen, 3 when a fire is to be released

* #6300 - ladder sprites / locations ???

* #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears

* #6341 - timer counts down when mario picks up bonus item or jumps an item for showing bonus on screen

* #6342

* #6343 - changes to 14 when umbrella picked up, 0C for hat, 10 for purse

* #6345 - usually 0.  changes to 1, then 2 when items are hit with the hammer

* #6348 - #00, turns to #01 when the oil can is on fire on girders

* #6350 - 0, turns to 1 when an item has been hit with hammer, back to 0 after score sprite appears in its place

* #6351 through #6354 used for temp storage for items hit with hammer

* #6380 - Internal difficulty. Dictates speed of fires, wild barrel behavior, barrel steerability and other things. Ranges from 1 to 5.

* #6381 = timer that controls when #6380 changes ?

* #6382 = 00 and turns to 80 when a blue barrel is about to be deployed.
*         First blue barrel has this at 81 and then 02.  changes to 1 for crazy barrel
*               Bit 7 is set when barrel is blue
*               Bit 0 is set when barrel is crazy
*               bit 1 is set for the second barrel of the round which can't be crazy

* #6383 = timer used in conjunction with the tasks

* #6384 = timer ?

* #6385 = varies from 0 to 7 while the intro screen runs, when kong climbs the dual ladders and scary music is played

* #6386 - is zero until time runs out.  then it turns to 2, then when it turns to 3 mario dies

* #6387 - is zero until time runs out.  then it counts down from FF to 00, when it hits 00 mario dies and #6386 is set to 3

* #6388 = usually zero, counts from 1 to 5 when the level is complete

* #6389 - ????

* #638C is the onscreen timer

* #638D = counts from 5 to 0 while kong is bouncing during intro

* #638E = counts from #1E to A while kong is climbing ladders at beginning of game

* #638F = Counts down 3,2,1,0 as a barrel is being deployed.  See #62AF

* #6390 - counts from 0 to 7F periodically

* #6391 - is 0, then changed to 1 when timer in #6390 is counting up

* #6392 = barrel deployment indicator.  0 normally, 1 when a barrel is being deployed

* #6393 - Barrel deployment indicator. This gets set to 1 as soon as the barrel deployment process begins, and gets set back to 0 as soon as
*         kong releases the barrel being deployed.

* #6396 = bouncer release flag.  0 normally, 3 when bouncer is to be deployed

* #6398 = 1 when riding an elevator ?

* #639B = pie deployment counter

* #639D = normally 0.  1 while mario dying, 2 when dead

* #639A = indicator for the fires/deployment

* #63A0 = usually 0, flips to 1 quickly when a firefox is deployed

* #63A1 =  number of firefoxes active

* #63A2 = used as a temporary counter

* #63A3 = top conveyor direction for this frame,  flips between 00 (stationary) and either 1 (right) or FF (left) depending on kongs direction

* #63A4 = middle left conveyor direction for this frame

* #63A5 = middle right conveyor direction for this frame

* #63A6 = bottom conveyor direction for this frame

* #63B3 - ???

* #63B5 - ???

* #63B7 - ???

* #63B8 is zero but turns to 1 when the timer expires but before mario dies

* #63B9 - is 1 during girders, changes to 0A when item is hit with hammer.
        *  on rivets it is 07.  conveyors turns to 6 when pie hit, 5 when fire hit. changes to 0A when mario dies

* #63C0 - ???

* #63C8,9 -  Used during fireball movement processing to store the address of the fireball data array for the current fireball being processed

* #63CC -  ???

* #6400 to #649F - Fireball data tables. There are 5 fireball slots, each with 32 bytes for storing data associated with that fireball. The first
*                  fireball's slot is #6400 to #641F, the second fireball's slot is #6420 to #643F, etc. The following is a description of the data
*                  stored at each offset into a fireball's slot:
* +00 - Fireball status. 0 = inactive (this fireball slot is free), 1 = active
* +01,02 - Empty
* +03 - Fireball actual X-position. This seems to be the same as +0E.
* +04 - Empty
* +05 - Fireball actual Y-position. This Y-position has been adjusted for the bobbing up and down that a each fireball is constantly doing. Note that
*       this bobbing up and down is mainly for visual effect and has no impact on any fireball movement logic (this uses +0F instead, which does not
*       account for the bobbing up and down), however hitboxes are still determined by this actual Y-position and not the effective Y-position
* +06 - Empty
* +07 - Fireball graphic data
* +08 - Fireball color. 0 = blue (Mario has hammer), 1 = normal
* +09 - (Width of fireball hitbox - 1)/2
* +0A - (Height of fireball hitbox - 1)/2
* +0B,0C - Empty
* +0D - Fireball direction of movement. It can take on the following values:
*         0 = left, but it can also mean "frozen" in the case of a freezer that is currently in freezer mode
*         1 = right
*         2 = "special" left, this is different from 0 since here the fireball behaves identically to a right-moving fireball, only moving left instead
*             of right. This means that ladders are permitted to be taken, speed is deterministic and not slowed, and freezers aren't frozen when
*             the direction is 2, unlike a direction of 0. The direction gets set to 2 only immediately after a fireball hits the right edge of a
*             girder, and it will stay at 2 until a "decision point" for reversing direction at which point the direction will become either 0 or 1.
*         4 = descending ladder
*         8 = ascending ladder
* +0E - Fireball effective X-position. This seems to be the same as +03.
* +0F - Fireball effective Y-position. This Y-position does not account for the fireball bobbing up and down and is treated as the true Y-position for
*       the purposes of all fireball movement.
* +10 to +12 - Empty
* +13 - This counter is used as an index into a table that determines how to adjust the fireball's Y-position to make it bob up and down.
* +14 - Ladder climb timer. This timer counts down from 2 as a fireball climbs a ladder. A fireball is only allowed to climb a pixel when this reaches
*       0, at which point it gets reset back to 2. This has the effect of causing fireballs to climb ladders at 1/3 of the speed at which they descend
*       ladders.
* +15 - Fireball animation change timer. This timer counts down from 2, and when it reaches 0 the fireball changes it's graphics.
* +16 - Fireball direction reverse counter. When this counter reaches 0 a fireball reverses direction with 50% probability. Such a decision is referred
*       to as a "decision point".
* +17 - Empty
* +18 - Fireball spawning flag. This is set to 1 to indicate that the fireball is in the process of spawning. Often fireballs follow a special
*       trajectory, such as when jumping out of an oil can, while this is set.
* +19 - Fireball freezer mode flag. Setting this to 2 indicates that freezer mode has been enguaged, at which point a fireball can potentially start
*       freezing. Only fireballs in the 2nd and 4th fireball slots can enter freezer mode.
* +1A,1B - During fireball spawning, when jumping out of an oil can, this is used to store the current index into the Y-position table that dictactes
*          the arc that the fireball follows as it comes out of the oil can.
* +1C - Fireball freeze timer. Freezers use this as a timer until a frozen fireball should unfreeze.
* +1D - Fireball freeze flag. If this gets set during freezer mode, then as long as Mario is not above the fireball it will immediately set the freeze
*       timer (+1C) for 256 frames and says frozen until the timer reaches 0, this can only happen when a fireball reaches the top of a ladder, all
*       other instances of a fireball freezing are caused by the direction being set to 0 during freezer mode and have nothing to do with the freeze
*       timer.
* +1E - Empty
* +1F - When a fireball is climbing up or down a ladder, this stores the Y-position of the other end of the ladder (the end the fireball is headed
*       towards).

* #64A7 -

* #6500 - #65AF = the ten bouncer values, 6510, 6520, etc. are starting values
*        +3 is the X pos, +5 is the Y pos

* #65A0 - #65?? = values for the 6 pies

* #6600 - 665F  = the 6 elevator values.  6610, 6620, 6630, 6640 ,6650 are starting values
*       + 3 is the X position, + 5 is the Y position

* #6680 -

* #6687 -

* #6688

* hammer code for top hammer of girders, lower hammer on rivets, upper left hammer on conveyors

* #6689 - changes from 5 to 6 when hammer active

* #668A - changes from 6 to 3 when hammer active

* #668E - changes from 0 to 10 when hammer active

* #668F - changes from 0 to F0 when hammer active

* #66A0 - ???

* #6700 range - barrel info +20, +40, +60, +80, +A0, +C0, +E0 for the barrels
* 00 = barrel not in use.  #02 = barrel being deployed.  #01 = barrel rolling

* #6701 - crazy barrel indicator.  00 for normal, #01 for crazy barrel

* #6702 - motion indicator.  02 = rolling right, 08 = rolling down, 04 = rolling left, bit 1 set when rolling down ladder

* #6703 - barrel X

* #6705 - barrel Y

* #6707 - right 2 bits are 01 when rolling, 10 when being deployed.  bit 7 toggles as it rolls

* #6708

* #670E = edge indicator.  counts from 0 to 3 while barrel is going over edge

* #670F = counts from 4 to 1 then over again when barrel is moving

* #6710 = 0 when deployed.  changed to #FF when at left edge and after landing after falling off right edge of girder.
*          changed to 1 when after landing after falling off left edge of girder and starting to roll right
*        changed to 0 while falling off right edge of girder

* #6711 = 60 when barrel is rolling around the right edge, A0 when rolling around left edge

*

* #6714 =

* #6715 =

* #6717 = position of next ladder it is going down or the ladder it just passed.
* ladders are :  70, 6A, 93, 8D, 8B, B3, B0, AC, D1, CD, F3, EE

* #6719 = grabs the Y value of the barrel when its crazy, and has hit a girder

* #6900 - #6907 = 2 sprites used for the girl

* #6908 - (#6908 + #28) = animation states for kong and maybe other things
        * #6909 - kong's right leg
        * #6913 -
        * #6919 - kong's mouth
        * #691D - kong's right arm
        * #692D - girl under kong's arms during game intro
        * #692F - girl under kong's arms ???

* #6944 - #694C = 2 sprites for moving ladders on conveyors

* #694C = mario sprite X value

* #694D = mario sprite value.

* #694E = mario sprite color ?

* #694F = mario sprite Y value

*00 = mario facing left
*01, 02 = mario running left
*03 = mario on ladder with left hand up
*04 = mario on ladder with butt showing
*05 = mario on ladder with butt showing
*06 = mario standing above ladder with back to screen
*07 = blank???
*08 = mario with hammer up, facing left
*09 = mario with hammer down, facing left
*0A = mario with hammer up, facing left
*0B = mario with hammer down, facing left
*0C = mario with hammer up, facing left
*0D = mario with hammer down, facing left
*0E = mario jumping left
*0F = mario landing left
*10 = top of girl
*11 = bottom of girl
*12 = bottom of girl (2nd pose)
*13 = bottom of girl (fat)
*14 = legs of girl when being carried
*15 = rolling barrel
*16, 17 = barrel going down ladder or crazy
*18 = barrel next to kong (vertical)
*19 = blue barrel (skull)
*1A, 1B = barrel going down ladder or crazy
*1C, 1D = blank ?
*1E = hammer
*1F = smashing down hammer
*20, 21, 22 = crazy kong face
*23 = kong face, frowning
*24 = kong face, growling
*25 = kong chest
*26 = kong left leg
*27 = kong right leg
*28 = kong right arm
*29 = kong left arm
*2A = kong right shoulder
*2B = part of kong ?
*2C = kong right foot
*2D = kong left arm grabbing barrel
*2E = kong bottom center
*2F = kong top right shoulder
*30 = kong face facing left
*31 = kong right arm
*32 = kong shoulder
*33 = kong shoulder
*34 = kong left arm
*35 = kong right arm
*36 = kong left foot climbing ladder
*37 = kong right foot climbing ladder
*38 = blank ?
*39 = lines for smashed item
*3A = solid block ?
*3B = bouncer (1)
*3C = bouncer (2 squished)
*3D = fireball (1)
*3E = fireball (2)
*3F = blank ?
*40 = fire on top of oil can
*41 = fire on top of oil can (2)
*42 =  fire on top of oil can (3)
*43 =  fire on top of oil can (4)
*44 =  flat girder (used for elevator?)
*45 = elevator receptacle
*46 =  ladder
*47, 48 = blank ?
*49 = oil can
*4A = blank?
*4B = pie
*4C = pie spilling over
*4D = firefox
*4E = firefox (2)
*4F = blanK?
*50 = edge of conveyor pulley
*51 = edge of conveyor pulley (2)
*52 = edge of conveyor pulley (3)
*53 - 5F = blank ?
*60 = circle for item being hit with hammer
*61 = small circle for item being hit with hammer
*62 = smaller circle for item being hit with hammer
*63 = burst for item being hit with hammer
*64 - 71  = blank
*72 = square for hiscore select
*73 = hat
*74 = purse
*75 = umbrella
*76 = heart
*77 = broken heart
*78 = dying, mario upside down
*79 = dying, mario head to right
*7A = mario dead
*7B = 100
*7C = 200
*7D = 300
*7E = 500
*7F = 800
*
*all values from 80-FF are mirror images of items 0 -7F
*
*80 = starting value, mario facing right
*81, 82 = mario running to right
*83 = mario on ladder with right hand up
*84 = mario on ladder with butt showing
*85 = mario on ladder with butt showing (2)
*86 =
*88 = mario with hammer up, facing right
*89 = mario with hammer down, facing right
*8A = mario with hammer up, facing right
*8B = mario with hammer down, facing right
*8C = mario with hammer up, facing right
*8D = mario with hammer down, facing right
*8E = mario jumping right
*8F = mario landing right
*FA = mario dead with circle (halo?)
*F8 = dying, right side up
*F9 = dying, head on left
*
*3rd sprite is the color
*0 = red
*1 = white
*2 = blue
*3,4,5,6 = cyan
*7 = white
*8 = orange
*9, A = pink
*B = light brown
*C = blue
*D = orange
*E = blue
*F = black
*10 =

* #6980 - X position of a barrel and bouncers (all sprites??) , #6981 = sprite type? , 2= sprite color?, #6983 = Y position
* Add 4 to each barrel/sprite in question up to #6A08

* #69B8 start for pie sprites

* #6A0C - #6A0C + 12 - positions of the bonus extra items, umbrella, purse, etc.

* #6A1C - #6A1F = hammer sprite

* #6A20 - #6A23 heart sprite

* #6A24 - #6A27 sprite used for kong's aching head lines

* #6A29 - sprite for oilcan fire

* #7400-77ff - video ram

* #7700 = 1 up area Letter P
* #7701 = score 10's value
* #7702 = under the score 10's value
* #7708 = area where Kong is on girders
* #7721 = score 100's value
* #7741 = score 1000's value
* #7761 = score 10,000 value
* #7781 = score 100,000 value
* #7641 is the start of high score 100,000 place
* #7521 - the start of player 2 score (100,000's place)


* characters data

*00 - 09 = 0 - 9
*10 = empty
*11 - 2A = A to Z
*12 = B
*13 = C
*14 = D
*15 = E
*16 = F
*17 = G
*18 = H
*19 = I
*1A = J
*1B = K
*1C = L
*1D = M
*1E = N
*1F = O
*20 = P
*21 = Q
*22 = R
*23 = S
*24 = T
*25 = U
*26 = V
*27 = W
*28 = X
*29 = Y
*2A = Z
*2B = .
*2C = -
*2D = high -
*2E = :
*2F = high -
*30 = <
*31 = >
*32 = I
*33 = II
*34 = = (equals sign)
*35 = -
*36 , 37 = !! (two exlamations)
*38 , 39= !
*3A = '
*3B, 3C = "
*3D = " (skinny quote marks)
*3E = L shape (right, bottom)
*3F = L shape, (right, top)
*40 = L shape
*41 = L shape, (left, top)
*42 = .
*43 = ,
*44 - 48 = some graphic (RUB END) ?
*49, 4A = copyrigh logo
*4B, 4C = some logo?
*4D, - 4F = solid blocks of various colors
*50 = 67 = kong graphics (retarded brother?)
*6C - 6F = a graphic
*70-79 = 0 - 9 (larger, used in score and tiemr)
*80 - 89 = 0-9
*8A = M
*8B = m
*8F-8C = some graphic
*9F= Left half of trademark symbol
*9E = right half of TM sybmol
*B1 = Red square with Yellow lines top and bottom
*B0 = Girder with hole in center used in rivets screen
*B6 = white line on top
*B7 = wierd icon?
*B8 = red line on bottom
*C0 - C7 = girder with ladder on bottom going up
*D0 - D7 = ladder graphic with girder under going up and out
*DD = HE  (help graphic)
*DE = EL
*DF = P!
*E1 - E7 = grider graphic going up and out
*EC - E8 = blank ?
*EF = P!
*EE = EL (part of help graphic)
*ED = HE (help graphic)
*F6 - F0 = girder graphic in several vertical phases coming up from bottom
*F7 = bottom yellow line
*FA - F8 = blank ?
*FB = ? (actually a question mark)
*FC = right red edge
*FD = left red edge
*FE = X graphic
*FF = Extra Mario Icon




    .global donkey_kong_irq
    .global donkey_kong_reset

	.include	"donkey_kong.inc"
	.ifdef	__amiga__
	.include "donkey_kong_ram.68k"
	.align	2
	.endif

*
*
* game start power-on
*
*

donkey_kong_reset:
	.ifndef	RELEASE
	tst.b	break_at_startup_flag
	beq.b	0f
	* put anything here that you need to track addresses
	
	jbsr	osd_break
	.endif
0:
l_0000:
	clr.b	d0                               	| [$0000: ld   a,$00] A := 0
	jbsr	osd_interrupt_control           	| [$0002: ld   (REG_VBLANK_ENABLED),a] disable interrupts
	jra	Init_0266                          	| [$0005: jp   Init_0266] skip ahead

*
* RST     #8
* if there are credits or the game is being played it returns immediately.  if not, it returns to higher subroutine
*

rst_08:
	move.b	nocredits_6007,d0               	| [$0008: ld      a,(nocredits_6007)] load A with 1 when no credits have been inserted, 0 if any credits exist or game is being played
	ror.b	#1,d0                            	| [$000b: rrca] any credits in the game ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$000c: ret     nc] yes, return [...]
0:

	addq.w	#4,sp                           	| [$000d: inc     sp] * 2
	rts                                    	| [$000f: ret] else return to higher subroutine

*
* RST     #10
* if mario is alive, it returns.  if mario is dead, it returns to the higher subroutine.
*
continue_only_if_mario_alive_0010:

	move.b	mario_array_6200,d0             	| [$0010: ld      a,(mario_array_6200)] 1 when mario is alive, 0 when dead
	ror.b	#1,d0                            	| [$0013: rrca] is mario alive?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0014: ret     c] yes, return [...]
0:

	addq.w	#4,sp                           	| [$0015: inc     sp] no, increase SP by 2 and return * 2
	rts                                    	| [$0017: ret] effectively returns twice

*
* RST     #18
*

rst_18:
l_0018:
	lea	waittimermsb_6009,a0           	| [$0018: ld      hl,waittimermsb_6009] load timer that counts down
	subq.b	#1,(a0)                         	| [$001b: dec     (hl)] Count it down...
	bne.b	0f                               	| [...]
	rts                                    	| [$001c: ret     z] Return if zero [...]
0:

	addq.w	#4,sp                           	| [$001d: inc     sp] otherwise Increase SP twice * 2
	rts                                    	| [$001f: ret] and return - effectively returns to higher subroutine

*
* RST     #20
*
rst_20:
	lea	waittimerlsb_6008,a0           	| [$0020: ld      hl,waittimerlsb_6008] load HL with timer
	subq.b	#1,(a0)                         	| [$0023: dec     (hl)] count it down
	jeq	l_0018                             	| [$0024: jr      z,$0018] If zero skip up and count down the other timer

l_0026:
	move.l	(sp)+,a0                        	| [$0026: pop     hl] else move stack pointer up and return to higher subroutine
	rts                                    	| [$0027: ret] return

rst_28:
*
* RST     #28
* jumps program to (4*D0 + Next program address)
* used in conjuction with a jump table after the call
*

	add.b	d0,d0                            	| [$0028: add     a,a] A := A * 2
	move.l	(sp)+,a0                        	| [$0029: pop     hl] load HL with address of jump table
	clr.w	d3                               	| [$002b: ld      d,$00] D := 0
	move.b	d0,d3                           	| [$002a: ld      e,a] load E with A
	                            	
									| [$002d: jp      $0032] skip ahead

	add.w	d3,a0                            	| [$0032: add     hl,de] HL is now 2 more than it was
	add.w	d3,a0                            	| [$0032: add     hl,de] (32 bits) HL is now 4 more than it was
	move.l	(a0),a0                         	| [$0033: ld      e,(hl)] load E with low byte from the table
											| [$0034: inc     hl] next table entry
											| [$0035: ld      d,(hl)] load D with high byte from table
											| [$0036: ex      de,hl] DE <> HL
	jra	(a0)                               	| [$0037: jp      (hl)] jump to the address in HL

*
* RST #30
*
only_continues_if_given_level_0030:
	                             	| [$0030: jr      $0044] this core sub is actually at #0044
* continuation of rst #30
* used to check a screen number.  if it doesn't match, the 2nd level of subroutine is returned
* A is preloaded with the check value, in binary

	lea	screen_number_6227,a0          	| [$0044: ld      hl,screen_number_6227] Load HL with address of Screen #
	move.b	(a0),d1                         	| [$0047: ld      b,(hl)] load B with Screen #, For B = 1 to screen # (1, 2, 3 or 4)

l_0048:
	ror.b	#1,d0                            	| [$0048: rrca] Rotate A right with carry
	scs		d7
	subq.b	#1,d1                           	| [...]
	jne	l_0048                             	| [$0049: djnz    $0048] Next B

	tst.b	d7
	beq.b	0f                               	| [...]
	rts                                    	| [$004b: ret    c] return if carry [...]
0:
	move.l	(sp)+,a0                        	| [$004c: pop     hl] otherwise HL gets the stack = return to higher subroutine
	rts                                    	| [$004d: ret] return
									


*
* RST     #38
* HL and C are preloaded
* updates #A (10 decimal) by adding C from each location from HL to HL + #40 by 4
* [the bytes affected are offset by 4 bytes each]
*
* Also #003D is called from several places. used for updating girl's sprite
*
rst_38:
	move.w	#0x0004,d3                      	| [$0038: ld      de,$0004] load offset of 4 to add 4
	move.b	#0x0a,d1                        	| [$003b: ld      b,$0a] for B = 1 to #A (10 decimal)

l_003d:
	                           	| [$003d: ld      a,c] Load A with C
	add.b	d2,(a0)                          	| [$003e: add     a,(hl)] Add the contents of HL into A
										| [$003f: ld      (hl),a] put back into HL, this increases the value in HL by C
	add.w	d3,a0                            	| [$0040: add     hl,de] next HL to do will be 4 more than previous
	subq.b	#1,d1                           	| [...]
	jne	l_003d                             	| [$0041: djnz    $003d] next B

	rts                                    	| [$0043: ret] return


* HL is preloaded with source data of kong sprites values
* this subroutine copies the memory values of HL to HL + #28 into #6908 through #6908 + #28
* used to set all the kong sprites

update_kong_sprites_004e:
	lea	start_of_kong_sprite_6908,a1   	| [$004e: ld      de,start_of_kong_sprite_6908] Kong's Sprites start
	move.w	#0x28,d1                        	| [$0051: ld      bc,$0028] #28 bytes to copy 40
	jbsr	ldir                              	| [$0054: ldir] copy
	rts                                    	| [$0056: ret] return

* this subroutine takes the value of RngTimer1 and adds into it the values from FrameCounter and RngTimer2
* it returns with A loaded with this result and also RngTimer1 with the answer.
* random number generator

random_0057:
	move.b	rngtimer1_6018,d0               	| [$0057: ld      a,(rngtimer1_6018)] load A with timer
	lea	framecounter_601a,a0           	| [$005a: ld      hl,framecounter_601a] load HL with other timer address
	add.b	(a0),d0                          	| [$005d: add     a,(hl)] add
	lea	rngtimer2_6019,a0              	| [$005e: ld      hl,rngtimer2_6019] load HL with yet another timer address
	add.b	(a0),d0                          	| [$0061: add     a,(hl)] add
	move.b	d0,rngtimer1_6018               	| [$0062: ld      (rngtimer1_6018),a] store
	rts                                    	| [$0065: ret] return

donkey_kong_irq:
* interrupt routine

	move.w	d0,-(sp)                        	| [$0066: push    af]
	movem.w	d1/d2,-(sp)                    	| [$0067: push    bc]
	movem.w	d3/d4,-(sp)                    	| [$0068: push    de]
	move.l	a1,-(sp)                        	| [$0068: push    de]

	move.l	a0,-(sp)                        	| [$0069: push    hl]

	move.l	a2,-(sp)                        	| [$006a: push    ix]

	move.l	a3,-(sp)                        	| [$006c: push    iy] save all registers

	clr.b	d0                               	| [$006e: xor     a] A := 0
	jbsr	osd_interrupt_control            	| [$006f: ld      (reg_vblank_enable),a] disable interrupts
*	move.b	in2,d0                          	| [$0072: ld      a,(in2)] load A with Credit/Service/Start Info
*	and.b	#0x01,d0                         	| [$0075: and     $01] is the Service button being pressed?
*	jne	l_4000                             	| [$0077: jp      nz,$4000] yes, jump to #4000 [??? this would cause a crash ???]

	lea	game_rom+0x0138,a0                      	| [$007a: ld      hl,$0138] load HL with start of table data
	jbsr	refresh_sprites_0141                            	| [$007d: call    $0141] refresh the P8257 Control registers / refresh sprites to hardware
	move.b	nocredits_6007,d0               	| [$0080: ld      a,(nocredits_6007)] load the credit indicator
	                               	| [$0083: and     a] are there credits present / is a game being played ?
	jne	l_00b5                             	| [$0084: jp      nz,$00b5] No, jump ahead

* disable cocktail
*	move.b	uprightcab_6026,d0              	| [$0087: ld      a,(uprightcab_6026)] yes, load A with upright/cocktail
*	                               	| [$008a: and     a] upright ?
*	jne	l_0098                             	| [$008b: jp      nz,$0098] yes, jump ahead
*
*	                               	| [$0091: and     a] is this player 2 ?
*	jbsr	osd_read_in_1                          	| [$0092: ld      a,(in1)] load A with raw input from player 2
*	tst.b	playerturnb_600e             	| [$008e: ld      a,(playerturnb_600e)] else load A with player number
*	jne	l_009b                             	| [$0095: jp      nz,$009b] yes, skip next step

l_0098:
	jbsr	osd_read_in_0                          	| [$0098: ld      a,(in0)] load A with raw input from player 1
l_009b:
	move.b	d0,d1                           	| [$009b: ld      b,a] copy to B
	and.b	#0x0f,d0                         	| [$009c: and     $0f] mask left 4 bits to zero
	move.b	d0,d2                           	| [$009e: ld      c,a] copy this to C
	move.b	rawinput_6011,d0                	| [$009f: ld      a,(rawinput_6011)] load A with player input
	not.b	d0                               	| [$00a2: cpl] The contents of A are inverted (ones complement).
	and.b	d1,d0                            	| [$00a3: and     b] logical and with raw input - checks for jump button
	and.b	#0x10,d0                         	| [$00a4: and     $10] mask all bits but 4.  if jump was pressed it is there
	rol.b	#3,d0                           	| [$00a6: rla] * 3
	or.b	d2,d0                             	| [$00a9: or      c] mix back into masked input
	move.b	d1,d5                           	| [$00aa: ld      h,b] load H with B = raw input
	move.b	d0,d6                           	| [$00ab: ld      l,a] load L with A = modified input
	move.b	d6,inputstate_6010              	| [$00ac: ld      (inputstate_6010),hl] store into input memories, InputState and RawInput
	move.b	d5,inputstate_6010+1              	| [$00ac: ld      (inputstate_6010),hl] store into input memories, InputState and RawInput
	move.b	d1,d0                           	| [$00af: ld      a,b] load A with raw input
	btst.b	#6,d0                           	| [$00b0: bit     6,a] is the bit 6 set for reset?
	jne	l_0000                             	| [$00b2: jp      nz,$0000] if reset, jump back to #0000 for a reboot

l_00b5:
	lea	framecounter_601a,a0           	| [$00b5: ld      hl,framecounter_601a] else load HL with Timer constantly counts down from FF to 00 and then FF to 00 again and again ... 1 count per frame
	subq.b	#1,(a0)                         	| [$00b8: dec     (hl)] decrease this timer
	jbsr	random_0057                            	| [$00b9: call    $0057] update the random number gen
	jbsr	handle_insert_coins_017b                            	| [$00bc: call    $017b] check for credits being inserted and handle them
	**jbsr	update_sounds_00e0                            	| [$00bf: call    $00e0] update all sounds
										| [$00c2: ld      hl,$00d2] load HL with return address

	pea		l_00d2                        	| [$00c5: push    hl] push to stack so any RETs go there (#00D2)
	move.b	gamemode1_6005,d0               	| [$00c6: ld      a,(gamemode1_6005)] load A with game mode1

* GameMode1 is 0 when game is turned on, 1 when in attract mode.  2 when credits in waiting for start, 3 when playing game
     jbsr	rst_28             | jump based on above:

	.long   l_01c3 | #01C3 = startup
	.long   attract_mode_073c | #073C = attract mode
	.long   l_08b2 | #08B2 = credits, waiting
	.long   playing_game_06fe | #06FE = playing game

* return here from any of the jumps above, based on return address pushed to stack at #00C5
l_00d2:
	move.l	(sp)+,a3                        	| [$00d2: pop     iy]
	move.l	(sp)+,a2                        	| [$00d4: pop     ix]
	move.l	(sp)+,a0                        	| [$00d6: pop     hl]
	move.l	(sp)+,a1                        	| [$00d7: pop     de]
	movem.w	(sp)+,d3/d4                    	| [$00d7: pop     de]

	movem.w	(sp)+,d1/d2                    	| [$00d8: pop     bc] restore all registers except AF

	move.b	#0x01,d0                        	| [$00d9: ld      a,$01] A := 1
	jbsr	osd_interrupt_control            	| [$00db: ld      (reg_vblank_enable),a] enable interrupts
	move.w	(sp)+,d0                        	| [$00de: pop     af] restore AF
	rts                                    	| [$00df: ret] return from interrupt

* called from #00BF
* updates all sounds

update_sounds_00e0:
	lea	walking_sound_buffer_6080,a0   	| [$00e0: ld      hl,walking_sound_buffer_6080] source data at sound buffer
	lea	reg_sfx,a1                     	| [$00e3: ld      de,reg_sfx] set destination to sound outputs
	move.b	nocredits_6007,d0               	| [$00e6: ld      a,(nocredits_6007)] load A with credit indicator
	                               	| [$00e9: and     a] have credits been inserted / is there a game being played ?
	beq.b	0f                               	| [...]
	rts                                    	| [$00ea: ret     nz] no, return [change to NOP to enable sound in demo ] [...]
0:

* this sub writes the sound buffer to the hardware
* sounds have durations to play in the buffer

	move.b	#0x08,d1                        	| [$00eb: ld      b,$08] yes, there was a credit or a game is being played.  For B = 1 to 8 Do:

l_00ed:
	move.b	(a0),d0                         	| [$00ed: ld      a,(hl)] load A with sound duration / sound effect for the sound
	                               	| [$00ee: and     a] is there a sound to play ?
	jeq	l_00f5                             	| [$00ef: jp      z,$00f5] no, skip next 2 steps

	subq.b	#1,(a0)                         	| [$00f2: dec     (hl)] yes, decrease the duration
	move.b	#0x01,d0                        	| [$00f3: ld      a,$01] A := 1

l_00f5:
	move.b	d0,(a1)+                         	| [$00f5: ld      (de),a] store sound to output (play sound)
	                           	| [$00f6: inc     e] next output address
	addq.w	#1,a0                           	| [$00f7: inc     l] next source address
	subq.b	#1,d1                           	| [...]
	jne	l_00ed                             	| [$00f8: djnz    $00ed] Next B

	lea	music_timer_608b,a0            	| [$00fa: ld      hl,music_timer_608b] load HL with music timer
	move.b	(a0),d0                         	| [$00fd: ld      a,(hl)] load A with this value
	                               	| [$00fe: and     a] == 0 ?
	jne	l_0108                             	| [$00ff: jp      nz,$0108] no, skip ahead 4 steps

	subq.w	#2,a0                           	| [$0102: dec     l] else * 2
	move.b	(a0),d0                         	| [$0104: ld      a,(hl)] load A with this value to use for music
	jra	l_010b                             	| [$0105: jp      $010b] skip next 3 steps

l_0108:
	subq.b	#1,(a0)                         	| [$0108: dec     (hl)] decrease timer
	                           	| [$0109: dec     l] HL := #608A
	move.b	-(a0),d0                         	| [$010a: ld      a,(hl)] load A with this tune to use

l_010b:
	move.b	d0,reg_music                    	| [$010b: ld      (reg_music),a] play music
	lea	play_death_sound_6088,a0       	| [$010e: ld      hl,play_death_sound_6088] load HL with address/counter for mario dying sound
	clr.b	d0                               	| [$0111: xor     a] A := 0
	cmp.b	(a0),d0                          	| [$0112: cp      (hl)] compare.  is mario dying ?
	jeq	l_0118                             	| [$0113: jp      z,$0118] no, skip next 2 steps

	subq.b	#1,(a0)                         	| [$0116: dec     (hl)] else decrease the counter
	addq.b	#1,d0                           	| [$0117: inc     a] A := 1

l_0118:
	move.b	d0,reg_sfx_death                	| [$0118: ld      (reg_sfx_death),a] store A into digital sound trigger -death (?)
	rts                                    	| [$011b: ret] return

* clear all sounds
* called from several places

clear_all_sounds_011c:
	move.b	#0x08,d1                        	| [$011c: ld      b,$08] For B = 1 to 8
	clr.b	d0                               	| [$011e: xor     a] A := 0
	lea	reg_sfx,a0                     	| [$011f: ld      hl,reg_sfx] [REG_SFX..REG_SFX+7] get all zeros
	lea	walking_sound_buffer_6080,a1   	| [$0122: ld      de,walking_sound_buffer_6080] #6080-#6088 get all zeros - clears sound buffer

l_0125:
	move.b	d0,(a0)+                         	| [$0125: ld      (hl),a] clear this memory - clears sound outputs
	move.b	d0,(a1)+                         	| [$0126: ld      (de),a] clear this memory
												| [$0127: inc     l] next memory
												| [$0128: inc     e] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_0125                             	| [$0129: djnz    $0125] Next B

	move.b	#0x04,d1                        	| [$012b: ld      b,$04] For B = 1 to 4

l_012d:
	move.b	d0,(a1)+                         	| [$012d: ld      (de),a] #6088-#608B get all zeros
												| [$012e: inc     e] next DE
	subq.b	#1,d1                           	| [...]
	jne	l_012d                             	| [$012f: djnz    $012d] Next B

	move.b	d0,reg_sfx_death                	| [$0131: ld      (reg_sfx_death),a] clear the digital sound trigger (death)
	move.b	d0,reg_music                    	| [$0134: ld      (reg_music),a] clear the sound output
	rts                                    	| [$0137: ret] return

* data used in sub below

*0138,0x53,0x00,0x69,0x80,0x41,0x00,0x70,0x80
*0140,0x81

* called from #007D
* HL is preloaded with #0138
* This copies the sprite data from $6900 to $7000
* Presumably the reason sprite data isn't stored in $7000 in 
* the first place is to ensure it's updated only during vblank.

refresh_sprites_0141:
	lea		girls_head_sprite_6900,a0
	jbsr	osd_update_sprites
	
*	clr.b	d0                               	| [$0141: xor     a] A := 0
*	move.b	d0,reg_dma                      	| [$0142: ld      (reg_dma),a] store into P8257 DRQ DMA Request
*	move.b	(a0),d0                         	| [$0145: ld      a,(hl)] load table data (#53)
*	move.b	d0,0x7808                       	| [$0146: ld      ($7808),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$0149: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$014a: ld      a,(hl)] load table data (#00)
*	move.b	d0,0x7800                       	| [$014b: ld      ($7800),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$014e: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$014f: ld      a,(hl)] load table data (#69)
*	move.b	d0,0x7800                       	| [$0150: ld      ($7800),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$0153: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$0154: ld      a,(hl)] load table data (#80)
*	move.b	d0,0x7801                       	| [$0155: ld      ($7801),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$0158: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$0159: ld      a,(hl)] load table data (#41)
*	move.b	d0,0x7801                       	| [$015a: ld      ($7801),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$015d: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$015e: ld      a,(hl)] load table data (#00)
*	move.b	d0,0x7802                       	| [$015f: ld      ($7802),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$0162: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$0163: ld      a,(hl)] load table data (#70)
*	move.b	d0,0x7802                       	| [$0164: ld      ($7802),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$0167: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$0168: ld      a,(hl)] load table data (#80)
*	move.b	d0,0x7803                       	| [$0169: ld      ($7803),a] store into P8257 control register
*	addq.w	#1,a0                           	| [$016c: inc     hl] next table entry
*	move.b	(a0),d0                         	| [$016d: ld      a,(hl)] load table data (#81)
*	move.b	d0,0x7803                       	| [$016e: ld      ($7803),a] store into P8257 control register
*	move.b	#0x01,d0                        	| [$0171: ld      a,$01] A := 1
*	move.b	d0,reg_dma                      	| [$0173: ld      (reg_dma),a] store into P8257 DRQ DMA Request
*	clr.b	d0                               	| [$0176: xor     a] A := 0
*	move.b	d0,reg_dma                      	| [$0177: ld      (reg_dma),a] store into P8257 DRQ DMA Request
	rts                                    	| [$017a: ret] return

* called from #00BC
* checks for and handles credits

handle_insert_coins_017b:
	jbsr	osd_read_in_2                          	| [$017b: ld      a,(in2)] load A with IN2
	lea	coinswitch_6003,a0             	| [$0180: ld      hl,coinswitch_6003] load HL with pointer to coin switch indicator
	btst.b	#7,d0                           	| [$017e: bit     7,a] is the coin switch active?
	jne	l_0189                             	| [$0183: jp      nz,$0189] yes, skip next 2 steps

	move.b	#0x01,(a0)                      	| [$0186: ld      (hl),$01] otherwise store 1 into coin switch indicator  -  this is for coin insertion
	rts                                    	| [$0188: ret] return

l_0189:
	move.b	(a0),d0                         	| [$0189: ld      a,(hl)] Load A with coin switch indicator
	                               	| [$018a: and     a] has a coin been inserted ?
	bne.b	0f                               	| [...]
	rts                                    	| [$018b: ret     z] no, return [...]
0:

* coin has been inserted


	move.l	a0,-(sp)                        	| [$018c: push    hl] else save HL to stack
	move.b	gamemode1_6005,d0               	| [$018d: ld      a,(gamemode1_6005)] load A with game mode1
	cmp.b	#0x03,d0                         	| [$0190: cp      $03] is someone playing?
	jeq	l_019d                             	| [$0192: jp      z,$019d] yes, skip ahead and don't play the sound

	jbsr	clear_all_sounds_011c                            	| [$0195: call    $011c] no, then clear all sounds
	move.b	#0x03,d0                        	| [$0198: ld      a,$03] load sound duration
	move.w	#CREDIT_SND,D0
	jbsr	osd_sound_start  	| [$019a: ld      (play_sound_for_bouncer_6083),a] plays the coin insert sound

l_019d:
	move.l	(sp)+,a0                        	| [$019d: pop     hl] restore HL from stack
	clr.b	(a0)                             	| [$019e: ld      (hl),$00] store 0 into coin switch indicator - no more coins
	                           	| [$01a0: dec     hl] HL := CoinCounter
	addq.b	#1,-(a0)                         	| [$01a1: inc     (hl)] increase this counter
	lea	coinspercredit2_6024,a1        	| [$01a2: ld      de,coinspercredit2_6024] load DE with # of coins needed per credit
	move.b	(a1),d0                         	| [$01a5: ld      a,(de)] load A with coins needed
	sub.b	(a0),d0                          	| [$01a6: sub     (hl)] has the player inserted enough coins for a new credit?
	beq.b	0f                               	| [...]
	rts                                    	| [$01a7: ret     nz] yes, return (CoinCounter is now zero) [...]
0:

	move.b	d0,(a0)                         	| [$01a8: ld      (hl),a] no| restore CoinCounter
	addq.w	#1,a1                           	| [$01a9: inc     de] DE := CreditsPerCoin
	subq.w	#1,a0                           	| [$01aa: dec     hl] HL := NumCredits
	exg	a1,a0                              	| [$01ab: ex      de,hl] DE := NumCredits, HL := CreditsPerCoin
	move.b	(a1),d0                         	| [$01ac: ld      a,(de)] load A with number of credits in BCD
	cmp.b	#max_credits,d0						| [cp      max_credits] is the number of credits already maxed out?
	bcs.b	0f                               	| [...]
	rts                                    	| [$01af: ret     nc] yes| return [...]
0:
	CLEAR_XC_FLAGS
	move.b	(a0),d7                          	| [$01b0: add     a,(hl)] add number of credits with # of credits per coin
	abcd	d7,d0					| [daa] decimal adjust
	move.b	d0,(a1)                         	| [$01b2: ld      (de),a] store result in credits
	move.w	#0x0400,d3                      	| [$01b3: ld      de,$0400] load task #4 - draws credits on screen if any are present
	jbsr	insert_task_309f                            	| [$01b6: call    $309f] insert task
	rts                                    	| [$01b9: ret] return

* table data used below in 01C6

l_01ba:
	.byte	0x00,0x37,0x00,0xAA,0xAA,0xAA,0x50,0x76,0x00
	.align	2
	
* this is called when the game is first turned on or reset from #00C9

l_01c3:
	jbsr	clear_screen_and_sprites_0874                            	| [$01c3: call    $0874] clears the screen and sprites
	lea	l_01ba(pc),a0                      	| [$01c6: ld      hl,$01ba] start of table data above
	lea	player_1_score_address_60b2,a1 	| [$01c9: ld      de,player_1_score_address_60b2] set destination
	move.w	#0x09,d1                        	| [$01cc: ld      bc,$0009] set counter to 9 9
	jbsr	ldir                              	| [$01cf: ldir] copy 9 bytes above into #60B2-#60BB
	move.b	#0x01,d0                        	| [$01d1: ld      a,$01] A := 1
	move.b	d0,nocredits_6007               	| [$01d3: ld      (nocredits_6007),a] store into credit indicator == no credits exist
	move.b	d0,level_number_6229       	| [$01d6: ld      (level_number_6229),a] initialize level to 1
	move.b	d0,number_of_lives_remaining_6228	| [$01d9: ld      (number_of_lives_remaining_6228),a] set number of lives remaining to 1
	jbsr	l_06b8                            	| [$01dc: call    $06b8] if a game is played or credits exist, display remaining lives-1 and level
	jbsr	read_dip_load_highs_0207                            	| [$01df: call    $0207] set all dip switch settings and create default high score table from ROM
	move.b	#0x01,d0                        	| [$01e2: ld      a,$01] A := 1
	move.b	d0,reg_flipscreen               	| [$01e4: ld      (reg_flipscreen),a] store into flip screen setting
	move.b	d0,gamemode1_6005               	| [$01e7: ld      (gamemode1_6005),a] store into game mode 1
	move.b	start_screen,d0
	addq	#1,d0
	move.b	d0,screen_number_6227           	| [$01ea: ld      (screen_number_6227),a] initialize screen to 1 (girders)
	clr.b	d0                               	| [$01ed: xor     a] A := 0
	move.b	d0,gamemode2_600a               	| [$01ee: ld      (gamemode2_600a),a] store into game mode 2
	jbsr	l_0a53                            	| [$01f1: call    $0a53] draw "1UP" on screen
	move.w  #0x0304,d3                      	| [$01f4: ld      de,$0304] load task data to draw "HIGH SCORE"
	jbsr	insert_task_309f                            	| [$01f7: call    $309f] insert task to draw text
	move.w  #0x0202,d3                      	| [$01fa: ld      de,$0202] load task #2, parameter 2 to display the high score
	jbsr	insert_task_309f                            	| [$01fd: call    $309f] insert task
	move.w	#0x0200,d3                      	| [$0200: ld      de,$0200] load task #2, parameter 0 to display player 1 score
	jbsr	insert_task_309f                            	| [$0203: call    $309f] insert task
	rts                                    	| [$0206: ret] return

* this sub reads and sets the dip switch settings, and creates the default high score table

read_dip_load_highs_0207:
	jbsr	osd_read_dsw_1                         	| [$0207: ld      a,(dsw1)] load A with Dip switch settings
	move.b	d0,d2                           	| [$020a: ld      c,a] copy to C
	lea	startinglives_6020,a0          	| [$020b: ld      hl,startinglives_6020] set destination address to initial number of lives
	and.b	#0x03,d0                         	| [$020e: and     $03] mask bits, now between 0 and 3 inclusive
	addq.b	#0x03,d0                        	| [$0210: add     a,$03] Add 3, now between 3 and 6 inclusive
	move.b	d0,(a0)+                         	| [$0212: ld      (hl),a] store in initial number of lives
	                           	| [$0213: inc     hl] next HL, now at ExtraLifeThreshold = score needed for extra life
	move.b	d2,d0                           	| [$0214: ld      a,c] load A with original value of dip switches
	ror.b	#2,d0                            	| [$0215: rrca] * 2
	and.b	#0x03,d0                         	| [$0217: and     $03] mask bits, now between 0 and 3
	move.b	d0,d7
	move.b	d0,d1                           	| [$0219: ld      b,a] copy to B.  used in minisub below for loop counter
	move.b	#0x07,d0                        	| [$021a: ld      a,$07] A := 7 = default score for extra life
	tst.b	d7
	jeq	l_0226                             	| [$021c: jp      z,$0226] on zero, jump ahead and use 7

	move.b	#0x05,d0                        	| [$021f: ld      a,$05] A : = 5

l_0221:
	CLEAR_XC_FLAGS
	move.b	#5,d7
	abcd	d7,d0                        	| [$0221: add     a,$05] add 5 + daa                 | decimal adjust
	subq.b	#1,d1                           	| [...]
	jne	l_0221                             	| [$0224: djnz    $0221] loop until done

l_0226:
	move.b	d0,(a0)+                         	| [$0226: ld      (hl),a] store the result in score for extra life
	                           	| [$0227: inc     hl] HL := CoinsPerCredit
	move.b	d2,d0                           	| [$0228: ld      a,c] load A with dipswitch
	move.b	#0x01,d1                        	| [$0229: ld      bc,$0101] B := 1, C := 1
	move.b	#0x01,d2                        	| [$0229: ld      bc,$0101] B := 1, C := 1
	move.b	#1,d3                      	| [$022c: ld      de,$0102] D := 1, E := 2
	move.b	#2,d4                      	| [$022c: ld      de,$0102] D := 1, E := 2
	and.b	#0x70,d0                         	| [$022f: and     $70] mask bits.  turns off all except the 3 used for coins/credits
	roxl.b	#4,d0                           	| [$0231: rla] * 4
	jeq	l_0247                             	| [$0235: jp      z,$0247] if zero, skip ahead and leave BC and DE alone

	jcs	l_0241                             	| [$0238: jp      c,$0241] if there was a carry, skip ahead

	addq.b	#1,d0                           	| [$023b: inc     a] increase A
	move.b	d0,d2                           	| [$023c: ld      c,a] store into C
	move.b	d3,d4                           	| [$023d: ld      e,d] E := 1
	jra	l_0247                             	| [$023e: jp      $0247] skip ahead

l_0241:
	addq.b	#0x02,d0                        	| [$0241: add     a,$02] else A := 2
	move.b	d0,d1                           	| [$0243: ld      b,a] B := 2
	move.b	d0,d3                           	| [$0244: ld      d,a] D := 2
	add.b	d0,d0                            	| [$0245: add     a,a] A := 4
	move.b	d0,d4                           	| [$0246: ld      e,a] E := 4

l_0247:
	move.b	d3,(a0)+                         	| [$0247: ld      (hl),d] store D into CoinsPerCredit
	                           	| [$0248: inc     hl] HL := CoinsPer2Credits
	move.b	d4,(a0)+                         	| [$0249: ld      (hl),e] store E into CoinsPer2Credits
	                          	| [$024a: inc     hl] HL := CoinsPerCredit2
	move.b	d1,(a0)+                         	| [$024b: ld      (hl),b] store B into CoinsPerCredit2
	                           	| [$024c: inc     hl] HL := CreditsPerCoin
	move.b	d2,(a0)+                         	| [$024d: ld      (hl),c] store DE and BC into coins/credits
	                           	| [$024e: inc     hl] HL := UprightCab = memory for upright/cocktail
	jbsr	osd_read_dsw_1                         	| [$024f: ld      a,(dsw1)] load A with dipswitch settings
	rol.b	#1,d0                            	| [$0252: rlca] rotate left
	jcs	l_0259                             	| [$0255: jp      c,$0259] if carry, skip next step
	move.b	#0x01,d0                        	| [$0253: ld      a,$01] A := 1

	subq.b	#1,d0                           	| [$0258: dec     a] A := 0
	bra.b	l_0259_2
l_0259:
	move.b	#0x01,d0                        	| [$0253: ld      a,$01] A := 1
l_0259_2:
	move.b	d0,(a0)                         	| [$0259: ld      (hl),a] store into upright / cocktail


	lea	game_rom+0x3565,a0                      	| [$025a: ld      hl,$3565] source = #3565 = default high score table
	lea	high_score_ram_6100,a1         	| [$025d: ld      de,high_score_ram_6100] dest = #6100 = high score RAM
	move.w	#0xaa,d1                        	| [$0260: ld      bc,$00aa] byte counter = #AA 170
	jbsr	ldir                              	| [$0263: ldir] copy high score table into RAM
	
	* now is a good time to try to load saved highscores if they exist
	lea	high_score_ram_6100,a0         	| [$025d: ld      de,high_score_ram_6100] dest = #6100 = high score RAM
	jbsr	osd_read_high_scores
	rts                                    	| [$0265: ret] return

* come here from game power-on
* first, clear system RAM
Init_0266:
	move.b	#0x10,d1                        	| [$0266: ld      b,$10] for B = 0 to #10
	lea	ram_6000,a0                         	| [$0268: ld      hl,ram] set destination
	clr.b	d0                               	| [$026b: xor     a] A := 0

l_026c:
	move.b	d0,d2                           	| [$026c: ld      c,a] For C = 0 to #FF

l_026d:
	move.b	d0,(a0)+                         	| [$026d: ld      (hl),a] store 0 into memory
	                           	| [$026e: inc     hl] next location
	subq.b	#1,d2                           	| [$026f: dec     c] Next C
	jne	l_026d                             	| [$0270: jr      nz,$026d] Loop until done

	subq.b	#1,d1                           	| [...]
	jne	l_026c                             	| [$0272: djnz    $026c] Next B

* clears sprite memory

	move.b	#0x04,d1                        	| [$0274: ld      b,$04] For B = 1 to 4
	lea	sprite_ram,a0                  	| [$0276: ld      hl,sprite_ram] load HL with start address
l_0279:
	move.b	d0,d2                           	| [$0279: ld      c,a] For C = 0 to #FF

l_027a:
	move.b	d0,(a0)+                         	| [$027a: ld      (hl),a] Clear this memory
	                           	| [$027b: inc     hl] next memory
	subq.b	#1,d2                           	| [$027c: dec     c] Next C
	jne	l_027a                             	| [$027d: jr      nz,$027a] loop until done

	subq.b	#1,d1                           	| [...]
	jne	l_0279                             	| [$027f: djnz    $0279] Next B

* this subroutine clears the VIDEO RAM with #10 (clear shape)

	move.b	#0x04,d1                        	| [$0281: ld      b,$04] for B = 1 to 4
	move.b	#0x10,d0                        	| [$0283: ld      a,$10] #10 is the code for clear on the screen
	move.w	#0x7400,d7                      	| [$0285: ld      hl,$7400] load HL with beginning of graphics memory

l_0288:
	clr.b	d2                               	| [$0288: ld      c,$00] For C = 1 to #FF

l_028a:
	jbsr	osd_w_videoram                         	| [$028a: ld      (hl),a] load clear into video RAM
	addq.w	#1,d7                           	| [$028b: inc     hl] next location
	subq.b	#1,d2                           	| [$028c: dec     c]
	jne	l_028a                             	| [$028d: jr      nz,$028a] Next C

	subq.b	#1,d1                           	| [...]
	jne	l_0288                             	| [$028f: djnz    $0288] Next B

* Loads #60C0 to #60FF (task list) with #FF

	lea	start_of_task_list_60c0,a0     	| [$0291: ld      hl,start_of_task_list_60c0] HL points to start of task list
	move.b	#0x40,d1                        	| [$0294: ld      b,$40] For B = 1 to #40
	st.b	d0                                	| [$0296: ld      a,$ff] load A with code for no task

l_0298:
	move.b	d0,(a0)+                         	| [$0298: ld      (hl),a] store into task location
										| [$0299: inc     hl] next location
	subq.b	#1,d1                           	| [...]
	jne	l_0298                             	| [$029a: djnz    $0298] Next B

* reset some memories to 0 and 1

	move.b	#0xc0,d0                        	| [$029c: ld      a,$c0] load A with #C0 for the #60B0 and #60B1 timers
	move.b	d0,task_list_pointer_60b0       	| [$029e: ld      (task_list_pointer_60b0),a] store into timer
	move.b	d0,the_task_pointer_60b1        	| [$02a1: ld      (the_task_pointer_60b1),a] store into timer
	clr.b	d0                               	| [$02a4: xor     a] A := 0
	move.b	d0,reg_sprite                   	| [$02a5: ld      (reg_sprite),a] Clear dkong_spritebank_w  /* 2 PSL Signal */

	move.b	d0,reg_palette_a                	| [$02a8: ld      (reg_palette_a),a] clear palette bank selector
	move.b	d0,reg_palette_b                	| [$02ab: ld      (reg_palette_b),a] clear palette bank selector
	jbsr	osd_update_palette_bank
	addq.b	#1,d0                           	| [$02ae: inc     a] A: = 1
	move.b	d0,reg_flipscreen               	| [$02af: ld      (reg_flipscreen),a] set flip screen setting
	lea     stack_pointer_6c00,sp				|  ld      sp,stack_pointer_6c00    | set Stack Pointer to #6C00
	jbsr	clear_all_sounds_011c                            	| [$02b5: call    $011c] clear all sounds
	move.b	#0x01,d0                        	| [$02b8: ld      a,$01] A := 1
	jbsr	osd_interrupt_control            	| [$02ba: ld      (reg_vblank_enable),a] enable interrupts

*
* arrive after RET encountered after #0306 jump
* check for tasks and do them if they exist
*

l_02bd:
	lea		ram_6000,a0	                    	| [$02bd: ld      h,$60] HL := #60xx
	moveq	#0,d0
	move.b	the_task_pointer_60b1,d0        	| [$02bf: ld      a,(the_task_pointer_60b1)] load A with task pointer
												| [$02c2: ld      l,a] copy to L.  HL now has #60XX which is the current task
	add.w	d0,a0
	move.b	(a0),d0                         	| [$02c3: ld      a,(hl)] load A with task
	add.b	d0,d0                            	| [$02c4: add     a,a] double.  Is there a task to do ?
	jcc	l_02e3                             	| [$02c5: jr      nc,$02e3] yes, skip ahead to handle task

	jbsr	l_0315                            	| [$02c7: call    $0315] else flash the "1UP" above the score when it is time to do so
	jbsr	l_0350                            	| [$02ca: call    $0350] check for and handle awarding extra lives
	lea	rngtimer2_6019,a0              	| [$02cd: ld      hl,rngtimer2_6019] load HL with timer
	addq.b	#1,(a0)                         	| [$02d0: inc     (hl)] increase the timer
	lea	memory_used_to_track_tasks_6383,a0	| [$02d1: ld      hl,memory_used_to_track_tasks_6383] load HL with address of memory used to track tasks
	move.b	framecounter_601a,d0            	| [$02d4: ld      a,(framecounter_601a)] load A with timer that constantly counts down from #FF to 0
	cmp.b	(a0),d0                          	| [$02d7: cp      (hl)] equal ?
	jeq	l_02bd                             	| [$02d8: jr      z,$02bd] yes, loop back to check for more tasks

	move.b	d0,(a0)                         	| [$02da: ld      (hl),a] else store A into the memory, for next time
	jbsr	l_037f                            	| [$02db: call    $037f] check for updating of difficulty
	jbsr	l_03a2                            	| [$02de: call    $03a2] check for releasing fires on girders and conveyors
	jra	l_02bd                             	| [$02e1: jr      $02bd] loop back to check for more tasks

* arrive from #02C5
* loads data from the task list at #60C0 through #60CF
* tasks are loaded in subroutine at #309F
* HL is preloaded with task pointer
* A is preloaded with 2x the task number

l_02e3:
	and.b	#0x1f,d0                         	| [$02e3: and     $1f] mask bits.  A now between 0 and #1F
	clr.w	d3                               	| [$02e6: ld      d,$00] D := 0
	move.b	d0,d3                           	| [$02e5: ld      e,a] copy to E
	st.b	(a0)+                      	| [$02e8: ld      (hl),$ff] overwrite the task with empty entry
	                           	| [$02ea: inc     l] next HL
	move.b	(a0),d2                         	| [$02eb: ld      c,(hl)] load C with the 2nd byte of the task (parameter)
	st.b	(a0)+                      	| [$02ec: ld      (hl),$ff] overwrite the task with empty entry
	                           	| [$02ee: inc     l] next HL
	move.l	a0,d0                           	| [$02ef: ld      a,l] load A with low byte of the address
	sub.l	#ram_6000,d0			| this is RAM based just sub base
	cmp.b	#0xc0,d0                         	| [$02f0: cp      $c0] < #C0 ?
	jcc	l_02f6                             	| [$02f2: jr      nc,$02f6] no, skip next step

	move.b	#0xc0,d0                        	| [$02f4: ld      a,$c0] reset low byte to #C0

l_02f6:
	move.b	d0,the_task_pointer_60b1        	| [$02f6: ld      (the_task_pointer_60b1),a] store into the task pointer
	move.b	d2,d0                           	| [$02f9: ld      a,c] load A with the 2nd byte of the task
	pea		l_02bd(pc)                     	| [$02fa: ld      hl,$02bd] load HL with return address

	                        	| [$02fd: push    hl] push to stack so RET will go to #02BD = task list
	lea	jump_table_0307,a0                      	| [$02fe: ld      hl,$0307] load HL with data from table below
	add.w	d3,a0                            	| [$0301: add     hl,de] add the offset based on byte 1 of the task
	add.w	d3,a0                            	| [$0301: add     hl,de] add the offset based on byte 1 of the task
	move.l	(a0),a0                         	| [$0302: ld      e,(hl)] load E with the low byte from the table below
												| [$0303: inc     hl] next HL
												| [$0304: ld      d,(hl)] load D with the high byte from the table
											| [$0305: ex      de,hl] DE <> HL
	jra	(a0)                               	| [$0306: jp      (hl)] jump to address from the table

* data for jump table used above
* task table

jump_table_0307:
	.long	add_to_score_051c                             | #051C | 0, for adding to score.  parameter is score in hundreds
	.long	l_059b                             | #059B | 1, clears and displays scores.  parameter 0 for p1, 1 for p2
	.long	l_05c6                             | #05C6 | 2, displays score.  0 for p1, 1 for p2, 2 for highscore
	.long	draw_text_to_screen_05e9                             | #05E9 | 3, used to draw text.  parameter is code for text to draw
	.long	l_0611                             | #0611 | 4, draws credits on screen if any are present
	.long	l_062a                             | #062A | 5, parameter 0 adds bonus to player's score , parameter 1 update onscreen bonus timer and play sound & change to red if below 1000
	.long	l_06b8                             | #06B8 | 6, draws remaining lives and level number.  parameter 1 to draw lives-1

* called from #02C7
* flashes 1UP or 2UP

l_0315:
	move.b	timer_constantly_counts_down_601a,d0	| [$0315: ld      a,(timer_constantly_counts_down_601a)] load A with timer constantly counts down from FF to 00 and then FF to 00 again and again ... 1 count per frame
	move.b	d0,d1                           	| [$0318: ld      b,a] copy to B
	and.b	#0x0f,d0                         	| [$0319: and     $0f] mask bits, now between 0 and #F.  Is it zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$031b: ret     nz] no, return [...]
0:

	jbsr	rst_08                            	| [$031c: rst     $8] if credits exist or someone is playing, continue.  else RET

	move.b	playerturna_600d,d0             	| [$031d: ld      a,(playerturna_600d)] Load A with player # (0 for player 1, 1 for player 2)
	jbsr	load_score_location_0347                            	| [$0320: call    $0347] Loads HL with location for score (either player 1 or 2)
	move.w	#0xffe0,d3                      	| [$0323: ld      de,$ffe0] load DE with offset for each column
	btst.b	#4,d1                           	| [$0326: bit     4,b] test bit 4 of timer.  Is it zero ?
	jeq	l_033e                             	| [$0328: jr      z,$033e] yes, skip ahead

	move.b	#0x10,d0                        	| [$032a: ld      a,$10] A := #10 = blank character
	jbsr	osd_w_videoram                         	| [$032c: ld      (hl),a] clear the text "1" from "1UP" or "2" from "2UP"
	add.w	d3,d7                            	| [$032d: add     hl,de] add offset for next column
	jbsr	osd_w_videoram                         	| [$032e: ld      (hl),a] clear the text "U" from "1UP"
	add.w	d3,d7                            	| [$032f: add     hl,de] next column
	jbsr	osd_w_videoram                         	| [$0330: ld      (hl),a] clear the text "P" from "1UP"
	move.b	twoplayergame_600f,d0           	| [$0331: ld      a,(twoplayergame_600f)] load A with # of players in game
	                               	| [$0334: and     a] is this a 1 player game?
	bne.b	0f                               	| [...]
	rts                                    	| [$0335: ret     z] yes, return [...]
0:

	move.b	playerturna_600d,d0             	| [$0336: ld      a,(playerturna_600d)] Load current player #
	eor.b	#0x01,d0                         	| [$0339: xor     $01] change player from 1 to 2 or from 2 to 1
	jbsr	load_score_location_0347                            	| [$033b: call    $0347] Loads HL with location for score (either player 1 or 2)

l_033e:
	addq.b	#1,d0                           	| [$033e: inc     a] increase A, now it has the number of the player
	jbsr	osd_w_videoram                         	| [$033f: ld      (hl),a] draw player number on screen
	add.w	d3,d7                            	| [$0340: add     hl,de] next column
	move.w	d0,-(a7)
	move.b	#0x25,d0                      	| [$0341: ld      (hl),$25] draw "U" on screen
	jbsr	osd_w_videoram
	add.w	d3,d7                            	| [$0343: add     hl,de] next column
	move.b	#0x20,d0                      	| [$0344: ld      (hl),$20] draw "P" on screen
	jbsr	osd_w_videoram
	move.w	(a7)+,d0
	rts                                    	| [$0346: ret] return

* called from #033B

load_score_location_0347:
	move.w	#0x7740,d7                      	| [$0347: ld      hl,$7740] for player 1 HL gets #7740 VRAM address
	tst.b	d0                               	| [$034a: and     a] is this player 2?
	bne.b	0f                               	| [...]
	rts                                    	| [$034b: ret     z] no, then return [...]
0:

	move.w	#0x74e0,d7                      	| [$034c: ld      hl,$74e0] player 2 gets #74E0 location on screen
	rts                                    	| [$034f: ret] return

* called from #02CA
* checks for and handles extra life

l_0350:
	move.b	extra_life_indicator_622d,d0    	| [$0350: ld      a,(extra_life_indicator_622d)] load A with high score indicator
	                               	| [$0353: and     a] has this player already been awarded extra life?
	beq.b	0f                               	| [...]
	rts                                    	| [$0354: ret     nz] yes, return [...]
0:

	lea	address_for_player_1_score_60b3,a0	| [$0355: ld      hl,address_for_player_1_score_60b3] load HL with address for player 1 score
	move.b	playerturna_600d,d0             	| [$0358: ld      a,(playerturna_600d)] load A with 0 when player 1 is up, 1 when player 2 is up
	                               	| [$035b: and     a] player 1 up ?
	jeq	l_0361                             	| [$035c: jr      z,$0361] yes, skip next step

	lea	address_of_player_2_score_60b6,a0	| [$035e: ld      hl,address_of_player_2_score_60b6] else load HL with address of player 2 score

l_0361:
	move.b	(a0)+,d0                         	| [$0361: ld      a,(hl)] load A with a byte of the player's score
	and.b	#0xf0,d0                         	| [$0362: and     $f0] mask bits
	move.b	d0,d1                           	| [$0364: ld      b,a] copy to B
	                           	| [$0365: inc     hl] next score byte
	move.b	(a0),d0                         	| [$0366: ld      a,(hl)] load A with byte of player's score
	and.b	#0x0f,d0                         	| [$0367: and     $0f] mask bits
	or.b	d1,d0                             	| [$0369: or      b] mix together the 2 score bytes
	ror.b	#4,d0                            	| [$036a: rrca] * 4
	lea	extralifethreshold_6021,a0     	| [$036e: ld      hl,extralifethreshold_6021] load HL with score needed for extra life
	cmp.b	(a0),d0                          	| [$0371: cp      (hl)] compare player's score to high score.  is it greater?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0372: ret     c] no, return [...]
0:

	move.b	#0x01,d0                        	| [$0373: ld      a,$01] A := 1
	move.b	d0,extra_life_indicator_622d    	| [$0375: ld      (extra_life_indicator_622d),a] store into extra life indicator
	lea	number_of_lives_remaining_6228,a0	| [$0378: ld      hl,number_of_lives_remaining_6228] load HL with address of number of lives remaining
	addq.b	#1,(a0)                         	| [$037b: inc     (hl)] increase
	jra	l_06b8                             	| [$037c: jp      $06b8] skip ahead and update # of lives on the screen

* called from #02DB
* checks timers and increments difficulty if needed

* [timer_6384++ | IF timer_6384 != 256 THEN RETURN | timer_6384 := 0 | ]

l_037f:
	lea	timer_address_6384,a0          	| [$037f: ld      hl,timer_address_6384] load HL with timer address
	move.b	(a0),d0                         	| [$0382: ld      a,(hl)] load A with the timer
	addq.b	#1,(a0)                         	| [$0383: inc     (hl)] increase the timer
	tst.b	d0                               	| [$0384: and     a] was the timer at zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$0385: ret     nz] no, return [...]
0:

* [timer_6381++ | IF (timer_6381/8) != INT(timer_6381/8) THEN RETURN]

	lea	timer_6381,a0                  	| [$0386: ld      hl,timer_6381] load HL with timer
	move.b	(a0),d0                         	| [$0389: ld      a,(hl)] load A with timer value
	move.b	d0,d1                           	| [$038a: ld      b,a] copy to B
	addq.b	#1,(a0)                         	| [$038b: inc     (hl)] increase timer
	and.b	#0x07,d0                         	| [$038c: and     $07] mask bits.  are right 3 bits == #000 ? does for every 8 steps of #6381
	beq.b	0f                               	| [...]
	rts                                    	| [$038e: ret     nz] no, return [...]
0:

* increase difficulty if not at max

* [ difficulty := (timer_6381 div 8) + level | IF difficulty > 5 THEN difficulty := 5 | RETURN]

	move.b	d1,d0                           	| [$038f: ld      a,b] load A with original timer value
	ror.b	#3,d0                            	| [$0390: rrca] roll right 3 times... (div 8) * 3
	move.b	d0,d1                           	| [$0393: ld      b,a] store result into B
	move.b	level_number_6229,d0       	| [$0394: ld      a,(level_number_6229)] load A with level number
	add.b	d1,d0                            	| [$0397: add     a,b] add B to A
	cmp.b	#0x05,d0                         	| [$0398: cp      $05] is this answer > 5 ?
	jcs	l_039e                             	| [$039a: jr      c,$039e] no, skip next step

	move.b	#0x05,d0                        	| [$039c: ld      a,$05] otherwise A := 5

l_039e:
	move.b	d0,difficulty_level_6380                 	| [$039e: ld      (difficulty_level_6380),a] store result into difficulty
l_03A1:
	rts  | [ret] return to #02DE

* called from #02DE

l_03a2:
	move.b	#0x03,d0                        	| [$03a2: ld      a,$03] A := 3 = 0011 binary
	jbsr	only_continues_if_given_level_0030                            	| [$03a4: rst     $30] only continue if level is girders or conveyors, else RET

	jbsr	continue_only_if_mario_alive_0010                            	| [$03a5: rst     $10] if mario is alive, continue, else RET

	move.b	item_hit_indicator_unknown_6350,d0	| [$03a6: ld      a,(item_hit_indicator_unknown_6350)] load A with 1 when an item has been hit with hammer
	ror.b	#1,d0                            	| [$03a9: rrca] has an item been hit with the hammer ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$03aa: ret     c] yes, return, we don't do anything here while hammer hits occur [...]
0:

	lea	this_counter_62b8,a0           	| [$03ab: ld      hl,this_counter_62b8] load HL with this counter
	subq.b	#1,(a0)                         	| [$03ae: dec     (hl)] decrease.  at zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$03af: ret     nz] no, return [...]
0:

	move.b	#0x04,(a0)                      	| [$03b0: ld      (hl),$04] yes, reset counter to 4
	move.b	fire_release_62b9,d0            	| [$03b2: ld      a,(fire_release_62b9)] load A with fire release indicator
	ror.b	#1,d0                            	| [$03b5: rrca] roll right.  carry?  Is there a fire onscreen or is it time to release a new fire?
	bcs.b	0f                               	| [...]
	rts                                    	| [$03b6: ret     nc] no, return [...]
0:

* a fire is onscreen or to be released

	lea	sprite_for_fire_above_oil_can_6a29,a0	| [$03b7: ld      hl,sprite_for_fire_above_oil_can_6a29] load HL with sprite for fire above oil can
	move.b	#0x40,d1                        	| [$03ba: ld      b,$40] B := #40
	lea	oil_can_address_66a0,a2        	| [$03bc: ld      ix,oil_can_address_66a0] load IX with fire array start ?
	ror.b	#1,d0                            	| [$03c0: rrca] roll A right again.  carry ?  Is it time to release another fire?
	jcc	l_03e4                             	| [$03c1: jp      nc,$03e4] no, skip ahead, animate oilcan, reset timer and return

* release a fire

	move.b	#0x02,(0x09,a2)                 	| [$03c4: ld      (ix+$09),$02] store 2 into sprite +9 indicator (size ???)
	move.b	#0x02,(0x0a,a2)                 	| [$03c8: ld      (ix+$0a),$02] store 2 into sprite +#A indicator (size ???)
	addq.b	#2,d1                           	| [$03cc: inc     b] * 2
	jbsr	l_03f2                            	| [$03ce: call    $03f2] randomly store B or B+1 into (HL) - animates the oilcan fire with extra fire
	lea	timer_reset_62ba,a0            	| [$03d1: ld      hl,timer_reset_62ba] load HL with this timer.  usually it is set at #10 when a level begins
	subq.b	#1,(a0)                         	| [$03d4: dec     (hl)] decrease timer.  zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$03d5: ret     nz] no, return [...]
0:

* release a fire, or do something when fires already exist

	move.b	#0x01,d0                        	| [$03d6: ld      a,$01] A := 1
	move.b	d0,fire_release_62b9            	| [$03d8: ld      (fire_release_62b9),a] store into fire release indicator
	move.b	d0,unknown_63a0                 	| [$03db: ld      (unknown_63a0),a] store into other fireball release indicator

l_03de:
	move.b	#0x10,d0                        	| [$03de: ld      a,$10] A := #10
	move.b	d0,timer_reset_62ba             	| [$03e0: ld      (timer_reset_62ba),a] reset timer back to #10
	rts                                    	| [$03e3: ret] return

l_03e4:
	move.b	#0x02,(0x09,a2)                 	| [$03e4: ld      (ix+$09),$02] set +9 to 2 (size ???)
	clr.b	(0x0a,a2)                        	| [$03e8: ld      (ix+$0a),$00] set +A to 0 (size ???)
	jbsr	l_03f2                            	| [$03ec: call    $03f2] randomly store B or B+1 into (HL) - animates the oilcan fire
	jra	l_03de                             	| [$03ef: jp      $03de] skip back, reset timer, and return

* called from #03CE and #03EC above
* animates the oilcan fire

l_03f2:
	move.b	d1,(a0)                         	| [$03f2: ld      (hl),b] store B into (HL) - set the oilcan fire sprite
	move.b	rngtimer2_6019,d0               	| [$03f3: ld      a,(rngtimer2_6019)] load A with random number
	ror.b	#1,d0                            	| [$03f6: rrca] rotate right.  carry ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$03f7: ret     c] yes, return [...]
0:

	addq.b	#1,d1                           	| [$03f8: inc     b] else increase B
	move.b	d1,(a0)                         	| [$03f9: ld      (hl),b] store B into (HL) - set the oilcan fire sprite with higher value
	rts                                    	| [$03fa: ret] return

* called from main routine at #19B0
* animates kong, checks for kong beating chest, animates girl and her screams for help

l_03fb:
	move.b	screen_number_6227,d0           	| [$03fb: ld      a,(screen_number_6227)] load A with screen number
	cmp.b	#0x02,d0                         	| [$03fe: cp      $02] are we on the conveyors?
	jne	l_0413                             	| [$0400: jp      nz,$0413] no, skip ahead

* conveyors

	lea	start_of_kong_sprite_6908,a0   	| [$0403: ld      hl,start_of_kong_sprite_6908] load HL with kongs sprite start
	move.b	top_conveyor_direction_vector_63a3,d0	| [$0406: ld      a,(top_conveyor_direction_vector_63a3)] load A with kongs direction
	move.b	d0,d2                           	| [$0409: ld      c,a] copy to C for subroutine below
	jbsr	rst_38                            	| [$040a: rst     $38] move kong
	move.b	kongs_x_position_6910,d0        	| [$040b: ld      a,(kongs_x_position_6910)] load A with kong's X position
	sub.b	#0x3b,d0                         	| [$040e: sub     $3b] subtract #3B (59 decimal)
	move.b	d0,kongs_position_63b7          	| [$0410: ld      (kongs_position_63b7),a] store into kong's position

* #6390 - counts from 0 to 7F periodically
* #6391 - is 0, then changed to 1 when timer in #6390 is counting up

l_0413:
	move.b	indicator_6391,d0               	| [$0413: ld      a,(indicator_6391)] load A with indicator
	                               	| [$0416: and     a] == 0 ?
	jne	l_0426                             	| [$0417: jp      nz,$0426] no, skip next 5 steps

	move.b	framecounter_601a,d0            	| [$041a: ld      a,(framecounter_601a)] else load A with this clock counts down from #FF to 00 over and over...
	                               	| [$041d: and     a] == 0 ?
	jne	l_0486                             	| [$041e: jp      nz,$0486] no, skip ahead

	move.b	#0x01,d0                        	| [$0421: ld      a,$01] else A := 1
	move.b	d0,indicator_6391               	| [$0423: ld      (indicator_6391),a] store into indicator

l_0426:
	lea	timer_unknown_6390,a0          	| [$0426: ld      hl,timer_unknown_6390] load HL with timer
	addq.b	#1,(a0)                         	| [$0429: inc     (hl)] increase
	move.b	(a0),d0                         	| [$042a: ld      a,(hl)] load A with timer value
	cmp.b	#0x80,d0                         	| [$042b: cp      $80] == #80 ?
	jeq	l_0464                             	| [$042d: jp      z,$0464] yes, skip ahead

	move.b	barrel_deployment_indicator_6393,d0	| [$0430: ld      a,(barrel_deployment_indicator_6393)] else get barrel deployment
	                               	| [$0433: and     a] is a barrel deployment in progress?
	jne	l_0486                             	| [$0434: jp      nz,$0486] yes, jump ahead

	move.b	(a0),d0                         	| [$0437: ld      a,(hl)] else load A with timer
	move.b	d0,d1                           	| [$0438: ld      b,a] copy to B
	and.b	#0x1f,d0                         	| [$0439: and     $1f] mask bits, now == 0 ?
	jne	l_0486                             	| [$043b: jp      nz,$0486] no, skip ahead

	lea	game_rom+0x39cf,a0                      	| [$043e: ld      hl,$39cf] else load HL with start of table data
	btst.b	#5,d1                           	| [$0441: bit     5,b] is bit 5 turned on timer ?  (1/8 chance???)
	jne	l_0448                             	| [$0443: jr      nz,$0448] no, skip ahead

* kong is beating his chest

	lea	game_rom+0x39f7,a0                      	| [$0445: ld      hl,$39f7] start of table data
l_0448:
	jbsr	update_kong_sprites_004e                            	| [$0448: call    $004e] update kong's sprites
	move.b	#0x03,d0                        	| [$044b: ld      a,$03] load sound duration of 3
	move.b	d0,boom_sound_address_6082      	| [$044d: ld      (boom_sound_address_6082),a] play boom sound using sound buffer
	move.w	#BOOM_SND,d0
	jbsr	osd_sound_start
l_0450:
	move.b	screen_number_6227,d0           	| [$0450: ld      a,(screen_number_6227)] load A with screen number
	ror.b	#1,d0                            	| [$0453: rrca] is this the girders or the elevators ?
	jcc	l_0478                             	| [$0454: jp      nc,$0478] no, skip ahead

	ror.b	#1,d0                            	| [$0457: rrca] else is this the rivets ?
	jcs	l_0486                             	| [$0458: jp      c,$0486] yes, skip ahead

* else pie factory

	lea	kong_sprite_array_690b,a0      	| [$045b: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite data
	move.b	#0xfc,d2                        	| [$045e: ld      c,$fc] C := #FC.  used in sub below to move kong by -4
	jbsr	rst_38                            	| [$0460: rst     $38] move kong
	jra	l_0486                             	| [$0461: jp      $0486] skip ahead

* arrive here from #042D when timer in #6390 is #80

l_0464:
	clr.b	d0                               	| [$0464: xor     a] A := 0
	move.b	d0,(a0)+                         	| [$0465: ld      (hl),a] clear timer
												| [$0466: inc     hl] increase address to #6391
	move.b	d0,(a0)                         	| [$0467: ld      (hl),a] clear this one too
	move.b	barrel_deployment_indicator_6393,d0	| [$0468: ld      a,(barrel_deployment_indicator_6393)] Load Barrel deployment indicator
	                               	| [$046b: and     a] is a deployment in progress?
	jne	l_0486                             	| [$046c: jp      nz,$0486] yes, jump ahead

	lea	game_rom+0x385c,a0                      	| [$046f: ld      hl,$385c] else load HL with start of table data for kongs sprites
	jbsr	update_kong_sprites_004e                            	| [$0472: call    $004e] update kong's sprites
	jra	l_0450                             	| [$0475: jp      $0450] jump back

* arrive here from #0454 when on rivets and conveyors
* moves kong, updates girl and her screams for help

l_0478:
	lea	start_of_kong_sprite_6908,a0   	| [$0478: ld      hl,start_of_kong_sprite_6908] load HL with start of kong sprite X position
	move.b	#0x44,d2                        	| [$047b: ld      c,$44] set offset to #44, used only on rivets
	ror.b	#1,d0                            	| [$047d: rrca] roll screen number right (again).  is this the conveyors screen?
	jcc	l_0485                             	| [$047e: jp      nc,$0485] no, skip next 2 steps

	move.b	kongs_position_63b7,d0          	| [$0481: ld      a,(kongs_position_63b7)] load A with kong's position
	move.b	d0,d2                           	| [$0484: ld      c,a] copy to C for sub below, controls position of kong

l_0485:
	jbsr	rst_38                            	| [$0485: rst     $38] move kong to his position

l_0486:
	move.b	timer_unknown_6390,d0           	| [$0486: ld      a,(timer_unknown_6390)] load A with timer
	move.b	d0,d2                           	| [$0489: ld      c,a] copy to C
	move.w	#0x0020,d3                      	| [$048a: ld      de,$0020] DE := #20, used for offset in call at #04A6 32
	move.b	screen_number_6227,d0           	| [$048d: ld      a,(screen_number_6227)] load A with screen number
	cmp.b	#0x04,d0                         	| [$0490: cp      $04] are we on the rivets level?
	jeq	l_04be                             	| [$0492: jp      z,$04be] yes, jump ahead to handle

	move.b	d2,d0                           	| [$0495: ld      a,c] load A with the timer
	                               	| [$0496: and     a] == 0 ?
	jeq	l_04a1                             	| [$0497: jp      z,$04a1] yes, skip next 3 steps

	move.b	#0xef,d0                        	| [$049a: ld      a,$ef] else A := #EF
	btst.b	#6,d2                           	| [$049c: bit     6,c] is bit 6 of the timer set ?
	jne	l_04a3                             	| [$049e: jp      nz,$04a3] no, skip next step

l_04a1:
	move.b	#0x10,d0                        	| [$04a1: ld      a,$10] A := #10

l_04a3:
	move.w	#0x75c4,d7                      	| [$04a3: ld      hl,$75c4] load HL with address of a location in video RAM where girl yells "HELP"
	jbsr	clear_help_0514                            	| [$04a6: call    $0514] update girl yelling "HELP"
	move.b	girls_sprite_6905,d0            	| [$04a9: ld      a,(girls_sprite_6905)] load A with girl's sprite

l_04ac:
	move.b	d0,girls_sprite_6905            	| [$04ac: ld      (girls_sprite_6905),a] store girl's sprite
	btst.b	#6,d2                           	| [$04af: bit     6,c] is bit 6 of the timer set ?
	bne.b	0f                               	| [...]
	rts                                    	| [$04b1: ret     z] yes, return [...]
0:

	move.b	d0,d1                           	| [$04b2: ld      b,a] else B := A
	move.b	d2,d0                           	| [$04b3: ld      a,c] A := C (timer)
	and.b	#0x07,d0                         	| [$04b4: and     $07] mask bits, now betwen 0 and 7.  zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$04b6: ret     nz] no, return [...]
0:

	move.b	d1,d0                           	| [$04b7: ld      a,b] restore A which has girl's sprite
	eor.b	#0x03,d0                         	| [$04b8: xor     $03] toggle bits 0 and 1
	move.b	d0,girls_sprite_6905            	| [$04ba: ld      (girls_sprite_6905),a] store into girl's sprite
	rts                                    	| [$04bd: ret] return to #19B3 - main routine

* arrive here when we are on the rivets level

l_04be:
	move.b	#0x10,d0                        	| [$04be: ld      a,$10] A := #10 = code for clear space
	move.w	#0x7623,d7                      	| [$04c0: ld      hl,$7623] load HL with video RAM for girl location
	jbsr	clear_help_0514                            	| [$04c3: call    $0514] clear the "help" the girl yells on the left side
	move.w	#0x7583,d7                      	| [$04c6: ld      hl,$7583] load HL with video RAM right of girl
	jbsr	clear_help_0514                            	| [$04c9: call    $0514] clear the "help" the girl yells on the right side
	btst.b	#6,d2                           	| [$04cc: bit     6,c] check timer bit 6.  zero?
	jeq	l_0509                             	| [$04ce: jp      z,$0509] yes, skip ahead

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$04d1: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario X position
	cmp.b	#0x80,d0                         	| [$04d4: cp      $80] is mario on left side of screen ?
	jcc	l_04f1                             	| [$04d6: jp      nc,$04f1] yes, skip ahead

	move.b	#0xdf,d0                        	| [$04d9: ld      a,$df] else A := #DF
	move.w	#0x7623,d7                      	| [$04db: ld      hl,$7623] load HL with video RAM for girl location
	jbsr	clear_help_0514                            	| [$04de: call    $0514] draw "help" on the left side

l_04e1:
	move.b	unknown_6901,d0                 	| [$04e1: ld      a,(unknown_6901)] load A with sprite used for girl
	or.b	#0x80,d0                          	| [$04e4: or      $80] set bit 7
	move.b	d0,unknown_6901                 	| [$04e6: ld      (unknown_6901),a] store into sprite used for girl
	move.b	girls_sprite_6905,d0            	| [$04e9: ld      a,(girls_sprite_6905)] load A with girl's sprite
	or.b	#0x80,d0                          	| [$04ec: or      $80] set bit 7
	jra	l_04ac                             	| [$04ee: jp      $04ac] jump back and animate girl

l_04f1:
	move.b	#0xef,d0                        	| [$04f1: ld      a,$ef] A := #EF
	move.w	#0x7583,d7                      	| [$04f3: ld      hl,$7583] load HL with video RAM for girl location
	jbsr	clear_help_0514                            	| [$04f6: call    $0514] draw "help" on the right side

l_04f9:
	move.b	unknown_6901,d0                 	| [$04f9: ld      a,(unknown_6901)] load A with sprite used for girl
	and.b	#0x7f,d0                         	| [$04fc: and     $7f] mask bits, turns off bit 7
	move.b	d0,unknown_6901                 	| [$04fe: ld      (unknown_6901),a] store result
	move.b	girls_sprite_6905,d0            	| [$0501: ld      a,(girls_sprite_6905)] load A with girl's sprite
	and.b	#0x7f,d0                         	| [$0504: and     $7f] mask bits, turns off bit 7
	jra	l_04ac                             	| [$0506: jp      $04ac] jump back and store into girl's sprite and check for animation and RET

* jump from #04CE

l_0509:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$0509: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario X position
	cmp.b	#0x80,d0                         	| [$050c: cp      $80] is mario on left side of screen?
	jcc	l_04f9                             	| [$050e: jp      nc,$04f9] yes, jump back

	jra	l_04e1                             	| [$0511: jp      $04e1] else jump back

*
* this sub gets called a lot
* d7 is preloaded with an address of video RAM
* d3 is preloaded with an offset to add
* d0 is preloaded with a value to write
* writes A into HL, A-1 into HL+DE, A-2 into HL+2DE
*

clear_help_0514:
	move.b	#0x03,d1                        	| [$0514: ld      b,$03] for B = 1 to 3

l_0516:
	jbsr	osd_w_videoram                         	| [$0516: ld      (hl),a] store A into memory
	add.w	d3,d7                            	| [$0517: add     hl,de] next memory
	subq.b	#1,d0                           	| [$0518: dec     a] decrease A
	subq.b	#1,d1                           	| [...]
	jne	l_0516                             	| [$0519: djnz    $0516] next B

	rts                                    	| [$051b: ret] return

*
* Task #0, arrive from jump at #0306
* adds score
* parameter in A is the score to add in hundreds
*

add_to_score_051c:
	move.b	d0,d2                           	| [$051c: ld      c,a] copy score to C
	jbsr	rst_08                            	| [$051d: rst     $8] only continue if credits exist or someone is playing, else RET
	jbsr	load_address_of_player_score_055f                            	| [$051e: call    $055f] load DE with address of player score
	move.b	d2,d0                           	| [$0521: ld      a,c] load score
	add.b	d2,d0                            	| [$0522: add     a,c] double
	add.b	d2,d0                            	| [$0523: add     a,c] triple
	clr.w	d1                               	| [$0528: ld      b,$00] B := 0
	move.b	d0,d1                           	| [$0524: ld      c,a] C is now 3 times A for use in the scoring table
	lea	item_scoring_table_3529,a0                      	| [$0525: ld      hl,$3529] #3529 holds table data for scoring
	add.w	d1,a0                            	| [$052a: add     hl,bc] add offset for scoring table
 	CLEAR_XC_FLAGS                               	| [$052b: and     a] clear carry flag
	move.w	#2,d1                        	| [$052c: ld      b,$03] for B = 1 to 3
l_052e:
	move.b	(a1),d0                         	| [$052e: ld      a,(de)] load A with current score
	move.b	(a0)+,d7
	abcd	D7,d0								| [adc     a,(hl) & daa]      | add the amount the player just scored + decimal adjust
	move.b	d0,(a1)+                         	| [$0531: ld      (de),a] store result in score
	* using DBF preserves X flag that abcd uses to propagate carry (else score resets to 0 after 9900)
	dbf		d1,l_052e                          	| [$0532: inc     de] next byte of score
	                           	| [$0533: inc     hl] next byte of score to add
	                           	| [...]
	                             	| [$0534: djnz    $052e] Next B

	move.l	a1,-(sp)                        	| [$0536: push    de] save DE
	subq.w	#1,a1                           	| [$0537: dec     de] DE is now the last byte of score
	move.b	playerturna_600d,d0             	| [$0538: ld      a,(playerturna_600d)] 0 for player 1, 1 for player 2
	jbsr	update_onscreen_score_056b                            	| [$053b: call    $056b] update onscreen score
	move.l	(sp)+,a1                        	| [$053e: pop     de] restore DE
	subq.w	#1,a1                           	| [$053f: dec     de] decrement
	lea	high_score_60ba,a0             	| [$0540: ld      hl,high_score_60ba] load HL with high score address
	move.b	#0x03,d1                        	| [$0543: ld      b,$03] for B = 1 to  3

l_0545:
	move.b	(a1),d0                         	| [$0545: ld      a,(de)] load A with player score
	cmp.b	(a0),d0                          	| [$0546: cp      (hl)] compare to high score
	bcc.b	0f                               	| [...]
	rts                                    	| [$0547: ret     c] if less, then return [...]
0:

	jne	l_0550                             	| [$0548: jp      nz,$0550] if greater, then skip ahead to update

	subq.w	#1,a1                           	| [$054b: dec     de] next score byte
	subq.w	#1,a0                           	| [$054c: dec     hl] next highscore byte
	subq.b	#1,d1                           	| [...]
	jne	l_0545                             	| [$054d: djnz    $0545] next B

	rts                                    	| [$054f: ret] return

l_0550:
	jbsr	load_address_of_player_score_055f                            	| [$0550: call    $055f] load DE with address of player score
	lea	high_score_60b8,a0             	| [$0553: ld      hl,high_score_60b8] load HL with high score address

l_0556:
	move.b	(a1)+,(a0)+                         	| [$0556: ld      a,(de)] load A with player score byte
							| [$0557: ld      (hl),a] store into high score byte
												| [$0558: inc     de] next address
												| [$0559: inc     hl] next address
	subq.b	#1,d1                           	| [...]
	jne	l_0556                             	| [$055a: djnz    $0556] next B

	jra	l_05da                             	| [$055c: jp      $05da] skip ahead to update high score onscreen

* called from #051E and #0550
* loads DE with address of current player's score

load_address_of_player_score_055f:
	lea	player_1_score_address_60b2,a1 	| [$055f: ld      de,player_1_score_address_60b2] load DE with player 1 score
	move.b	playerturna_600d,d0             	| [$0562: ld      a,(playerturna_600d)] load number of players
	                               	| [$0565: and     a] is this player 2 ?
	bne.b	0f                               	| [...]
	rts                                    	| [$0566: ret     z] no, return [...]
0:

	lea	player_2_score_address_60b5,a1 	| [$0567: ld      de,player_2_score_address_60b5] else load DE with player 2 score
	rts                                    	| [$056a: ret] return

* called from #053B
* update onscreen score

update_onscreen_score_056b:
	lea	0x7781,a2                      	| [$056b: ld      ix,$7781] load IX with the start of the score in video RAM (100,000's place)
	tst.b	d0                               	| [$056f: and     a] is this player 1?
	jeq	l_057c                             	| [$0570: jr      z,$057c] Yes, jump ahead

	lea	0x7521,a2                      	| [$0572: ld      ix,$7521] else load IX with #7521 - the start of player 2 score (100,000's place)
	jra	l_057c                             	| [$0576: jr      $057c] skip next step

l_0578:
	lea	0x7641,a2                      	| [$0578: ld      ix,$7641] #7641 is the start of high score 100,000 place

l_057c:
	exg	a1,a0                              	| [$057c: ex      de,hl] DE <> HL
	move.w	#0xffe0,d3                      	| [$057d: ld      de,$ffe0] offset is inverse of 20 ?  to add to next column in scoreboard
	move.b	#0x03,d1                        	| [$0580: ld      bc,$0304] For B = 1 to 3 772
	move.b	#0x04,d2                        	| [$0580: ld      bc,$0304] For B = 1 to 3 772

* can arrive here from #0627 to draw number of credits

draw_digits_0583:
	move.b	(a0),d0                         	| [$0583: ld      a,(hl)] get digit
	ror.b	#4,d0                            	| [$0584: rrca] * 4
	jbsr	draw_digit_on_screen_0593                            	| [$0588: call    $0593] draw to screen
	move.b	(a0),d0                         	| [$058b: ld      a,(hl)] get digit (again)
	jbsr	draw_digit_on_screen_0593                            	| [$058c: call    $0593] draw to screen
	subq.w	#1,a0                           	| [$058f: dec     hl] next digit
	subq.b	#1,d1                           	| [...]
	jne	draw_digits_0583                             	| [$0590: djnz    $0583] Next B

	rts                                    	| [$0592: ret] return

* called from #0588 and #058C above

draw_digit_on_screen_0593:
	and.b	#0x0f,d0                         	| [$0593: and     $0f] mask out left 4 bits of A
	exg		a2,d7
	jbsr	osd_w_videoram                     	| [$0595: ld      (ix+$00),a] store A on screen
	exg		a2,d7
	add.w	d3,a2                            	| [$0598: add     ix,de] adjust to next location
	rts                                    	| [$059a: ret] return

*
* task #1
* called from #0306
* parameter is 0 when 1 player game, 1 when 2 player game
* clears score and runs task #2 as well
*

l_059b:
	cmp.b	#0x03,d0                         	| [$059b: cp      $03] task parameter < 3 ?
	jcc	l_05bd                             	| [$059d: jp      nc,$05bd] yes, skip ahead [when would it do this???  A always 0 or 1 ???]

* #60B2, #60B3, #60B4 - player 1 score

* #60B5, #60B6, #60B7 - player 2 score

	move.w	d0,-(sp)                        	| [$05a0: push    af] save AF
	lea	player_1_score_address_60b2,a0 	| [$05a1: ld      hl,player_1_score_address_60b2] load HL with player 1 score
	tst.b	d0                               	| [$05a4: and     a] parameter == 0 ?
	jeq	l_05ab                             	| [$05a5: jp      z,$05ab] yes, skip next step

	lea	player_2_score_address_60b5,a0 	| [$05a8: ld      hl,player_2_score_address_60b5] else load HL with player 2 score
l_05ab:
	cmp.b	#0x02,d0                         	| [$05ab: cp      $02] parameter == 2 ? [when would it do this ??? A always 0 or 1 ??? ]
	jne	l_05b3                             	| [$05ad: jp      nz,$05b3] no, skip next step

	lea	high_score_60b8,a0             	| [$05b0: ld      hl,high_score_60b8] load HL with high score

l_05b3:
	                               	| [$05b3: xor     a] A := 0
	clr.b	(a0)                         	| [$05b4: ld      (hl),a] clear score
	                           	| [$05b5: inc     hl] next score memory
	clr.b	(1,a0)                         	| [$05b6: ld      (hl),a] clear score
	                           	| [$05b7: inc     hl] next score memory
	clr.b	(2,a0)                         	| [$05b8: ld      (hl),a] clear score
	move.w	(sp)+,d0                        	| [$05b9: pop     af] restore AF
	
	.ifne	OPT_START_SCORE
	cmp.l	#player_1_score_address_60b2,a0
	bne.b	0f
	move.l	#OPT_START_SCORE,d0
	move.b	d0,(2,a0)
	lsr.l	#8,d0
	move.b	d0,(1,a0)
	lsr.l	#8,d0
	move.b	d0,(a0)
0:
	.endif
	jra	l_05c6                             	| [$05ba: jp      $05c6] jump ahead to task 2

* never arrives here ???

l_05bd:
	subq.b	#1,d0                           	| [$05bd: dec     a] decrease A
	move.w	d0,-(sp)                        	| [$05be: push    af] save AF
	jbsr	l_059b                            	| [$05bf: call    $059b] ???  call myself ???
	movem.w	(sp)+,d0                        	| [$05c2: pop     af] restore AF
	bne.b	0f                               	| [...]
	rts                                    	| [$05c3: ret     z] return if Zero [...]
0:

	jra	l_05bd                             	| [$05c4: jr      $05bd] else loop again

*
* task #2 - displays score
* called from #0306 and at end of task #1, from #05BA
* parameter is 0 for player 1, 1 for player 2, and 3 for high score
*

l_05c6:
	cmp.b	#0x03,d0                         	| [$05c6: cp      $03] task parameter == 3 ?
	jeq	l_05e0                             	| [$05c8: jp      z,$05e0] yes, skip ahead to handle high score

	lea	player_1_score_60b4,a1         	| [$05cb: ld      de,player_1_score_60b4] load DE with player 1 score
	tst.b	d0                               	| [$05ce: and     a] parameter == 0 ? (1 player game)
	jeq	l_05d5                             	| [$05cf: jp      z,$05d5] yes, skip next step

	lea	player_2_score_60b7,a1         	| [$05d2: ld      de,player_2_score_60b7] else load DE with player 2 score

l_05d5:
	cmp.b	#0x02,d0                         	| [$05d5: cp      $02] parameter == 2 ?
	jne	update_onscreen_score_056b                             	| [$05d7: jp      nz,$056b] no, jump back and display score

* arrive here from #055C

l_05da:
	lea	high_score_60ba,a1             	| [$05da: ld      de,high_score_60ba] yes, load DE with high score
	jra	l_0578                             	| [$05dd: jp      $0578] jump back and display high score

l_05e0:
	subq.b	#1,d0                           	| [$05e0: dec     a] decrease A
	move.w	d0,-(sp)                        	| [$05e1: push    af] save AF
	jbsr	l_05c6                            	| [$05e2: call    $05c6] call this sub again for the lower parameter
	movem.w	(sp)+,d0                        	| [$05e5: pop     af] restore AF.  A == 0 ?  are we done?
	bne.b	0f                               	| [...]
	rts                                    	| [$05e6: ret     z] yes, return [...]
0:

	jra	l_05e0                             	| [$05e7: jr      $05e0] else loop back again

* task #3
* draws text to screen
* called from #0306 with code for text to draw in D0

draw_text_to_screen_05e9:
	moveq	#0,d7			| so move.w (sp)+,d7 sets the proper flag
	lea	game_rom+0x364b,a0                      	| [$05e9: ld      hl,$364b] start of table data
	add.b	d0,d0                            	| [$05ec: add     a,a] double the parameter
	scs		d7									| remember carry
	move.w	d7,-(sp)                        	| [$05ed: push    af] save AF to stack
	move.w	d7,-(sp)                        	| [$05ed: push    af] save AF to stack (twice, 0026 pops A0/caller)
	and.b	#0x7f,d0                         	| [$05ee: and     $7f] mask bits
	clr.w	d3                               	| [$05f1: ld      d,$00] D := 0
	move.b	d0,d3                           	| [$05f0: ld      e,a] copy to E
	add.w	d3,a0                            	| [$05f3: add     hl,de] add to table to get pointer
	move.b	(a0)+,d4                         	| [$05f4: ld      e,(hl)] load E with first byte from table
	                           	| [$05f5: inc     hl] next table entry
	move.b	(a0),d3                         	| [$05f6: ld      d,(hl)] load D with 2nd byte from table
	LOAD_D3_16_FROM_D3D4
	* can be from ROM or RAM
	LOAD_ANY_ADDRESS_BE	d3,a1
	exg	a1,a0                              	| [$05f7: ex      de,hl] DE <> HL
	
	* screen address followed by text
	move.b	(a0)+,d4                         	| [$05f8: ld      e,(hl)] load E with 1st byte from dereferenced table
	                           	| [$05f9: inc     hl] next table entry
	move.b	(a0)+,d3                         	| [$05fa: ld      d,(hl)] load D with 2ndy byte from derefernced table
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d5   | d5 has screen destination
	                           	| [$05fb: inc     hl] next table entry
	move.w	#0xffe0,d1                        	| [$05fc: ld      bc,$ffe0] load BC with offset to print characters across 65504
	exg	a0,a1                              	| [$05ff: ex      de,hl] DE <> HL.  HL now has screen destination, DE has table pointer
l_0600:
	move.b	(a1),d0                         	| [$0600: ld      a,(de)] load A with table data
	cmp.b	#0x3f,d0                         	| [$0601: cp      $3f] end of string reached?
	jeq	l_0026                             	| [$0603: jp      z,$0026] yes, return to program.  This will effectively RET twice
	move.w	d5,d7
	jbsr	osd_w_videoram                         	| [$0606: ld      (hl),a] draw letter to screen

	move.w	(sp)+,d7                        	| [$0607: pop     af] restore AF from stack.  is there a carry?
	move.w	(sp)+,d7                        	| [$0607: pop     af] restore AF from stack.  is there a carry? twice
	jeq	l_060c                             	| [$0608: jr      nc,$060c] no, skip next step

	
	exg	d5,d7
	move.b	#0x10,d0                      	| [$060a: ld      (hl),$10] yes, write a blank space to the screen
	jbsr	osd_w_videoram
	exg	d5,d7
	
l_060c:
	move.w	d7,-(sp)                        	| [$060c: push    af] save AF
	move.w	d7,-(sp)                        	| [$060c: push    af] save AF
	addq.w	#1,a1                           	| [$060d: inc     de] next table data
	add.w	d1,d5                            	| [$060e: add     hl,bc] add screen offset for next column
	jra	l_0600                             	| [$060f: jr      $0600] loop again

*
* task #4
* jump from #0306
* draws credits on screen if any are present
*

l_0611:
	move.b	nocredits_6007,d0               	| [$0611: ld      a,(nocredits_6007)] 1 when no credits have been inserted| 0 if any credits exist
	ror.b	#1,d0                            	| [$0614: rrca] credits in game ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$0615: ret     nc] yes, return [...]
0:

* called from #08F0

l_0616:
	move.b	#0x05,d0                        	| [$0616: ld      a,$05] load text code for "CREDIT"
	jbsr	draw_text_to_screen_05e9                            	| [$0618: call    $05e9] draw to screen
	lea	numcredits_6001,a0             	| [$061b: ld      hl,numcredits_6001] load HL with pointer to number of credits
	move.w	#0xffe0,d3                      	| [$061e: ld      de,$ffe0] load DE with #ffe0 = offset for columns?
	lea	0x74bf,a2                      	| [$0621: ld      ix,$74bf] load IX with screen address to draw
	move.b	#0x01,d1                        	| [$0625: ld      b,$01] B := 1
	jra	draw_digits_0583                             	| [$0627: jp      $0583] jump back to draw number of credits on screen and return

*
* task #5
* called from #0306
* parameter 0 = adds bonus to player's score
* parameter 1 = update onscreen bonus timer and play sound & change to red if below 1000

l_062a:
	tst.b	d0                               	| [$062a: and     a] parameter == 0 ?
	jeq	add_bonus_to_player_score_0691                             	| [$062b: jp      z,$0691] yes, skip ahead and add bonus to player's score

	move.b	onscreen_timer_638c,d0    	| [$062e: ld      a,(onscreen_timer_638c)] else load onscreen timer
	                               	| [$0631: and     a] timer == 0 ?
	jne	l_06a8                             	| [$0632: jp      nz,$06a8] no, jump ahead

	tst.b	mario_dead_flag_63b8         	| [$0635: ld      a,(mario_dead_flag_63b8)] else load A with timer expired indicator
	                               	| [$0638: and     a] has timer expired ?
	beq.b	0f                               	| [...]
	rts                                    	| [$0639: ret     nz] yes, return [...]
0:

* the following code sets up the on screen timer initial value

	move.b	initial_clock_value_62b0,d0     	| [$063a: ld      a,(initial_clock_value_62b0)] load a with value from #62B0 (expects a decimal number here)
	move.b	#0x00,d1                        	| [$063d: ld      bc,$000a] B := 0, C := #0A (10 decimal) 10
	move.b	#0x0a,d2                        	| [$063d: ld      bc,$000a] B := 0, C := #0A (10 decimal) 10

l_0640:
	addq.b	#1,d1                           	| [$0640: inc     b] increment b
	sub.b	d2,d0                            	| [$0641: sub     c] subtract 10 decimal from A
	jne	l_0640                             	| [$0642: jp      nz,$0640] loop again if not zero| counts how many tens there are

	move.b	d1,d0                           	| [$0645: ld      a,b] load a with the number of tens in the counter
	rol.b	#4,d0                            	| [$0646: rlca] rotate left (x2) * 4
	move.b	d0,onscreen_timer_638c    	| [$064a: ld      (onscreen_timer_638c),a] load on screen timer with result.  hex value converts to decimal.


	lea	game_rom+0x384a,a0                      	| [$064d: ld      hl,$384a] load HL with #384A - table data
	move.w	#0x7465,d7                      	| [$0650: ld      de,$7465] load DE with #7465 - screen location for bonus timer
	move.b	#0x06,d0                        	| [$0653: ld      a,$06] For A = 1 to 6

* draws timer box on screen with all zeros

l_0655:
	                      	| [$0655: ld      ix,$001d] load IX with #001D offset used for each column 29
	move.w	#0x03-1,d1                        	| [$0659: ld      bc,$0003] counter := 3 3
	move.w	D0,-(a7)
0:
	move.b	(a0)+,d0                              	| [$065c: ldir] transfer (HL) to (DE) 3 times
	jbsr	osd_w_videoram
	addq	#1,d7
	dbf		d1,0b
	add.w	#0x1d,d7                            	| [$065e: add     ix,de] add offset DE to IX
	move.w	(a7)+,d0											| [$0660: push    ix]
												| [$0662: pop     de] load DE with IX
	subq.b	#1,d0                           	| [$0663: dec     a] decrease counter
	jne	l_0655                             	| [$0664: jp      nz,$0655] loop again if not zero

* check to see if timer is below 1000

	move.b	onscreen_timer_638c,d0    	| [$0667: ld      a,(onscreen_timer_638c)] load a with value from on screen timer

l_066a:
	move.b	d0,d2                           	| [$066a: ld      c,a] copy to C
	and.b	#0x0f,d0                         	| [$066b: and     $0f] zeroes out left 4 bits
	move.b	d0,d1                           	| [$066d: ld      b,a] store result in B
	move.b	d2,d0                           	| [$066e: ld      a,c] restore a with original value from timer
	ror.b	#4,d0                            	| [$066f: rrca] rotate right 4 times.  divides by 16 * 4
	and.b	#0x0f,d0                         	| [$0673: and     $0f] and with #0F - zero out left 4 bits
	jne	l_0689                             	| [$0675: jp      nz,$0689] jump if not zero to #0689

* arrive here when timer runs below 1000

	move.b	#MUS_OUTATIME,d0                        	| [$0678: ld      a,$03] else load A with warning sound
	jbsr	osd_sound_start
	move.b	d0,background_music_value_6089  	| [$067a: ld      (background_music_value_6089),a] set warning sound
	move.b	#0x70,d0                        	| [$067d: ld      a,$70] A := #70 = color code for red?
	WRITE_TO_SCREEN	0x7486                       	| [$067f: ld      ($7486),a] store A into #7486 = paint score red (MSB) ?
	WRITE_TO_SCREEN	0x74a6                       	| [$0682: ld      ($74a6),a] store A into #74A6 = paint score red (LSB) ?
	add.b	d1,d0                            	| [$0685: add     a,b] A = A + B
	move.b	d0,d1                           	| [$0686: ld      b,a] B := A
	move.b	#0x10,d0                        	| [$0687: ld      a,$10] A = #10 = code for blank space

l_0689:
	WRITE_TO_SCREEN	0x74e6                       	| [$0689: ld      ($74e6),a] draw timer to screen (MSB)
	move.b	d1,d0                           	| [$068c: ld      a,b] A := B
	WRITE_TO_SCREEN	0x74c6                       	| [$068d: ld      ($74c6),a] draw timer to screen (LSB)
	rts                                    	| [$0690: ret] return

*
* continuation of task #5 when parameter = 0 from #062B
* adds bonus to player's score
*

add_bonus_to_player_score_0691:
	move.b	onscreen_timer_638c,d0    	| [$0691: ld      a,(onscreen_timer_638c)] load A with timer value from #638C
	move.b	d0,d1                           	| [$0694: ld      b,a] copy to B
	and.b	#0x0f,d0                         	| [$0695: and     $0f] and with #0F - mask four left bits.  how has low byte of bonus
	movem.w	d1/d2,-(sp)                    	| [$0697: push    bc] save BC
	jbsr	add_to_score_051c                            	| [$0698: call    $051c] add to score

	movem.w	(sp)+,d1/d2                    	| [$069b: pop     bc] restore BC
	move.b	d1,d0                           	| [$069c: ld      a,b] load A with timer
	ror.b	#4,d0                            	| [$069d: rrca] rotate right 4 times * 4
	and.b	#0x0f,d0                         	| [$06a1: and     $0f] mask four left bits to zero
	add.b	#0x0a,d0                         	| [$06a3: add     a,$0a] add #0A (10 decimal) - this indicates scores of thousands to add
	jra	add_to_score_051c                             	| [$06a5: jp      $051c] jump to add score (thousands) and RET

* jump here from #0632

l_06a8:
	tst.b	infinite_time_flag
	jne	l_066a
	
	moveq	#1,d7
	sbcd	d7,d0                        	| [$06a8: sub     $01] subtract 1 from bonus timer
	jne	l_06b1                             	| [$06aa: jr      nz,$06b1] If not zero, skip next 2 steps

* timer at zero

	move.b	#0x01,mario_dead_flag_63b8        	| [$06ac: ld      hl,mario_dead_flag_63b8] load HL with mario dead flag
													| [$06af: ld      (hl),$01] store 1 - mario will die soon on next timer click

l_06b1:
	*daa                 | Decimal adjust
	move.b	d0,onscreen_timer_638c    	| [$06b2: ld      (onscreen_timer_638c),a] store A into timer
	jra	l_066a                             	| [$06b5: jp      $066a] jump back

*
* task #6
* called from #01DC and #0306.  also jump here from #037C after high score has been exceeded
* parameter used to subtract the number of lives to draw
*

l_06b8:
	move.b	d0,d2                           	| [$06b8: ld      c,a] load C with the task parameter
	jbsr	rst_08                            	| [$06b9: rst     $8] is the game being played or credits exists?  If so, continue.  Else RET

	move.b	#0x06,d1                        	| [$06ba: ld      b,$06] For B = 1 to 6
	move.w	#0xffe0,d3                      	| [$06bc: ld      de,$ffe0] load DE with offset for next column
	move.w	#0x7783,d7                      	| [$06bf: ld      hl,$7783] load HL with screen location where mario extra lives drawn
	move.b	#0x10,d0
l_06c2:
	jbsr	osd_w_videoram                      	| [$06c2: ld      (hl),$10] clear this area of screen
	add.w	d3,d7                            	| [$06c4: add     hl,de] add offset for next column
	subq.b	#1,d1                           	| [...]
	jne	l_06c2                             	| [$06c5: djnz    $06c2] next B

	move.b	number_of_lives_remaining_6228,d0	| [$06c7: ld      a,(number_of_lives_remaining_6228)] load A with number of lives remaining
	sub.b	d2,d0                            	| [$06ca: sub     c] subtract the task parameter.  zero lives to draw?
	jeq	l_06d7                             	| [$06cb: jp      z,$06d7] yes, skip next 5 steps

	move.b	d0,d1                           	| [$06ce: ld      b,a] For B = 1 to A
	move.w	#0x7783,d7                      	| [$06cf: ld      hl,$7783] load HL with screen location to draw remaining lives
	st	d0
l_06d2:
	jbsr	osd_w_videoram                      	| [$06d2: ld      (hl),$ff] draw the extra mario
	add.w	d3,d7                            	| [$06d4: add     hl,de] add offset for next column
	subq.b	#1,d1                           	| [...]
	jne	l_06d2                             	| [$06d5: djnz    $06d2] next B

l_06d7:
	move.w	#0x7503,d7                      	| [$06d7: ld      hl,$7503] load HL with screen location for "L="
	move.b	#0x1c,d0                      	| [$06da: ld      (hl),$1c] draw "L"
	jbsr	osd_w_videoram
	move.w	#0x74e3,d7                      	| [$06dc: ld      hl,$74e3] next location
	move.b	#0x34,d0                      	| [$06df: ld      (hl),$34] draw "="
	jbsr	osd_w_videoram
	move.b	level_number_6229,d0       	| [$06e1: ld      a,(level_number_6229)] load A with level #
	cmp.b	#0x64,d0                         	| [$06e4: cp      $64] level < #64 (100 decimal) ?
	jcs	l_06ed                             	| [$06e6: jr      c,$06ed] yes, skip next 2 steps

	move.b	#0x63,d0                        	| [$06e8: ld      a,$63] otherwise A := #63 (99 decimal)
	move.b	d0,level_number_6229       	| [$06ea: ld      (level_number_6229),a] store into level #

l_06ed:
	move.b	#0xff,d1                        	| [$06ed: ld      bc,$ff0a] B: = #FF, C := #0A (10 decimal) 65290
	move.b	#0x0a,d2                        	| [$06ed: ld      bc,$ff0a] B: = #FF, C := #0A (10 decimal) 65290

l_06f0:
	addq.b	#1,d1                           	| [$06f0: inc     b] increment B
	sub.b	d2,d0                            	| [$06f1: sub     c] subtract 10 decimal
	jcc	l_06f0                             	| [$06f2: jp      nc,$06f0] not carry, loop again (counts tens)

	add.b	d2,d0                            	| [$06f5: add     a,c] add 10 back to A to get a number from 0 to 9
	WRITE_TO_SCREEN   0x74a3                       	| [$06f6: ld      ($74a3),a] draw level to screen (low byte)
	move.b	d1,d0                           	| [$06f9: ld      a,b] load a with b (number of tens)
	WRITE_TO_SCREEN   0x74c3                       	| [$06fa: ld      ($74c3),a] draw level to screen (high byte)
	rts                                    	| [$06fd: ret] return

* start of main routine when playing a game
* arrive here from #00C9

playing_game_06fe:
	move.b	gamemode2_600a,d0               	| [$06fe: ld      a,(gamemode2_600a)] load A with game mode2
	jbsr	rst_28                            	| [$0701: rst     $28] jump based on what the game state is

    .long	l_0986                      | (0)  #0986     | game start = clears screen, clears sounds, sets screen flip if needed
    .long	l_09ab                      | (1)  #09AB     | copy player data, set screen, set next game mode based on number of players
    .long	l_09d6                      | (2)  #09D6     | clears palettes, draws "PLAYER <I>", draws player2 score, draws "2UP" (2 player game only)
    .long	l_09fe                      | (3)  #09FE     | copy player data into correct area (2 player game only)
    .long	l_0a1b                      | (4)  #0A1B     | clears palletes, draws "PLAYER <II>", update player2 score, draw "2UP" to screen (2 player game only)
    .long	l_0a37                      | (5)  #0A37     | updates high score, player score, remaining lives, level, 1UP
    .long	l_0a63                      | (6)  #0A63     | clears screen and sprites, check for intro screen to run
    .long	l_0a76                      | (7)  #0A76     | kong clims ladders and scary music played
    .long	height_pre_level_screen_0bda     | (8)  #0BDA     | draw goofy kongs, how high can you get, play music
    .long	0                           | (9)            | unused
    .long	l_0c91                      | (A)  #0C91     | clears screen, update timers, draws current screen, sets background music
    .long	l_123c                      | (B)  #123C     | set initial mario sprite position and draw remaining lives and level
    .long	l_197a                      | (C)  #197A     | for when playing a game.  this is the main routine
    .long	mario_died_127c             | (D)  #127C     | mario died.  handle mario dying animations
    .long	l_12f2                      | (E)  #12F2     | clear sounds, decrease life, check for and handle game over
    .long	l_1344                      | (F)  #1344     | clear sounds, clear game start flag, draw game over if needed PL2, set game mode2 accordingly
    .long	l_138f                      | (10) #138F    | check for game over status on a 2 player game
    .long	l_13a1                      | (11) #13A1    | check for game over status on a 2 player game
    .long	l_13aa                      | (12) #13AA    | flip screen if needed, reset game mode2 to zero, set player 2
    .long	l_13bb                      | (13) #13BB    | set player 1, reset game mode2 to zero, set screen flip to not flipped
    .long	check_for_a_high_score_141e                      | (14) #141E    | draw credits on screen, clears screen and sprites, checks for high score, flips screen if necessary
    .long	enter_initials_1486                      | (15) #1486    | player enters initials in high score table
    .long	end_of_level_animations_1615                      | (16) #1615    | handle end of level animations
    .long	l_196b                      | (17) #196B    | clear screen and all sprites, set game mode2 to #12 for player1 or #13 for player2

* arrive from #00C9 when attract mode starts
attract_mode_073c:
	lea	gamemode2_600a,a0              	| [$073c: ld      hl,gamemode2_600a] load HL with game mode2 address
	move.b	numcredits_6001,d0              	| [$073f: ld      a,(numcredits_6001)] load A with number of credits
	                               	| [$0742: and     a] any credits exist ?
	jne	l_075c                             	| [$0743: jp      nz,$075c] yes, skip ahead, zero out game mode2, increase game mode1, and RET

	move.b	(a0),d0                         	| [$0746: ld      a,(hl)] else load A with game mode2
	jbsr	rst_28                            	| [$0747: rst     $28] jump based on A

	.long	first_boot_screen_0779 | #0779         | clear screen, set color palettes, draw attract mode text and high score table,
				  	          | [continued] increase game mode2, clear sprites, | draw "1UP" on screen , draws number of coins needed for play
	.long	l_0763 | #0763         |
	.long	l_123c | #123C         | set initial mario sprite position and draw remaining lives and level
	.long	l_1977 | #1977         | set artificial input for demo play [change to #197A to enable playing in demo part 1/2]
	.long	mario_died_127c | #127C         | handle mario dying animations
	.long	l_07c3 | #07C3         | clears the screen and sprites and increase game mode2
	.long	l_07cb | #07CB         | handle intro splash screen ?
	.long	l_084b | #084B         | counts down a timer then resets game mode2 to 0

* arrive from #0743 when credits exist

l_075c:
	clr.b	(a0)                             	| [$075c: ld      (hl),$00] set game mode2 to zero
	lea	gamemode1_6005,a0              	| [$075e: ld      hl,gamemode1_6005] load HL with game mode1
	addq.b	#1,(a0)                         	| [$0761: inc     (hl)] increase
	rts                                    	| [$0762: ret] return

* arrive here from #0747 during attract mode when GameMode2 == 1

l_0763:
	jbsr	rst_20                            	| [$0763: rst     $20] only continue here once per frame, else RET

	clr.b	d0                               	| [$0764: xor     a] A := 0
	move.b	d0,barrel_deployment_indicator_6392	| [$0765: ld      (barrel_deployment_indicator_6392),a] clear barrel deployment indicator
	move.b	d0,unknown_63a0                 	| [$0768: ld      (unknown_63a0),a] clear fireball release indicator
	move.b	#0x01,d0                        	| [$076b: ld      a,$01] A := 1
	move.b	d0,screen_number_6227           	| [$076d: ld      (screen_number_6227),a] load screen number with 1
	move.b	d0,level_number_6229       	| [$0770: ld      (level_number_6229),a] load level # with 1
	move.b	d0,number_of_lives_remaining_6228	| [$0773: ld      (number_of_lives_remaining_6228),a] load number of lives with 1
	jra	l_0c92                             	| [$0776: jp      $0c92] skip ahead

* arrive from #0747 when GameMode2 == 0
* clear screen, set color palettes, draw attract mode text and high score table, increase game mode2, clear sprites, 
* draw "1UP" on screen , draws number of coins needed for play

first_boot_screen_0779:
	lea	reg_palette_a,a0               	| [$0779: ld      hl,reg_palette_a]
	clr.b	(a0)+                             	| [$077c: ld      (hl),$00] clear palette bank selector
	clr.b	(a0)                             	| [$077f: ld      (hl),$00] clear palette bank selector
	jbsr	osd_update_palette_bank
	move.w  #0x031b,d3                      	| [$0781: ld      de,$031b] load task data for text "INSERT COIN"
	jbsr	insert_task_309f                            	| [$0784: call    $309f] insert task to draw text
	addq.b	#1,d3                           	| [$0787: inc     e] load task data for text "PLAYER    COIN" (1C)
	jbsr	insert_task_309f                            	| [$0788: call    $309f] insert task to draw text
	jbsr	l_0965                            	| [$078b: call    $0965] draws credits on screen if any are present and displays high score table
	lea	waittimermsb_6009,a0           	| [$078e: ld      hl,waittimermsb_6009] load HL with timer address
	move.b	#0x02,(a0)+                      	| [$0791: ld      (hl),$02] set timer at 2
	                           	| [$0793: inc     hl] load HL with game mode2
	addq.b	#1,(a0)                         	| [$0794: inc     (hl)] increase
	jbsr	clear_screen_and_sprites_0874                            	| [$0795: call    $0874] clears the screen and sprites
	jbsr	l_0a53                            	| [$0798: call    $0a53] draw "1UP" on screen
	move.b	twoplayergame_600f,d0           	| [$079b: ld      a,(twoplayergame_600f)] load A with number of players in game
	cmp.b	#0x01,d0                         	| [$079e: cp      $01] 2 player game?
	bne.b	0f                               	| [...]
	jbsr	l_09ee                            	| [$07a0: call    z,$09ee] yes, skip ahead to handle
0:

	move.b	coinspercredit_6022,d4      	| [$07a3: ld      de,(coinspercredit_6022)] D := CoinsPer2Credits| E := CoinsPerCredit
	move.b	coinspercredit_6022+1,d3
	move.w	#0x756c,d7                      	| [$07a7: ld      hl,$756c] load HL with screen RAM location
	jbsr	l_07ad                            	| [$07aa: call    $07ad] run this sub below twice

l_07ad:
	move.b	d4,d0                         	| [$07ad: ld      (hl),e] draw to screen number of coins needed for 1 player game
	jbsr	osd_w_videoram
	addq.w	#2,d7                           	| [$07ae: inc     hl] * 2
	move.b	d3,d0                         	| [$07b0: ld      (hl),d] draw to screen number of coins neeeded for 2 player game
	jbsr	osd_w_videoram
	move.b	d3,d0                           	| [$07b1: ld      a,d] A := D
	sub.b	#0x0a,d0                         	| [$07b2: sub     $0a] subtract #A (10 decimal). result == 0 ?
	jne	l_07bc                             	| [$07b4: jp      nz,$07bc] no, skip next 3 steps

	jbsr	osd_w_videoram                         	| [$07b7: ld      (hl),a] else draw this zero to screen
	addq.b	#1,d0                           	| [$07b8: inc     a] increase A, A := 1 now
	WRITE_TO_SCREEN	0x758e                       	| [$07b9: ld      ($758e),a] draw 1 to screen in front of the zero, so it draws "10" credits needed for 2 players

l_07bc:
	move.b	#2,d3
	move.b	#1,d4                      	| [$07bc: ld      de,$0201] D := 2, E := 1, used for next loop for 1 player and 2 players
	move.w	#0x768c,d7                      	| [$07bf: ld      hl,$768c] set screen location to draw for next loop if needed
	rts                                    	| [$07c2: ret] return

* arrive from #0747 when GameMode2 == 5

l_07c3:
	jbsr	clear_screen_and_sprites_0874                            	| [$07c3: call    $0874] clears the screen and sprites
	lea	gamemode2_600a,a0              	| [$07c6: ld      hl,gamemode2_600a] load HL with game mode 2
	addq.b	#1,(a0)                         	| [$07c9: inc     (hl)] increase game mode2
	rts                                    	| [$07ca: ret] return

* arrive from jump at #0747 when GameMode2 == 6

l_07cb:
	move.b	kong_intro_flash_counter_638a,d0	| [$07cb: ld      a,(kong_intro_flash_counter_638a)] load A with kong screen flash counter
	                               	| [$07ce: cp      $00] == 0 ?  time to flash?
	jne	l_082d                             	| [$07d0: jp      nz,$082d] no, skip ahead : load C with (#638B), decreases #638A, loads A with (#638A) | loads C with #638B, decreases #638A returns to #07DA

	move.b	#0x60,d0                        	| [$07d3: ld      a,$60] else A := #60
	move.b	d0,kong_intro_flash_counter_638a	| [$07d5: ld      (kong_intro_flash_counter_638a),a] store into kong screen flash counter
	move.b	#0x5f,d2                        	| [$07d8: ld      c,$5f] C := #5F

* can arrive here from jump at #0838

l_07da:
	tst.b	d0                               	| [$07da: cp      $00] A == 0 ? [why not AND A ?]
	jeq	l_083b                             	| [$07dc: jp      z,$083b] yes, skip ahead

	lea	reg_palette_a,a0               	| [$07df: ld      hl,reg_palette_a] load pallete bank
	clr.b	(a0)                             	| [$07e2: ld      (hl),$00] clear palette bank selector
	move.b	d2,d0                           	| [$07e4: ld      a,c] A := C
	rol.b	#1,d0                            	| [$07e5: rlc     a] rotate left.  carry bit set?
	jcc	l_07eb                             	| [$07e7: jr      nc,$07eb] no, skip next step

	move.b	#0x01,(a0)                      	| [$07e9: ld      (hl),$01] set pallete bank selector to 1

l_07eb:
	addq.w	#1,a0                           	| [$07eb: inc     hl] HL := REG_PALETTE_B = 2nd pallete bank
	clr.b	(a0)                             	| [$07ec: ld      (hl),$00] clear the pallete bank selector
	rol.b	#1,d0                            	| [$07ee: rlc     a] rotate left again.  carry bit set ?
	jcc	l_07f4                             	| [$07f0: jr      nc,$07f4] no, skip next step

	move.b	#0x01,(a0)                      	| [$07f2: ld      (hl),$01] set pallete bank selector to 1

l_07f4:
	jbsr	osd_update_palette_bank
	move.b	d0,unknown_638b                 	| [$07f4: ld      (unknown_638b),a] store A into ???

* draws DONKEY KONG logo to screen

	lea	game_rom+0x3d08,a0                      	| [$07f7: ld      hl,$3d08] load HL with start of table data

l_07fa:
	move.b	#0xb0,d0                        	| [$07fa: ld      a,$b0] A := #B0 = code for girder on screen
	move.b	(a0)+,d1                         	| [$07fc: ld      b,(hl)] get first data.  this is used as a loop counter
	                           	| [$07fd: inc     hl] next table entry
	move.b	(a0)+,d4                         	| [$07fe: ld      e,(hl)] load E with table data
	                           	| [$07ff: inc     hl] next entry
	move.b	(a0),d3                         	| [$0800: ld      d,(hl)] load D with table data.  DE now has an address
	LOAD_D3_16_FROM_D3D4
	move.w	d3,d7
l_0801:
	jbsr	osd_w_videoram                         	| [$0801: ld      (de),a] draw girder on screen
	addq.w	#1,d7											| [$0802: inc     de] next address
	subq.b	#1,d1                           	| [...]
	jne	l_0801                             	| [$0803: djnz    $0801] Next B

	addq.w	#1,a0                           	| [$0805: inc     hl] next table entry
	move.b	(a0),d0                         	| [$0806: ld      a,(hl)] get data
	                               	| [$0807: cp      $00] done ?
	jne	l_07fa                             	| [$0809: jp      nz,$07fa] no, loop again

	move.w  #0x031e,d3                      	| [$080c: ld      de,$031e] load task data for text "(C) 1981"
	jbsr	insert_task_309f                            	| [$080f: call    $309f] insert task to draw text
	addq.w	#1,d3                           	| [$0812: inc     de] load task data for text "NINTENDO OF AMERICA"
	jbsr	insert_task_309f                            	| [$0813: call    $309f] insert task to draw text
	lea	game_rom+0x39cf,a0                      	| [$0816: ld      hl,$39cf] load HL with table data for kong beating chest
	jbsr	update_kong_sprites_004e                            	| [$0819: call    $004e] update kong's sprites
	jbsr	l_3f24                            	| [$081c: call    $3f24] draw TM logo onscreen [patch? orig japanese had 3 NOPs here]
											| [$081f: nop] no operation
	lea	start_of_kong_sprite_6908,a0   	| [$0820: ld      hl,start_of_kong_sprite_6908] load HL with start of kong sprite X pos
	move.b	#0x44,d2                        	| [$0823: ld      c,$44] load C with offset to add X
	jbsr	rst_38                            	| [$0825: rst     $38] draw kong in new position
	lea	kong_sprite_array_690b,a0      	| [$0826: ld      hl,kong_sprite_array_690b] load HL with start of kong sprite Y pos
	move.b	#0x78,d2                        	| [$0829: ld      c,$78] load C with offset to add Y
	jbsr	rst_38                            	| [$082b: rst     $38] draw kong
	rts                                    	| [$082c: ret] return

* jump here from #07D0
* loads C with #638B, decreases #638A

l_082d:
	move.b	unknown_638b,d0                 	| [$082d: ld      a,(unknown_638b)] load A with ???
	move.b	d0,d2                           	| [$0830: ld      c,a] copy to C
	move.b	kong_intro_flash_counter_638a,d0	| [$0831: ld      a,(kong_intro_flash_counter_638a)] load A with kong intro flash counter
	subq.b	#1,d0                           	| [$0834: dec     a] decrease
	move.b	d0,kong_intro_flash_counter_638a	| [$0835: ld      (kong_intro_flash_counter_638a),a] store result
	jra	l_07da                             	| [$0838: jp      $07da] jump back

* jump here from #07DC

l_083b:
	lea	waittimermsb_6009,a0           	| [$083b: ld      hl,waittimermsb_6009] load HL with timer address
	move.b	#0x02,(a0)                      	| [$083e: ld      (hl),$02] set timer to 2
	addq.w	#1,a0                           	| [$0840: inc     hl] HL := GameMode2
	addq.b	#1,(a0)                         	| [$0841: inc     (hl)] increase game mode2
	lea	kong_intro_flash_counter_638a,a0	| [$0842: ld      hl,kong_intro_flash_counter_638a] load HL with kong intro flash counter
	clr.b	(a0)                             	| [$0845: ld      (hl),$00] clear counter
	addq.w	#1,a0                           	| [$0847: inc     hl] HL := #638B = ???
	clr.b	(a0)                             	| [$0848: ld      (hl),$00] clear this memory
	rts                                    	| [$084a: ret] return

* arrive from #0747 when GameMode2 == 7

l_084b:
	jbsr	rst_20                            	| [$084b: rst     $20] update timer and continue here only when complete, else RET

	lea	gamemode2_600a,a0              	| [$084c: ld      hl,gamemode2_600a] load HL with game mode2
	clr.b	(a0)                             	| [$084f: ld      (hl),$00] set to 0
	rts                                    	| [$0851: ret] return

* called from #0986
* clears screen and all sprites

l_0852:
	move.w	#0x7400,d7                      	| [$0852: ld      hl,$7400] #7400 is beginning of video RAM
	move.b	#0x04,d2                        	| [$0855: ld      c,$04] for C= 1 to 4
l_0857:
	clr.b	d1                               	| [$0857: ld      b,$00] for B = 1 to 256
	move.b	#0x10,d0                        	| [$0859: ld      a,$10] #10 is clear for screen in video RAM

l_085b:
	jbsr	osd_w_videoram                         	| [$085b: ld      (hl),a] clear this screen element
	addq.w	#1,d7                           	| [$085c: inc     hl] next screen location
	subq.b	#1,d1                           	| [...]
	jne	l_085b                             	| [$085d: djnz    $085b] Next B

	subq.b	#1,d2                           	| [$085f: dec     c] Next C
	jne	l_0857                             	| [$0860: jp      nz,$0857] loop until done

	lea	girls_head_sprite_6900,a0      	| [$0863: ld      hl,girls_head_sprite_6900] load HL with start of sprite RAM
	move.b	#0x02,d2                        	| [$0866: ld      c,$02] for C = 1 to 2
l_0868:
	move.b	#0xc0,d1                        	| [$0868: ld      b,$c0] for B = 1 to #C0
	clr.b	d0                               	| [$086a: xor     a] A := 0

l_086b:
	move.b	d0,(a0)                         	| [$086b: ld      (hl),a] clear RAM
	addq.w	#1,a0                           	| [$086c: inc     hl] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_086b                             	| [$086d: djnz    $086b] next B

	subq.b	#1,d2                           	| [$086f: dec     c] next C
	jne	l_0868                             	| [$0870: jp      nz,$0868] loop until done

	rts                                    	| [$0873: ret] return

* called from many places.  EG #08BA and #01C3 and #0C92 and other places
* clears the screen and sprites

clear_screen_and_sprites_0874:
	move.w	#0x7404,d7                      	| [$0874: ld      hl,$7404] load HL with start of video RAM
	move.b	#0x20,d2                        	| [$0877: ld      c,$20] For C = 1 to #20

l_0879:
	move.b	#0x1c,d1                        	| [$0879: ld      b,$1c] for B = 1 to #1C
	move.b	#0x10,d0                        	| [$087b: ld      a,$10] A := #10
	move.w	#0x0004,d3                      	| [$087d: ld      de,$0004] DE = 4, used as offset to add later 4

l_0880:
	jbsr	osd_w_videoram                        	| [$0880: ld      (hl),a] store into memory
	addq.w	#1,d7                           	| [$0881: inc     hl] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_0880                             	| [$0882: djnz    $0880] Next B

	add.w	d3,d7                            	| [$0884: add     hl,de] add offset of 4
	subq.b	#1,d2                           	| [$0885: dec     c] decrease counter
	jne	l_0879                             	| [$0886: jp      nz,$0879] loop until zero

	move.w	#0x7522,d7                      	| [$0889: ld      hl,$7522] load HL with screen location
	move.w	#0x0020,d3                      	| [$088c: ld      de,$0020] load DE with offset to use 32
	move.b	#0x02,d2                        	| [$088f: ld      c,$02] for C = 1 to 2
	move.b	#0x10,d0                        	| [$0891: ld      a,$10] A := #10 = clear screen byte

l_0893:
	move.b	#0x0e,d1                        	| [$0893: ld      b,$0e] for B = 1 to #0E
l_0895:
	jbsr	osd_w_videoram                         	| [$0895: ld      (hl),a] clear the screen element
	add.w	d3,d7                            	| [$0896: add     hl,de] add offset for next
	subq.b	#1,d1                           	| [...]
	jne	l_0895                             	| [$0897: djnz    $0895] Next B

	move.w	#0x7523,d7                      	| [$0899: ld      hl,$7523] load HL with next screen location
	subq.b	#1,d2                           	| [$089c: dec     c] done ?
	jne	l_0893                             	| [$089d: jp      nz,$0893] no, loop again

	lea	girls_head_sprite_6900,a0      	| [$08a0: ld      hl,girls_head_sprite_6900] load HL with start of sprite RAM
	clr.b	d1                               	| [$08a3: ld      b,$00] For B = 0 to #FF
	clr.b	d0                               	| [$08a5: ld      a,$00] A := 0

l_08a7:
	move.b	d0,(a0)+                         	| [$08a7: ld      (hl),a] clear memory
	                           	| [$08a8: inc     hl] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_08a7                             	| [$08a9: djnz    $08a7] Next B

	move.b	#0x80,d1                        	| [$08ab: ld      b,$80] For B = 0 to #80
l_08ad:
	move.b	d0,(a0)+                         	| [$08ad: ld      (hl),a] store memory
	                           	| [$08ae: inc     hl] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_08ad                             	| [$08af: djnz    $08ad] Next B

	rts                                    	| [$08b1: ret] Return

* jump from #00C9
* arrive here when credits have been inserted, waiting for game to start

l_08b2:
	move.b	gamemode2_600a,d0               	| [$08b2: ld      a,(gamemode2_600a)] load A with game mode2

* GameMode2 = 1 during attract mode, 7 during intro , A during how high can u get,
*         B right before play, C during play, D when dead, 10 when game over

	jbsr	rst_28                            	| [$08b5: rst     $28] jump based on A

	.long	l_08BA | #08BA         | display screen to press start etc.
	.long	l_08F8 | #08F8         | wait for start buttons to be pressed

l_08BA:
	jbsr	clear_screen_and_sprites_0874                            	| [$08ba: call    $0874] clear the screen and sprites
	clr.b	d0                               	| [$08bd: xor     a] A := 0
	move.b	d0,nocredits_6007               	| [$08be: ld      (nocredits_6007),a] store into credit indicator
	move.w  #0x030c,d3                      	| [$08c1: ld      de,$030c] load DE with task code to display "PUSH" onscreen
	jbsr	insert_task_309f                            	| [$08c4: call    $309f] insert task
	lea	gamemode2_600a,a0              	| [$08c7: ld      hl,gamemode2_600a] load A with game mode2
	addq.b	#1,(a0)                         	| [$08ca: inc     (hl)] increase game mode2
	jbsr	l_0965                            	| [$08cb: call    $0965] draw credits on screen if any are present and displays high score table
	clr.b	d0                               	| [$08ce: xor     a] A := 0
	lea	reg_palette_a,a0               	| [$08cf: ld      hl,reg_palette_a] load HL with pallete bank
	move.b	d0,(a0)+                         	| [$08d2: ld      (hl),a] clear palette bank selector
	                           	| [$08d3: inc     l] next pallete bank
	move.b	d0,(a0)                         	| [$08d4: ld      (hl),a] clear palette bank selector
	jbsr	osd_update_palette_bank

* called from #08F8

l_08d5:
	move.b	#0x04,d1                        	| [$08d5: ld      b,$04] B := 4 = 0100 binary
	move.b	#0x09,d4                        	| [$08d7: ld      e,$09] E := 9 , code for "ONLY 1 PLAYER BUTTON"
	move.b	numcredits_6001,d0              	| [$08d9: ld      a,(numcredits_6001)] load A with number of credits
	cmp.b	#0x01,d0                         	| [$08dc: cp      $01] == 1 ?
	jeq	l_08e4                             	| [$08de: jp      z,$08e4] yes, skip next 2 steps

	move.b	#0x0c,d1                        	| [$08e1: ld      b,$0c] B := #0C = 1100 binary
	addq.b	#1,d4                           	| [$08e3: inc     e] E := #0A, code for "1 OR 2 PLAYERS BUTTON"

l_08e4:
	move.b	framecounter_601a,d0            	| [$08e4: ld      a,(framecounter_601a)] load A with # Timer constantly counts down from FF to 00
	and.b	#0x07,d0                         	| [$08e7: and     $07] mask bits. zero ?
	jne	l_08f3                             	| [$08e9: jp      nz,$08f3] no, skip next 3 steps

	move.b	d4,d0                           	| [$08ec: ld      a,e] yes, load A with E for code of text to draw, for buttons to press to start
	jbsr	draw_text_to_screen_05e9                            	| [$08ed: call    $05e9] draw text to screen
	jbsr	l_0616                            	| [$08f0: call    $0616] draw credits on screen

l_08f3:
	jbsr	osd_read_in_2                          	| [$08f3: ld      a,(in2)] load A with IN2 [Credit/Service/Start Info]
	and.b	d1,d0                            	| [$08f6: and     b] mask bits with B
	rts                                    	| [$08f7: ret] return

* jump from #08B5 when GameMode2 == 1
l_08F8:
	jbsr	l_08d5                            	| [$08f8: call    $08d5] draws press player buttons and loads A with IN2, masked by possible player numbers
	cmp.b	#0x04,d0                         	| [$08fb: cp      $04] is the player 1 button pressed ?
	jeq	l_0906                             	| [$08fd: jp      z,$0906] yes, skip ahead

	cmp.b	#0x08,d0                         	| [$0900: cp      $08] is the player 2 button pressed ?
	jeq	l_0919                             	| [$0902: jp      z,$0919] yes, skip ahead

	rts                                    	| [$0905: ret] return to #00D2

* player 1 start

l_0906:
	jbsr	l_0977                            	| [$0906: call    $0977] subtract 1 credit and update screen credit counter
	lea	p2numlives_6048,a0             	| [$0909: ld      hl,p2numlives_6048] load HL with RAM used for player 2
	move.b	#0x08,d1                        	| [$090c: ld      b,$08] for B = 1 to 8
	clr.b	d0                               	| [$090e: xor     a] A := 0

l_090f:
	move.b	d0,(a0)+                         	| [$090f: ld      (hl),a] clear memory
	                           	| [$0910: inc     l] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_090f                             	| [$0911: djnz    $090f] Next B

	clr.w	d5                      	| [$0913: ld      hl,$0000] clear HL 0
	jra	l_0938                             	| [$0916: jp      $0938] skip ahead

* 2 players start

l_0919:
	jbsr	l_0977                            	| [$0919: call    $0977] subtract 1 credit and update screen credit counter
	jbsr	l_0977                            	| [$091c: call    $0977] subtract 1 credit and update screen credit counter
	lea	p2numlives_6048,a1             	| [$091f: ld      de,p2numlives_6048] load DE with RAM location used for player 2
	move.b	startinglives_6020,d0           	| [$0922: ld      a,(startinglives_6020)] load initial number of lives
	move.b	d0,(a1)+                         	| [$0925: ld      (de),a] store into number of lives player 2
											| [$0926: inc     e] DE := Unk6049
	lea	l_095e,a0                      	| [$0927: ld      hl,$095e] load HL with source data table start
	move.w	#0x07,d1                        	| [$092a: ld      bc,$0007] counter = 7 7
	jbsr	ldir                              	| [$092d: ldir] copy #095E into Unk6049 for 7 bytes
	move.w  #0x0101,d3                      	| [$092f: ld      de,$0101] load task #1, parameter 1.  clears player 1 and 2 scores and displays them.
	jbsr	insert_task_309f                            	| [$0932: call    $309f] insert task
	move.w	#0x0100,d5                      	| [$0935: ld      hl,$0100] HL := #100

l_0938:
	LOAD_D5D6_FROM_D5_16
	move.b	d6,playerturnb_600e             	| [$0938: ld      (playerturnb_600e),hl] store HL into PlayerTurnB and TwoPlayerGame.  TwoPlayerGame is the number of players in the game
	move.b	d5,playerturnb_600e+1             	| [$0938: ld      (playerturnb_600e),hl] store HL into PlayerTurnB and TwoPlayerGame.  TwoPlayerGame is the number of players in the game
	jbsr	clear_screen_and_sprites_0874                            	| [$093b: call    $0874] clear the screen and sprites
	lea	p1numlives_6040,a1             	| [$093e: ld      de,p1numlives_6040] load DE with address for number of lives player 1
	move.b	startinglives_6020,d0           	| [$0941: ld      a,(startinglives_6020)] number of initial lives set with dip switches (3, 4, 5, or 6)
	move.b	d0,(a1)+                         	| [$0944: ld      (de),a] store into number of lives
	                           	| [$0945: inc     e] DE := Unk6041
	lea	l_095e,a0                      	| [$0946: ld      hl,$095e] load HL with start of table data
	move.w	#0x07,d1                        	| [$0949: ld      bc,$0007] counter = 7 7
	jbsr	ldir                              	| [$094c: ldir] copy #095E into Unk6041 for 7 bytes
	move.w  #0x0100,d3                      	| [$094e: ld      de,$0100] load task #1, parameter 0.  clears player 1 score and displays it
	jbsr	insert_task_309f                            	| [$0951: call    $309f] insert task
	clr.b	d0                               	| [$0954: xor     a] A := 0
	move.b	d0,gamemode2_600a               	| [$0955: ld      (gamemode2_600a),a] reset game mode2
	move.b	#0x03,d0                        	| [$0958: ld      a,$03] A := 3
	move.b	d0,gamemode1_6005               	| [$095a: ld      (gamemode1_6005),a] store into game mode1
	rts                                    	| [$095d: ret] return

* table data use in code above - gets copied to Unk6041 to Unk6041+7

* OPT_START_LEVEL is 1, but can be set to 2 to test second screen
* as elevators, or 3 to test second screen as "pie factory"
l_095e:
	.ifeq	OPT_START_LEVEL-1
	.byte	0x01,0x65
	.else
		.ifeq	OPT_START_LEVEL-2
		.byte	0x02,0x67              | #3A65 is start of table data for screens/levels	
	    .else
		    .byte	0x03,0x6A              | #3A65 is start of table data for screens/levels	
		.endif
	.endif
	
	.byte	0x3A,0x01,0x00,0x00,0x00              | #3A65 is start of table data for screens/levels
	
	.align	2
* called from #08CB

l_0965:
	move.w  #0x0400,d3                      	| [$0965: ld      de,$0400] set task #4 = draws credits on screen if any are present
	jbsr	insert_task_309f                            	| [$0968: call    $309f] insert task
	move.w  #0x0314,d3                      	| [$096b: ld      de,$0314] set task #3, parameter 14 through 1A.  For display of high score table
	move.b	#0x06,d1                        	| [$096e: ld      b,$06] for B = 1 to 6

l_0970:
	jbsr	insert_task_309f                            	| [$0970: call    $309f] insert task
	addq.b	#1,d3                           	| [$0973: inc     e] increase task parameter
	subq.b	#1,d1                           	| [...]
	jne	l_0970                             	| [$0974: djnz    $0970] Next B

	rts                                    	| [$0976: ret] return

* subtract 1 credit and update screen credit counter

l_0977:
	CLEAR_XC_FLAGS
	lea	numcredits_6001,a0             	| [$0977: ld      hl,numcredits_6001] load HL with pointer to number of credits
	move.b	#0x99,d0                        	| [$097a: ld      a,$99] A := #99
	move.b	(a0),d7
	abcd	d7,d0                          	| [$097c: add     a,(hl)] add to number of credits.   equivalent of subtracting 1
	*daa                 | decimal adjust
	move.b	d0,(a0)                         	| [$097e: ld      (hl),a] store into number of credits
	move.w  #0x0400,d3                      	| [$097f: ld      de,$0400] set task #4 = draws credits on screen if any are present
	jbsr	insert_task_309f                            	| [$0982: call    $309f] insert task
	rts                                    	| [$0985: ret] return

* arrive here when a game begins
* clears screen, clears sounds, sets screen flip if needed
* jump from #0701 when GameMode2 == 0

l_0986:
	jbsr	l_0852                            	| [$0986: call    $0852] clear screen and all sprites
	jbsr	clear_all_sounds_011c                            	| [$0989: call    $011c] clear all sounds
	lea	reg_flipscreen,a1              	| [$098c: ld      de,reg_flipscreen] load DE with flip screen setting
	move.b	#0x01,d0                        	| [$098f: ld      a,$01] A := 1
	move.b	d0,(a1)                         	| [$0991: ld      (de),a] store
	lea	gamemode2_600a,a0              	| [$0992: ld      hl,gamemode2_600a] load HL with game mode 2 address
	move.b	playerturnb_600e,d0             	| [$0995: ld      a,(playerturnb_600e)] load A with 0 when player 1 is up, = 1 when player 2 is up
	                               	| [$0998: and     a] is player 1 up?
	jne	l_099f                             	| [$0999: jp      nz,$099f] no, skip next 2 steps

	move.b	#0x01,(a0)                      	| [$099c: ld      (hl),$01] set game mode 2 to 1
	rts                                    	| [$099e: ret] return

l_099f:
	move.b	uprightcab_6026,d0              	| [$099f: ld      a,(uprightcab_6026)] load A with upright/cocktail
	subq.b	#1,d0                           	| [$09a2: dec     a] is this cocktail mode ?
	jeq	l_09a8                             	| [$09a3: jp      z,$09a8] no, skip next 2 steps

	clr.b	d0                               	| [$09a6: xor     a] A := 0
	move.b	d0,(a1)                         	| [$09a7: ld      (de),a] set screen to flipped

l_09a8:
	move.b	#0x03,(a0)                      	| [$09a8: ld      (hl),$03] set game mode 2 to 3
	rts                                    	| [$09aa: ret] return

* jump from #0701 when GameMode2 == 1
* copy player data, set screen, set next game mode based on number of players

l_09ab:
	lea	p1numlives_6040,a0             	| [$09ab: ld      hl,p1numlives_6040] load HL with source data location
	lea	number_of_lives_remaining_6228,a1	| [$09ae: ld      de,number_of_lives_remaining_6228] load DE with destination data location.  start with remaining lives
	move.w	#0x08,d1                        	| [$09b1: ld      bc,$0008] byte counter set to 8 8
	jbsr	ldir                              	| [$09b4: ldir] copy (HL) into (DE) from P1NumLives to P2NumLives into #6228 to #622F
	LOAD_ROM_ADDRESS_LE	store_622a,a0               	| [$09b6: ld      hl,(store_622a)] EG #3A65.  start of table data for screens/levels
	move.b	(a0),d0                         	| [$09b9: ld      a,(hl)] load screen number from table
	move.b	d0,screen_number_6227           	| [$09ba: ld      (screen_number_6227),a] store screen number
	move.b	twoplayergame_600f,d0           	| [$09bd: ld      a,(twoplayergame_600f)] load A with number of players
	                               	| [$09c0: and     a] 1 player game?
	lea	waittimermsb_6009,a0           	| [$09c1: ld      hl,waittimermsb_6009] load HL with timer address
	lea	gamemode2_600a,a1              	| [$09c4: ld      de,gamemode2_600a] load DE with game mode2 address
	jeq	l_09d0                             	| [$09c7: jp      z,$09d0] if 1 player game, skip ahead

* 2 player game

	move.b	#0x78,(a0)                      	| [$09ca: ld      (hl),$78] store #78 into timer
	exg	a1,a0                              	| [$09cc: ex      de,hl] DE <> HL.  HL now has game mode2
	move.b	#0x02,(a0)                      	| [$09cd: ld      (hl),$02] GameMode2 := 2
	rts                                    	| [$09cf: ret] return

* 1 player game

l_09d0:
	move.b	#0x01,(a0)                      	| [$09d0: ld      (hl),$01] store 1 into timer
	exg	a1,a0                              	| [$09d2: ex      de,hl] DE <> HL.  HL now has game mode2
	move.b	#0x05,(a0)                      	| [$09d3: ld      (hl),$05] GameMode2 := 5
	rts                                    	| [$09d5: ret] return


* used to draw players during 2 player game
* jump here from #0701
* clears palettes, draws "PLAYER <I>", draws player2 score, draws "2UP"

l_09d6:
	clr.b	d0                               	| [$09d6: xor     a] A := 0
	move.b	d0,reg_palette_a                	| [$09d7: ld      (reg_palette_a),a] clear palette bank selector
	move.b	d0,reg_palette_b                	| [$09da: ld      (reg_palette_b),a] clear palette bank selector
	jbsr	osd_update_palette_bank
	move.w  #0x0302,d3                      	| [$09dd: ld      de,$0302] load task data for text #2 "PLAYER <I>"
	jbsr	insert_task_309f                            	| [$09e0: call    $309f] insert task to draw
	move.w  #0x0201,d3                      	| [$09e3: ld      de,$0201] load task #2, parameter 1 to display player 2 score
	jbsr	insert_task_309f                            	| [$09e6: call    $309f] insert task
	move.b	#0x05,d0                        	| [$09e9: ld      a,$05] A := 5
	move.b	d0,gamemode2_600a               	| [$09eb: ld      (gamemode2_600a),a] store into game mode2

l_09ee:
	move.b	#0x02,d0                        	| [$09ee: ld      a,$02] load A with "2"
	WRITE_TO_SCREEN   0x74e0                       	| [$09f0: ld      ($74e0),a] write to screen
	move.b	#0x25,d0                        	| [$09f3: ld      a,$25] load A with "U"
	WRITE_TO_SCREEN   0x74c0                       	| [$09f5: ld      ($74c0),a] write to screen
	move.b	#0x20,d0                        	| [$09f8: ld      a,$20] load A with "P"
	WRITE_TO_SCREEN   0x74a0                       	| [$09fa: ld      ($74a0),a] write to screen
	rts                                    	| [$09fd: ret] return

* arrive from #0701 when GameMode2 == 3

l_09fe:
	lea	p2numlives_6048,a0             	| [$09fe: ld      hl,p2numlives_6048] source location is ???
	lea	number_of_lives_remaining_6228,a1	| [$0a01: ld      de,number_of_lives_remaining_6228] destination is player lives remaining plus other player variables
	move.w	#0x08,d1                        	| [$0a04: ld      bc,$0008] byte counter set to 8 8
	jbsr	ldir                              	| [$0a07: ldir] copy
	LOAD_ROM_ADDRESS_LE	store_622a,a0               	| [$0a09: ld      hl,(store_622a)] load HL with table for screens/levels
	move.b	(a0),d0                         	| [$0a0c: ld      a,(hl)] load A with screen number from table
	move.b	d0,screen_number_6227           	| [$0a0d: ld      (screen_number_6227),a] store A into screen number
	move.b	#0x78,d0                        	| [$0a10: ld      a,$78] A := #78
	move.b	d0,waittimermsb_6009            	| [$0a12: ld      (waittimermsb_6009),a] store into timer
	move.b	#0x04,d0                        	| [$0a15: ld      a,$04] A := 4
	move.b	d0,gamemode2_600a               	| [$0a17: ld      (gamemode2_600a),a] store into game mode2
	rts                                    	| [$0a1a: ret] return

* arrive from #0701 when GameMode2 == 4
* clears palletes, draws "PLAYER <II>", update player2 score, draw "2UP" to screen

l_0a1b:
	clr.b	d0                               	| [$0a1b: xor     a] A := 0
	move.b	d0,reg_palette_a                	| [$0a1c: ld      (reg_palette_a),a] clear palette bank selector
	move.b	d0,reg_palette_b                	| [$0a1f: ld      (reg_palette_b),a] clear palette bank selector
	jbsr	osd_update_palette_bank
	move.w  #0x0303,d3                      	| [$0a22: ld      de,$0303] load task data for text #3 "PLAYER <II>"
	jbsr	insert_task_309f                            	| [$0a25: call    $309f] insert task to draw text
	move.w  #0x0201,d3                      	| [$0a28: ld      de,$0201] load task #2, parameter 1 to display player 2 score
	jbsr	insert_task_309f                            	| [$0a2b: call    $309f] insert task
	jbsr	l_09ee                            	| [$0a2e: call    $09ee] draw "2UP" to screen
	move.b	#0x05,d0                        	| [$0a31: ld      a,$05] A := 5
	move.b	d0,gamemode2_600a               	| [$0a33: ld      (gamemode2_600a),a] store into game mode2
	rts                                    	| [$0a36: ret] return

* arrive from #0701 when GameMode2 == 5
* updates high score, player score, remaining lives, level, 1UP

l_0a37:
	move.w  #0x0304,d3                      	| [$0a37: ld      de,$0304] load task data for text #4 "HIGH SCORE"
	jbsr	insert_task_309f                            	| [$0a3a: call    $309f] insert task to draw text
	move.w  #0x0202,d3                      	| [$0a3d: ld      de,$0202] load task #2, parameter 2 to display high score
	jbsr	insert_task_309f                            	| [$0a40: call    $309f] insert task
	move.w  #0x0200,d3                      	| [$0a43: ld      de,$0200] load task #2, parameter 0 to display player 1 score
	jbsr	insert_task_309f                            	| [$0a46: call    $309f] insert task
	move.w  #0x0600,d3                      	| [$0a49: ld      de,$0600] load task #6 parameter 0 to display lives remaining and level
	jbsr	insert_task_309f                            	| [$0a4c: call    $309f] insert task
	lea	gamemode2_600a,a0              	| [$0a4f: ld      hl,gamemode2_600a] load HL with game mode2 address
	addq.b	#1,(a0)                         	| [$0a52: inc     (hl)] increase game mode

*  called from #01F1 , #0798, and other places
* draw "1UP" on screen

l_0a53:
	move.b	#0x01,d0                        	| [$0a53: ld      a,$01] load A with "1"
	WRITE_TO_SCREEN   0x7740                       	| [$0a55: ld      ($7740),a] write to screen
	move.b	#0x25,d0                        	| [$0a58: ld      a,$25] load A with "U"
	WRITE_TO_SCREEN   0x7720                       	| [$0a5a: ld      ($7720),a] write to screen
	move.b	#0x20,d0                        	| [$0a5d: ld      a,$20] load A with "P"
	WRITE_TO_SCREEN   0x7700                       	| [$0a5f: ld      ($7700),a] write to screen
	rts                                    	| [$0a62: ret] return

* arrive from #0701 when GameMode2 == 6
* clears screen and sprites, check for intro screen to run

l_0a63:
	jbsr	rst_18                            	| [$0a63: rst     $18] count down WaitTimerMSB and only continue here if == 0, else return to higher sub.
	jbsr	clear_screen_and_sprites_0874                            	| [$0a64: call    $0874] clears the screen and sprites
	lea	waittimermsb_6009,a0           	| [$0a67: ld      hl,waittimermsb_6009] load HL with timer
	move.b	#0x01,(a0)+                      	| [$0a6a: ld      (hl),$01] set timer to 1
	                           	| [$0a6c: inc     l] HL := GameMode2
	addq.b	#1,(a0)                         	| [$0a6d: inc     (hl)] increase game mode2 to 7
	lea	game_start_flag_622c,a1        	| [$0a6e: ld      de,game_start_flag_622c] load DE with game start flag address
	move.b	(a1),d0                         	| [$0a71: ld      a,(de)] load A with game start flag
	                               	| [$0a72: and     a] is this game just beginning?
	beq.b	0f                               	| [...]
	rts                                    	| [$0a73: ret     nz] yes, return [...]
0:

	addq.b	#1,(a0)                         	| [$0a74: inc     (hl)] else increase game mode2 to 8 - skip kong intro to begin
	rts                                    	| [$0a75: ret] return

* arrive from #0701 when GameMode2 == 7

l_0a76:
	move.b	intro_screen_counter_6385,d0    	| [$0a76: ld      a,(intro_screen_counter_6385)] varies from 0 to 7 while the intro screen runs, when kong climbs the dual ladders and scary music is played
	jbsr	rst_28                            	| [$0a79: rst     $28] jump based on A

	.long	l_0a8a	|    0       | #0A8A
	.long	l_0abf	|    1       | #0ABF
	.long	l_0ae8	|    2       | #0AE8
	.long	l_3069	|    3       | #3069
	.long	l_0b06	|    4       | #0B06
	.long	l_3069	|    5       | #3069
	.long	l_0b68	|    6       | #0B68
	.long	l_0bb3	|    7       | #0BB3

l_0a8a:
* arrive from #0A79 when intro screen indicator == 0

	clr.b	d0                               	| [$0a8a: xor     a] A := 0
	move.b	d0,reg_palette_a                	| [$0a8b: ld      (reg_palette_a),a] clear palette bank selector
	addq.b	#1,d0                           	| [$0a8e: inc     a] A := 1
	move.b	d0,reg_palette_b                	| [$0a8f: ld      (reg_palette_b),a] store into palette bank selector
	jbsr	osd_update_palette_bank
	lea	game_rom+0x380d,a1                      	| [$0a92: ld      de,$380d] load DE with start of table data
	jbsr	draw_the_screen_0da7                            	| [$0a95: call    $0da7] draw the screen
	move.b	#0x10,d0                        	| [$0a98: ld      a,$10] A := #10
	WRITE_TO_SCREEN	0x76a3                       	| [$0a9a: ld      ($76a3),a] erase a graphic near top of screen
 	WRITE_TO_SCREEN	0x7663                       	| [$0a9d: ld      ($7663),a] erase a graphic near top of screen
	move.b	#0xd4,d0                        	| [$0aa0: ld      a,$d4] A := #D4
	WRITE_TO_SCREEN	0x75aa                       	| [$0aa2: ld      ($75aa),a] draw a ladder at top of screen
	clr.b	d0                               	| [$0aa5: xor     a] A := 0
	move.b	d0,kong_misc_counter_62af   	| [$0aa6: ld      (kong_misc_counter_62af),a] store into kong climbing counter
	lea	game_rom+0x38b4,a0                      	| [$0aa9: ld      hl,$38b4] load HL with start of table data
	STORE_ROM_ADDRESS_LE	a0,store_63c2                   	| [$0aac: ld      (store_63c2),hl] store
	lea	game_rom+0x38cb,a0                      	| [$0aaf: ld      hl,$38cb] load HL with start of table data
	STORE_ROM_ADDRESS_LE	a0,unknown_63c4                 	| [$0ab2: ld      (unknown_63c4),hl] store
	move.b	#0x40,d0                        	| [$0ab5: ld      a,$40] A := #40
	move.b	d0,waittimermsb_6009            	| [$0ab7: ld      (waittimermsb_6009),a] set timer to #40
	lea	intro_screen_counter_6385,a0   	| [$0aba: ld      hl,intro_screen_counter_6385] load HL with intro screen counter
	addq.b	#1,(a0)                         	| [$0abd: inc     (hl)] increase
	rts                                    	| [$0abe: ret] return

* arrive from #0A79 when intro screen indicator == 1

l_0abf:
	jbsr	rst_18                            	| [$0abf: rst     $18] count down timer and only continue here if zero, else RET
	lea	game_rom+0x388c,a0                      	| [$0ac0: ld      hl,$388c] load HL with start of table data for kong
	jbsr	update_kong_sprites_004e                            	| [$0ac3: call    $004e] update kong's sprites
	lea	start_of_kong_sprite_6908,a0   	| [$0ac6: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	move.b	#0x30,d2                        	| [$0ac9: ld      c,$30] load offset to add
	jbsr	rst_38                            	| [$0acb: rst     $38] move kong
	lea	kong_sprite_array_690b,a0      	| [$0acc: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	move.b	#0x99,d2                        	| [$0acf: ld      c,$99] load offset to add
	jbsr	rst_38                            	| [$0ad1: rst     $38] move kong
	move.b	#0x1f,d0                        	| [$0ad2: ld      a,$1f] A := #1F
	move.b	d0,kong_ladder_climb_counter_638e	| [$0ad4: ld      (kong_ladder_climb_counter_638e),a] store into kong ladder climb counter
	clr.b	d0                               	| [$0ad7: xor     a] A := 0
	move.b	d0,clear_kongs_top_right_sprite_690c	| [$0ad8: ld      (clear_kongs_top_right_sprite_690c),a] store into kong's right arm sprite

	st.b	in_intro_flag
	move.w	#MUS_INTRO,d0
	jbsr	osd_sound_start
	
	lea	sound_buffer_address_608a,a0   	| [$0adb: ld      hl,sound_buffer_address_608a] load HL with music buffer
	move.b	#MUS_INTRO,(a0)+                      	| [$0ade: ld      (hl),$01] play scary music for start of game sound
	                           	| [$0ae0: inc     hl] load HL with duration
	move.b	#0x03,(a0)                      	| [$0ae1: ld      (hl),$03] set duration to 3
	lea	intro_screen_counter_6385,a0   	| [$0ae3: ld      hl,intro_screen_counter_6385] load HL with intro screen counter
	addq.b	#1,(a0)                         	| [$0ae6: inc     (hl)] increase
	rts                                    	| [$0ae7: ret] return

* arrive from #0A79 when intro screen indicator == 2

l_0ae8:
	jbsr	kong_climbing_ladder_with_girl_306f        	| [$0ae8: call    $306f] animate kong climbing up the ladder with girl under arm
	move.b	kong_misc_counter_62af,d0   	| [$0aeb: ld      a,(kong_misc_counter_62af)] load A with kong climbing counter
	and.b	#0x0f,d0                         	| [$0aee: and     $0f] mask bits, now between 0 and #F.  zero?
	bne.b	0f                               	| [...]
	jbsr	l_304a                            	| [$0af0: call    z,$304a] yes, roll up kong's ladder behind him
0:

	move.b	kong_sprite_array_690b,d0       	| [$0af3: ld      a,(kong_sprite_array_690b)] load HL with start of Kong sprite
	cmp.b	#0x5d,d0                         	| [$0af6: cp      $5d] < #5D ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$0af8: ret     nc] no, return [...]
0:

	move.b	#0x20,d0                        	| [$0af9: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$0afb: ld      (waittimermsb_6009),a] set timer to #20
	lea	intro_screen_counter_6385,a0   	| [$0afe: ld      hl,intro_screen_counter_6385] load HL with intro screen counter
	addq.b	#1,(a0)                         	| [$0b01: inc     (hl)] increase
	STORE_RAM_ADDRESS_LE		a0,timer_unknown_63c0           	| [$0b02: ld      (timer_unknown_63c0),hl] store HL into ???
	rts                                    	| [$0b05: ret] return

* arrive from #0A79 when intro screen indicator == 4

l_0b06:
	move.b	framecounter_601a,d0            	| [$0b06: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	ror.b	#1,d0                            	| [$0b09: rrca] rotate right.  carry bit?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0b0a: ret     c] yes, return [...]
0:

	LOAD_ROM_ADDRESS_LE	store_63c2,a0               	| [$0b0b: ld      hl,(store_63c2)] load HL with ??? EG HL = #38B4
 	move.b	(a0),d0                         	| [$0b0e: ld      a,(hl)] load table data
	cmp.b	#0x7f,d0                         	| [$0b0f: cp      $7f] end of data ?
	jeq	l_0b1e                             	| [$0b11: jp      z,$0b1e] yes, jump ahead

	addq.w	#1,a0                           	| [$0b14: inc     hl] next HL
	STORE_ROM_ADDRESS_LE	a0,store_63c2                   	| [$0b15: ld      (store_63c2),hl] store
	move.b	d0,d2                           	| [$0b18: ld      c,a] C := A
	lea	kong_sprite_array_690b,a0      	| [$0b19: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	jbsr	rst_38                            	| [$0b1c: rst     $38] move kong
	rts                                    	| [$0b1d: ret] return

l_0b1e:
	lea	game_rom+0x385c,a0                      	| [$0b1e: ld      hl,$385c] load HL with start of kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$0b21: call    $004e] update kong's sprites
	lea	girls_head_sprite_6900,a1      	| [$0b24: ld      de,girls_head_sprite_6900] load destination with girl sprite
	move.w	#0x08,d1                        	| [$0b27: ld      bc,$0008] set counter to 8 8
	jbsr	ldir                              	| [$0b2a: ldir] draw the girl after kong takes her up the ladder
	lea	start_of_kong_sprite_6908,a0   	| [$0b2c: ld      hl,start_of_kong_sprite_6908] load HL with kong sprite start address
	move.b	#0x50,d2                        	| [$0b2f: ld      c,$50] C := #50
	jbsr	rst_38                            	| [$0b31: rst     $38] move kong
	lea	kong_sprite_array_690b,a0      	| [$0b32: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	move.b	#0xfc,d2                        	| [$0b35: ld      c,$fc] C := #FC
	jbsr	rst_38                            	| [$0b37: rst     $38] move kong

l_0b38:
	jbsr	l_304a                            	| [$0b38: call    $304a] roll up kong's ladder behind him
	move.b	kong_ladder_climb_counter_638e,d0	| [$0b3b: ld      a,(kong_ladder_climb_counter_638e)] load A with kong ladder climb counter
	cmp.b	#0x0a,d0                         	| [$0b3e: cp      $0a] == #A ? (all done)
	jne	l_0b38                             	| [$0b40: jp      nz,$0b38] no, loop again

	move.b	#0x03,d0                        	| [$0b43: ld      a,$03] set boom sound duration
	move.b	d0,boom_sound_address_6082      	| [$0b45: ld      (boom_sound_address_6082),a] play boom sound
	move.w	#BOOM_SND,d0
	jbsr	osd_sound_start
	
	lea	game_rom+0x392c,a1                      	| [$0b48: ld      de,$392c] load DE with table data start for first angled girder
	jbsr	draw_the_screen_0da7                            	| [$0b4b: call    $0da7] draw the angled girder
	move.b	#0x10,d0                        	| [$0b4e: ld      a,$10] A := #10 = clear character

	WRITE_TO_SCREEN   0x74aa                       	| [$0b50: ld      ($74aa),a] clear the right end of the top girder
	WRITE_TO_SCREEN   0x748a                       	| [$0b53: ld      ($748a),a] clear the right end of the top girder
	move.b	#0x05,d0                        	| [$0b56: ld      a,$05] A := 5
	move.b	d0,kong_bounce_counter_638d     	| [$0b58: ld      (kong_bounce_counter_638d),a] store into kong bounce counter
	move.b	#0x20,d0                        	| [$0b5b: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$0b5d: ld      (waittimermsb_6009),a] set timer to #20
	lea	intro_screen_counter_6385,a0   	| [$0b60: ld      hl,intro_screen_counter_6385] load HL with intro screen counter
	addq.b	#1,(a0)                         	| [$0b63: inc     (hl)] increase
	STORE_RAM_ADDRESS_LE	a0,timer_unknown_63c0           	| [$0b64: ld      (timer_unknown_63c0),hl] store into ???
	rts                                    	| [$0b67: ret] return

* arrive from #0A79 when intro screen indicator == 6

l_0b68:
	move.b	framecounter_601a,d0            	| [$0b68: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	ror.b	#1,d0                            	| [$0b6b: rrca] rotate right.  carry bit set?
	bcc.b	0f                               	| [...]
	rts                                    	| [$0b6c: ret     c] yes, return [...]
0:

* make kong jump to the left during intro

	LOAD_ROM_ADDRESS_LE	unknown_63c4,a0             	| [$0b6d: ld      hl,(unknown_63c4)] load HL with ??? (table data?)
	move.b	(a0),d0                         	| [$0b70: ld      a,(hl)] get table data
	cmp.b	#0x7f,d0                         	| [$0b71: cp      $7f] done ?
	jeq	l_0b86                             	| [$0b73: jp      z,$0b86] yes, jump ahead

	addq.w	#1,a0                           	| [$0b76: inc     hl] next table entry
	STORE_ROM_ADDRESS_LE	a0,unknown_63c4                 	| [$0b77: ld      (unknown_63c4),hl] store for next
	lea	kong_sprite_array_690b,a0      	| [$0b7a: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	move.b	d0,d2                           	| [$0b7d: ld      c,a] C := A
	jbsr	rst_38                            	| [$0b7e: rst     $38] move kong
	lea	start_of_kong_sprite_6908,a0   	| [$0b7f: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	st.b	d2                                	| [$0b82: ld      c,$ff] C := #FF (negative 1)
	jbsr	rst_38                            	| [$0b84: rst     $38] move kong
	rts                                    	| [$0b85: ret] return

l_0b86:
	lea	game_rom+0x38cb,a0                      	| [$0b86: ld      hl,$38cb] load HL with start of table data
	STORE_ROM_ADDRESS_LE	a0,unknown_63c4                 	| [$0b89: ld      (unknown_63c4),hl] store into ???
	move.b	#0x03,d0                        	| [$0b8c: ld      a,$03] set boom sound duration
	move.w	#BOOM_SND,d0
	jbsr	osd_sound_start
	move.b	d0,boom_sound_address_6082      	| [$0b8e: ld      (boom_sound_address_6082),a] play boom sound
	lea	game_rom+0x38dc,a0                      	| [$0b91: ld      hl,$38dc] load HL with start of table data
	move.b	kong_bounce_counter_638d,d0     	| [$0b94: ld      a,(kong_bounce_counter_638d)] load A with kong bounce counter
	subq.b	#1,d0                           	| [$0b97: dec     a] decrease
	rol.b	#4,d0                            	| [$0b98: rlca] * 4
	clr.w	d3                               	| [$0b9d: ld      d,$00] D := 0
	move.b	d0,d3                           	| [$0b9c: ld      e,a] copy to E
	add.w	d3,a0                            	| [$0b9f: add     hl,de] add to HL
	exg	a1,a0                              	| [$0ba0: ex      de,hl] DE <> HL
	jbsr	draw_the_screen_0da7                            	| [$0ba1: call    $0da7] draw the screen
	lea	kong_bounce_counter_638d,a0    	| [$0ba4: ld      hl,kong_bounce_counter_638d] load HL with kong bounce counter
	subq.b	#1,(a0)                         	| [$0ba7: dec     (hl)] decrease.  done bouncing?
	beq.b	0f                               	| [...]
	rts                                    	| [$0ba8: ret     nz] no, return [...]
0:

	move.b	#0xb0,d0                        	| [$0ba9: ld      a,$b0] else A := #B0
	move.b	d0,waittimermsb_6009            	| [$0bab: ld      (waittimermsb_6009),a] store into counter
	lea	intro_screen_counter_6385,a0   	| [$0bae: ld      hl,intro_screen_counter_6385] load HL with intro screen counter
	addq.b	#1,(a0)                         	| [$0bb1: inc     (hl)] increase
	rts                                    	| [$0bb2: ret] return

* arrive from #0A79 - last part of the intro to the game ?

l_0bb3:
	lea	sound_buffer_address_608a,a0   	| [$0bb3: ld      hl,sound_buffer_address_608a] load HL with music sound address
	move.b	waittimermsb_6009,d0            	| [$0bb6: ld      a,(waittimermsb_6009)] load A with timer value
	cmp.b	#0x90,d0                         	| [$0bb9: cp      $90] == #90 ?
	jne	l_0bc8                             	| [$0bbb: jr      nz,$0bc8] no, skip ahead
	move.b	#MUS_DK_ROAR,d0					| AKA GORILLA_YELLS_SND
	move.b	d0,(a0)+                      	| [$0bbd: ld      (hl),$0f] play sound #0F = X X X kong sound
	                           	| [$0bbf: inc     hl] HL := GameMode2
	jbsr	osd_sound_start
	move.b	#0x03,(a0)                      	| [$0bc0: ld      (hl),$03] set game mode2 to 3
	lea	unknown_6919,a0                	| [$0bc2: ld      hl,unknown_6919] load HL with kong's face sprite
	addq.b	#1,(a0)                         	| [$0bc5: inc     (hl)] increase - kong is now showing teeth
	jra	l_0bd1                             	| [$0bc6: jr      $0bd1] skip ahead

l_0bc8:
	cmp.b	#0x18,d0                         	| [$0bc8: cp      $18] timer == #18 ?
	jne	l_0bd1                             	| [$0bca: jr      nz,$0bd1] no, skip ahead

	lea	unknown_6919,a0                	| [$0bcc: ld      hl,unknown_6919] load HL with kong's face sprite
	subq.b	#1,(a0)                         	| [$0bcf: dec     (hl)] decrease - kong is normal face
	nop                                    	| [$0bd0: nop] no operation [?]

l_0bd1:
	jbsr	rst_18                            	| [$0bd1: rst     $18] count down timer and only continue here if zero, else RET.  HL is loaded with WaitTimerMSB address
	clr.b	d0                               	| [$0bd2: xor     a] A := 0
	move.b	d0,intro_screen_counter_6385    	| [$0bd3: ld      (intro_screen_counter_6385),a] reset intro screen counter to zero
	addq.b	#1,(a0)+                         	| [$0bd6: inc     (hl)] increase timer in WaitTimerMSB
	                           	| [$0bd7: inc     hl] HL := GameMode2
	addq.b	#1,(a0)                         	| [$0bd8: inc     (hl)] increase game mode2 (to 8?)
	rts                                    	| [$0bd9: ret] return

store_d2_in_video_ram:
	exg	d2,d0
	jbsr	osd_w_videoram
	exg	d2,d0
	rts
	

* called after kong jump on the girders at start of game ?
* also after mario dies
* how high can you get ?
* draws goofy kongs and 25m, 50m, etc.
* plays music
height_pre_level_screen_0bda:
	jbsr	clear_all_sounds_011c                            	| [$0bda: call    $011c] clear all sounds
	jbsr	rst_18                            	| [$0bdd: rst     $18] count down timer and only continue here if zero, else RET

	jbsr	clear_screen_and_sprites_0874                            	| [$0bde: call    $0874] clear the screen and sprites
	move.w	#0x0600,d3                        	| [$0be1: ld      d,$06] load task #6
	move.b	mario_array_6200,d0             	| [$0be3: ld      a,(mario_array_6200)] load A with 1 when mario is alive, 0 when dead
	move.b	d0,d3                           	| [$0be6: ld      e,a] store into task parameter
	jbsr	insert_task_309f                            	| [$0be7: call    $309f] insert task to display remaining lives and level number
	lea	reg_palette_a,a0               	| [$0bea: ld      hl,reg_palette_a] load HL with palette bank
	move.b	#0x01,(a0)+                      	| [$0bed: ld      (hl),$01] set palette bank selector
										| [$0bef: inc     hl] next palette bank
	clr.b	(a0)                             	| [$0bf0: ld      (hl),$00] clear palette bank selector
	jbsr	osd_update_palette_bank
	lea	sound_buffer_address_608a,a0   	| [$0bf2: ld      hl,sound_buffer_address_608a] load HL with tune address
	move.b	#0x02,(a0)+                      	| [$0bf5: ld      (hl),$02] play how high can you get sound?
	                           	| [$0bf7: inc     hl] HL := #608B .  load HL with music timer ?
	move.b	#0x03,(a0)                      	| [$0bf8: ld      (hl),$03] set to 3 units
	move.b	#MUS_HOWHIGH,D0
	jbsr	osd_sound_start
	
	lea	store_63a7,a0                  	| [$0bfa: ld      hl,store_63a7] load HL with address of counter
	clr.b	(a0)                             	| [$0bfd: ld      (hl),$00] clear the counter
	move.l	#0x76dc,d7                      	| [$0bff: ld      hl,$76dc] load HL with screen address to draw the number of meters ?
	move.w	d7,screen_pointer_for_meters_63a8                  	| [$0c02: ld      (screen_pointer_for_meters_63a8),hl] store - used at #0C54
	move.b	number_of_goofys_to_draw_622e,d0	| [$0c05: ld      a,(number_of_goofys_to_draw_622e)] load A with number of goofy kongs to draw
	cmp.b	#0x06,d0                         	| [$0c08: cp      $06] < 6 ?
	jcs	l_0c11                             	| [$0c0a: jr      c,$0c11] yes, skip next 2 steps [BUG.  change to 0C0A  1805   JR #0C11 to fix]

	move.b	#0x05,d0                        	| [$0c0c: ld      a,$05] else A := 5
	move.b	d0,number_of_goofys_to_draw_622e	| [$0c0e: ld      (number_of_goofys_to_draw_622e),a] store into number of goofy kongs to draw

l_0c11:
	move.b	current_screen_level_622f,d0    	| [$0c11: ld      a,(current_screen_level_622f)] load A with current screen/level
	move.b	d0,d1                           	| [$0c14: ld      b,a] copy to B
	move.b	store_622a,d0                   	| [$0c15: ld      a,(store_622a)] load A with the low byte of the pointer for lookup to screens/levels
	cmp.b	d1,d0                            	| [$0c18: cp      b] are they the same ?
	jeq	l_0c1f                             	| [$0c19: jr      z,$0c1f] yes, skip next 2 steps

	lea	number_of_goofys_to_draw_622e,a0	| [$0c1b: ld      hl,number_of_goofys_to_draw_622e] else load HL with number of goofys to draw
	addq.b	#1,(a0)                         	| [$0c1e: inc     (hl)] increase

l_0c1f:
	move.b	d0,current_screen_level_622f    	| [$0c1f: ld      (current_screen_level_622f),a] store A into current screen/level
	move.b	number_of_goofys_to_draw_622e,d0	| [$0c22: ld      a,(number_of_goofys_to_draw_622e)] load A with number of goofys to draw
	move.b	d0,d1                           	| [$0c25: ld      b,a] copy to B for use as loop counter, refer to #0C7E
	move.w	#0x75bc,d7                      	| [$0c26: ld      hl,$75bc] load HL with screen location start for goofy kong

l_0c29:
	move.b	#0x50,d2                        	| [$0c29: ld      c,$50] C := #50 = start graphic for goofy kong

l_0c2b:
	bsr		store_d2_in_video_ram           	| [$0c2b: ld      (hl),c] draw part of goofy kong
	addq.b	#1,d2                           	| [$0c2c: inc     c] next graphic
	subq.w	#1,d7                           	| [$0c2d: dec     hl] next screen location
	bsr		store_d2_in_video_ram                         	| [$0c2e: ld      (hl),c] draw part of goofy kong
	addq.b	#1,d2                           	| [$0c2f: inc     c] next graphic
	subq.w	#1,d7                           	| [$0c30: dec     hl] next screen location
	bsr		store_d2_in_video_ram                         	| [$0c31: ld      (hl),c] draw part of goofy kong
	addq.b	#1,d2                           	| [$0c32: inc     c] next graphic
	subq.w	#1,d7                           	| [$0c33: dec     hl] next screen location
	bsr		store_d2_in_video_ram                         	| [$0c34: ld      (hl),c] draw part of goofy kong
	move.b	d2,d0                           	| [$0c35: ld      a,c] load A with graphic number
	cmp.b	#0x67,d0                         	| [$0c36: cp      $67] == #67 ? (are we done?)
	jeq	l_0c43                             	| [$0c38: jp      z,$0c43] yes, skip next 4 steps

	addq.b	#1,d2                           	| [$0c3b: inc     c] next C
	move.w	#0x0023,d3                      	| [$0c3c: ld      de,$0023] load DE with offset 35
	add.w	d3,d7                            	| [$0c3f: add     hl,de] add to screen location
	jra	l_0c2b                             	| [$0c40: jp      $0c2b] loop again

l_0c43:
	move.b	store_63a7,d0                   	| [$0c43: ld      a,(store_63a7)] load A with counter
	addq.b	#1,d0                           	| [$0c46: inc     a] increase
	move.b	d0,store_63a7                   	| [$0c47: ld      (store_63a7),a] store
	subq.b	#1,d0                           	| [$0c4a: dec     a] decrease
	asl.b	#2,d0                            	| [$0c4b: sla     a] * 2
	
	move.w	d7,-(sp)                        	| [$0c4f: push    hl] save HL
	lea	game_rom+0x3cf0,a0                      	| [$0c50: ld      hl,$3cf0] load HL with start of table data for 25m, 50m, etc.
	movem.w	d1/d2,-(sp)                    	| [$0c53: push    bc] save BC
	move.w	screen_pointer_for_meters_63a8,d7              	| [$0c54: ld      ix,(screen_pointer_for_meters_63a8)] load IX with screen VRAM address to draw number of meters
	move.w	d7,a2
	clr.w	d1                               	| [$0c59: ld      b,$00] B := 0
	move.b	d0,d1                           	| [$0c58: ld      c,a] C := A, used for offset
	add.w	d1,a0                            	| [$0c5b: add     hl,bc] add offset
	move.b	(a0),d0                         	| [$0c5c: ld      a,(hl)] get table data
	move.w		a2,d7
	add.w	#0x60,d7
	jbsr	osd_w_videoram                    	| [$0c5d: ld      (ix+$60),a] write to screen
	move.w		a2,d7
	addq.w	#1,a0                           	| [$0c60: inc     hl] next
	move.b	(a0)+,d0                         	| [$0c61: ld      a,(hl)] get data
	move.w		a2,d7
	add.w	#0x40,d7
	jbsr	osd_w_videoram                    	| [$0c62: ld      (ix+$40),a] write to screen
	move.w		a2,d7
										| [$0c65: inc     hl] next
	move.b	(a0),d0                         	| [$0c66: ld      a,(hl)] get table data
	add.w	#0x20,d7
	jbsr	osd_w_videoram                    	| [$0c67: ld      (ix+$20),a] write to screen
	sub.w	#0x40,d7
	move.b	#0x8b,d0
	jbsr	osd_w_videoram                	| [$0c6a: ld      (ix-$20),$8b] write "m" to screen for 25m, 50m ...

	movem.w	(sp)+,d1/d2                    	| [$0c6e: pop     bc] restore BC

												| [$0c6f: push    ix] transfer IX to HL (part 1/2)
												| [$0c71: pop     hl] transfer IX to HL (part 2/2)
												| [$0c72: ld      de,$fffc] load offset for next screen location
	sub.w	#4-0x20,d7                            	| [$0c75: add     hl,de] add offset
	move.w	d7,screen_pointer_for_meters_63a8                  	| [$0c76: ld      (screen_pointer_for_meters_63a8),hl] store result
	move.w	(sp)+,d7                        	| [$0c79: pop     hl] restore HL
	move.w	#0xff5f,d3                      	| [$0c7a: ld      de,$ff5f] load DE with offset for goofy
	add.w	d3,d7                            	| [$0c7d: add     hl,de] add offset to draw next goofy
	subq.b	#1,d1                           	| [$0c7e: dec     b] decrease B.  done drawing goofy kongs ?
	jne	l_0c29                             	| [$0c7f: jp      nz,$0c29] no, loop and do another [why not use DJNZ ???]

	move.w  #0x0307,d3                      	| [$0c82: ld      de,$0307] load task data for text #7 "HOW HIGH CAN YOU GET?"
	jbsr	insert_task_309f                            	| [$0c85: call    $309f] insert task to draw text
	lea	waittimermsb_6009,a0           	| [$0c88: ld      hl,waittimermsb_6009] load HL with timer to wait
	move.b	#0xa0,(a0)+                      	| [$0c8b: ld      (hl),$a0] set timer for #A0 units
	                           	| [$0c8d: inc     hl] HL := GameMode2
	addq.b	#2,(a0)                         	| [$0c8e: inc     (hl)] * 2
	rts                                    	| [$0c90: ret] return

* arrive here from #0701 when game mode = 9
* clears screen, update timers, draws current screen, sets background music,

l_0c91:
	jbsr	rst_18                            	| [$0c91: rst     $18] count down WaitTimerMSB and only continue when 0

* arrive here from #0776 during attract mode

l_0c92:
	jbsr	clear_screen_and_sprites_0874                            	| [$0c92: call    $0874] clears the screen and sprites
	clr.b	d0                               	| [$0c95: xor     a] A := 0
	move.b	d0,onscreen_timer_638c    	| [$0c96: ld      (onscreen_timer_638c),a] reset onscreen timer
	move.w  #0x0501,d3                      	| [$0c99: ld      de,$0501] load DE with task #5, parameter 1 update onscreen bonus timer and play sound & change to red if below 1000
	jbsr	insert_task_309f                            	| [$0c9c: call    $309f] insert task
	lea	reg_palette_a,a0               	| [$0c9f: ld      hl,reg_palette_a] load HL with palette bank selector
	clr.b	(a0)+                             	| [$0ca2: ld      (hl),$00] clear palette bank selector
											| [$0ca4: inc     hl] next bank
	move.b	#0x01,(a0)                      	| [$0ca5: ld      (hl),$01] set palette bank selector
	jbsr	osd_update_palette_bank
	move.b	screen_number_6227,d0           	| [$0ca7: ld      a,(screen_number_6227)] load A with screen number
	subq.b	#1,d0                           	| [$0caa: dec     a] decrease by 1

	.ifeq	OPT_START_SCREEN-2
	move.b	#2,screen_number_6227
	jra		draw_conveyors_screen_0cdf
	.endif

	.ifeq	OPT_START_SCREEN-3
	move.b	#3,screen_number_6227
	jra	l_0cf2
	.endif

	.ifeq	OPT_START_SCREEN-4
	move.b	#4,screen_number_6227
	jra	rivets_0cb6
	.endif

	jeq	l_0cd4                             	| [$0cab: jp      z,$0cd4] if zero jump to #0Cd4 - we were on girders - continue on #0CC6

	subq.b	#1,d0                           	| [$0cae: dec     a] if not decrease a again
	jeq	draw_conveyors_screen_0cdf                             	| [$0caf: jp      z,$0cdf] if zero jump to #0CDf - we were on pie - continue on #0CC6


	subq.b	#1,d0                           	| [$0cb2: dec     a] if not decrease a again
	jeq	l_0cf2                             	| [$0cb3: jp      z,$0cf2] iF zero jump to #0CF2 - we were on elevators - continue on #0CC6
                                        * else we are on rivets
rivets_0cb6:
	jbsr	l_0d43                            	| [$0cb6: call    $0d43] draws the blue vertical bars next to kong on rivets
	lea	reg_palette_a,a0               	| [$0cb9: ld      hl,reg_palette_a] load HL with palette bank selector
	move.b	#0x01,(a0)                      	| [$0cbc: ld      (hl),$01] set palette bank selector
	jbsr	osd_update_palette_bank
	move.b	#MUS_100M,d0                        	| [$0cbe: ld      a,$0b] load A with music code For rivets
	move.b	d0,background_music_value_6089  	| [$0cc0: ld      (background_music_value_6089),a] set music
	jbsr	osd_sound_start
	lea	game_rom+0x3c8b,a1                      	| [$0cc3: ld      de,$3c8b] load DE with start of table data for rivets

* other screens return here

l_0cc6:
	clr.b	in_intro_flag
	jbsr	draw_the_screen_0da7                            	| [$0cc6: call    $0da7] draw the screen

	move.b	screen_number_6227,d0           	| [$0cc9: ld      a,(screen_number_6227)] load A with screen number
	cmp.b	#0x04,d0                         	| [$0ccc: cp      $04] screen is rivets level?
	bne.b	0f                               	| [...]
	jbsr	l_0d00                            	| [$0cce: call    z,$0d00] yes, call sub to draw the rivets
0:

	jra	l_3fa0                             	| [$0cd1: jp      $3fa0] fix rectractable ladders for pie factory and returns to #0D5F. [orig code was JP #0D5F ?]

* girders from #0CAB

l_0cd4:
	lea	game_rom+0x3ae4,a1                      	| [$0cd4: ld      de,$3ae4] Load DE with start of table data for girders
	move.w	#MUS_25M,d0                        	| [$0cd7: ld      a,$08] A := 8 = music code for girders
	move.b	d0,background_music_value_6089  	| [$0cd9: ld      (background_music_value_6089),a] set music for girders
	jbsr	osd_sound_start
	jra	l_0cc6                             	| [$0cdc: jp      $0cc6] jump back

* conveyors from #0CAF

draw_conveyors_screen_0cdf:
	lea	game_rom+0x3b5d,a1                      	| [$0cdf: ld      de,$3b5d] load DE with start of table data for conveyors
	lea	reg_palette_a,a0               	| [$0ce2: ld      hl,reg_palette_a] load HL with palette bank selector
	move.b	#0x01,(a0)+                      	| [$0ce5: ld      (hl),$01] set palette bank selector
	                           	| [$0ce7: inc     hl]
	clr.b	(a0)                             	| [$0ce8: ld      (hl),$00] clear palette bank selector
	jbsr	osd_update_palette_bank
	move.b	#MUS_50M,d0                        	| [$0cea: ld      a,$09] load A with conveyor music
	move.b	d0,background_music_value_6089  	| [$0cec: ld      (background_music_value_6089),a] set music for conveyors
	jbsr	osd_sound_start
	jra	l_0cc6                             	| [$0cef: jp      $0cc6] jump back

* elevators from #0CB3

l_0cf2:
	jbsr	l_0d27                            	| [$0cf2: call    $0d27] draw elevator cables
	move.b	#MUS_75M,d0                        	| [$0cf5: ld      a,$0a] A := #A
	move.b	d0,background_music_value_6089  	| [$0cf7: ld      (background_music_value_6089),a] set music for elevators
	* no music in elevators
	*jbsr	osd_sound_start
	lea	game_rom+0x3be5,a1                      	| [$0cfa: ld      de,$3be5] load DE with start of table data for the elevators
	jra	l_0cc6                             	| [$0cfd: jp      $0cc6] jump back

* For the rivets level only  - draw the rivets

l_0d00:
	move.b	#0x08,d1                        	| [$0d00: ld      b,$08] for B = 1 to 8 rivets to draw
	lea	l_0d17(pc),a0                      	| [$0d02: ld      hl,$0d17] load HL with start of table data below

l_0d05:
	move.b	#0xb8,d0                        	| [$0d05: ld      a,$b8] load A with #B8 = start code for rivet
	move.b	#0x02,d2                        	| [$0d07: ld      c,$02] For C = 1 to 2
	move.w	(a0)+,d7                         	| [$0d09: ld      e,(hl)] load E with the high byte of the address
	                           	| [$0d0a: inc     hl] next HL
	                         	| [$0d0b: ld      d,(hl)] load D with the low byte of the adddress
	                           	| [$0d0c: inc     hl] next HL

l_0d0d:
	jbsr	osd_w_videoram                         	| [$0d0d: ld      (de),a] draw rivet onscreen
	subq.b	#1,d0                           	| [$0d0e: dec     a] next graphic
	addq.w	#1,d7                           	| [$0d0f: inc     de] next screen address
	subq.b	#1,d2                           	| [$0d10: dec     c] Next C
	jne	l_0d0d                             	| [$0d11: jp      nz,$0d0d] loop until done

	subq.b	#1,d1                           	| [...]
	jne	l_0d05                             	| [$0d14: djnz    $0d05] Next B

	rts                                    	| [$0d16: ret] return

* start of table data for rivets used above
* these are addresses in video RAM for the rivets
* in big endian, because well it's easy here

l_0d17:
	.word	0x76CA | #76CA
	.word	0x76CF | #76CF
	.word	0x76D4 | #76D4
	.word	0x76D9 | #76D9
	.word	0x752A | #752A
	.word	0x752F | #752F
	.word	0x7534 | #7534
	.word	0x7539 | #7539

* called from #0CF2 for elevators only
* draws the elevator cables

l_0d27:
	move.w	#0x770d,d7                      	| [$0d27: ld      hl,$770d] load HL with screen RAM location
	jbsr	l_0d30                            	| [$0d2a: call    $0d30] draw the left side elevator cable

	move.w	#0x760d,d7                      	| [$0d2d: ld      hl,$760d] load HL with screen RAM location for right side cable

l_0d30:
	move.b	#0x11,d1                        	| [$0d30: ld      b,$11] for B = 1 to #11

l_0d32:
	move.b	#0xfd,d0                      	| [$0d32: ld      (hl),$fd] draw the cable to screen
	jbsr	osd_w_videoram
	addq.w	#1,d7                           	| [$0d34: inc     hl] next location
	subq.b	#1,d1                           	| [...]
	jne	l_0d32                             	| [$0d35: djnz    $0d32] Next B

	move.w	#0x000f,d3                      	| [$0d37: ld      de,$000f] load DE with offset [why here? should be before loop starts ?] 15
	add.w	d3,d7                            	| [$0d3a: add     hl,de] add offset to location
	move.b	#0x11,d1                        	| [$0d3b: ld      b,$11] for B = 1 to #11

l_0d3d:
	move.b	#0xfc,d0                      	| [$0d3d: ld      (hl),$fc] draw cable to screen
	jbsr	osd_w_videoram
	addq.w	#1,d7                           	| [$0d3f: inc     hl] next location
	subq.b	#1,d1                           	| [...]
	jne	l_0d3d                             	| [$0d40: djnz    $0d3d] Next B

	rts                                    	| [$0d42: ret] return

* called from #0CB6 for rivets only
* draws top light blue vertical bars next to Kong

l_0d43:
	move.w	#0x7687,d7                      	| [$0d43: ld      hl,$7687] load HL with screen location (left side)
	jbsr	l_0d4c                            	| [$0d46: call    $0d4c] draw the bars
	move.w	#0x7547,d7                      	| [$0d49: ld      hl,$7547] load HL with screen location (right side)
l_0d4c:
	move.b	#0x04,d1                        	| [$0d4c: ld      b,$04] for B = 1 to 4

l_0d4e:
	move.b	#0xfd,d0                      	| [$0d4e: ld      (hl),$fd] draw a bar
	jbsr	osd_w_videoram
	addq.w	#1,d7                           	| [$0d50: inc     hl] next screen location
	subq.b	#1,d1                           	| [...]
	jne	l_0d4e                             	| [$0d51: djnz    $0d4e] Next B

	move.w	#0x001c,d3                      	| [$0d53: ld      de,$001c] load offset 28
	add.w	d3,d7                            	| [$0d56: add     hl,de] add offset
	move.b	#0x04,d1                        	| [$0d57: ld      b,$04] for B = 1 to 4

l_0d59:
	move.b	#0xfc,d0                      	| [$0d59: ld      (hl),$fc] draw a bar
	jbsr	osd_w_videoram	
	addq.w	#1,d7                           	| [$0d5b: inc     hl] next screen location
	subq.b	#1,d1                           	| [...]
	jne	l_0d59                             	| [$0d5c: djnz    $0d59] next B

	rts                                    	| [$0d5e: ret] return

* jump here from #0CD1 (via #3FA3)

l_0d5f:
	jbsr	l_0f56                            	| [$0d5f: call    $0f56] clear and initialize RAM values, compute initial timer, draw all initial sprites
	jbsr	l_2441                            	| [$0d62: call    $2441]
	lea	waittimermsb_6009,a0           	| [$0d65: ld      hl,waittimermsb_6009] load HL with timer addr.
	move.b	#0x40,(a0)+                      	| [$0d68: ld      (hl),$40] set timer to #40
	                           	| [$0d6a: inc     hl] HL := GameMode2
	addq.b	#1,(a0)                         	| [$0d6b: inc     (hl)] increase game mode2
	lea	game_rom+0x385c,a0                      	| [$0d6c: ld      hl,$385c] load HL with start of kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$0d6f: call    $004e] update kong's sprites

	lea	girls_head_sprite_6900,a1      	| [$0d72: ld      de,girls_head_sprite_6900] set destination to girl sprite
	move.w	#0x08,d1                        	| [$0d75: ld      bc,$0008] set counter to 8 8
	jbsr	ldir                              	| [$0d78: ldir] draw the girl on screen

	move.b	screen_number_6227,d0           	| [$0d7a: ld      a,(screen_number_6227)] load a with screen number
	cmp.b	#0x04,d0                         	| [$0d7d: cp      $04] is this rivets screen?
	jeq	l_0d8b                             	| [$0d7f: jr      z,$0d8b] if yes, jump ahead a bit

	ror.b	#2,d0                            	| [$0d81: rrca] no, roll right twice * 2
	bcc.b	0f                               	| [...]
	rts                                    	| [$0d83: ret     c] yes, return [...]
0:

                                        * else this is girders, kong needs to be moved

	lea	kong_sprite_array_690b,a0      	| [$0d84: ld      hl,kong_sprite_array_690b] load HL with start of kong sprite
	move.b	#0xfc,d2                        	| [$0d87: ld      c,$fc] set to move by -4
	jbsr	rst_38                            	| [$0d89: rst     $38] move kong
	rts                                    	| [$0d8a: ret] return

* on the rivets

l_0d8b:
	lea	start_of_kong_sprite_6908,a0   	| [$0d8b: ld      hl,start_of_kong_sprite_6908] load HL with kong sprite RAM
	move.b	#0x44,d2                        	| [$0d8e: ld      c,$44] set counter to #44 ?
	jbsr	rst_38                            	| [$0d90: rst     $38] move kong

	move.w	#0x0004,d3                      	| [$0d91: ld      de,$0004] load counters 4
	move.b	#0x02,d1                        	| [$0d94: ld      bc,$0210] load counters 528
	move.b	#0x10,d2                        	| [$0d94: ld      bc,$0210] load counters 528
	lea	girls_head_sprite_6900,a0      	| [$0d97: ld      hl,girls_head_sprite_6900] load HL with start of sprite RAM (girl sprite first)
	jbsr	l_003d                            	| [$0d9a: call    $003d] move girl to right

	move.b	#0x02,d1                        	| [$0d9d: ld      bc,$02f8] load counters 760
	move.b	#0xf8,d2                        	| [$0d9d: ld      bc,$02f8] load counters 760
	lea	sprite_girl_table_data_y_position_6903,a0	| [$0da0: ld      hl,sprite_girl_table_data_y_position_6903] load HL with Y value of girl -1
	jbsr	l_003d                            	| [$0da3: call    $003d] move girl up

	rts                                    	| [$0da6: ret] return [to #1983]

* part of routine which draws the screen
* DE is preloaded with address of table data
* called from many places

draw_the_screen_0da7:
	move.b	(a1),d0                         	| [$0da7: ld      a,(de)] load a with DE - points to start of table data
	move.b	d0,original_data_item_63b3      	| [$0da8: ld      (original_data_item_63b3),a] save for later use
	cmp.b	#0xaa,d0                         	| [$0dab: cp      $aa] is this the end of the data?
	bne.b	0f                               	| [...]
	rts                                    	| [$0dad: ret     z] yes, return [...]
0:

* else draw screen stuff

	addq.w	#1,a1                           	| [$0dae: inc     de] next table entry
	move.b	(a1),d0                         	| [$0daf: ld      a,(de)] load A with table data
	move.b	d0,d5                           	| [$0db0: ld      h,a] copy to H
	move.b	d5,d1                           	| [$0db1: ld      b,h] copy to B
	addq.w	#1,a1                           	| [$0db2: inc     de] next table entry
	move.b	(a1),d0                         	| [$0db3: ld      a,(de)] load A with table data
	move.b	d0,d6                           	| [$0db4: ld      l,a] copy to L
	move.b	d6,d2                           	| [$0db5: ld      c,l] copy to C
	movem.w	d3/d4,-(sp)                    	| [$0db6: push    de] save DE
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$0db7: call    $2ff0] convert HL into VRAM address
	movem.w	(sp)+,d3/d4                    	| [$0dba: pop     de] restore DE	
	MOVE_TO_VAR	d7,current_screen_address_63ab                 	| [$0dbb: ld      (current_screen_address_63ab),hl] store the VRAM address into this location for later use.  starting point of whatever we are drawing
	move.b	d1,d0                           	| [$0dbe: ld      a,b] A := B = original data item
	and.b	#0x07,d0                         	| [$0dbf: and     $07] mask bits, now between 0 and 7
	move.b	d0,unknown_63b4                 	| [$0dc1: ld      (unknown_63b4),a] store into ???
	move.b	d2,d0                           	| [$0dc4: ld      a,c] A := C = 2nd data item
	and.b	#0x07,d0                         	| [$0dc5: and     $07] mask bits, now between 0 and 7
	move.b	d0,original_data_item__63af     	| [$0dc7: ld      (original_data_item__63af),a] store into ???
	addq.w	#1,a1                           	| [$0dca: inc     de] next table entry
	move.b	(a1),d0                         	| [$0dcb: ld      a,(de)] load A with table data
	move.b	d0,d5                           	| [$0dcc: ld      h,a] copy to H
	sub.b	d1,d0                            	| [$0dcd: sub     b] subract the original data.  less than zero?
	jcc	l_0dd3                             	| [$0dce: jp      nc,$0dd3] no, skip next step

	neg.b	d0                               	| [$0dd1: neg] Negate A (A := #FF - A)

l_0dd3:
	move.b	d0,result_63b1                  	| [$0dd3: ld      (result_63b1),a] store into ???
	addq.w	#1,a1                           	| [$0dd6: inc     de] next table entry
	move.b	(a1),d0                         	| [$0dd7: ld      a,(de)] load A with table data
	move.b	d0,d6                           	| [$0dd8: ld      l,a] copy to L
	sub.b	d2,d0                            	| [$0dd9: sub     c] subtract the 2nd data item
	move.b	d0,unknown_63b2                 	| [$0dda: ld      (unknown_63b2),a] store into ???
	move.b	(a1),d0                         	| [$0ddd: ld      a,(de)] load A with same table data
	and.b	#0x07,d0                         	| [$0dde: and     $07] mask bits, now between 0 and 7
	move.b	d0,unknown_63b0                 	| [$0de0: ld      (unknown_63b0),a] store into ???
	movem.w	d3/d4,-(sp)                    	| [$0de3: push    de] save DE
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$0de4: call    $2ff0] convert HL into VRAM address
	movem.w	(sp)+,d3/d4                    	| [$0de7: pop     de] restore DE
	MOVE_TO_VAR	d7,unknown_63ad                 	| [$0de8: ld      (unknown_63ad),hl] store into ???
	move.b	original_data_item_63b3,d0      	| [$0deb: ld      a,(original_data_item_63b3)] load A with first data item
	cmp.b	#0x02,d0                         	| [$0dee: cp      $02] < 2 ? are we drawing a ladder or a broken ladder?
	jpl	l_0e4f                             	| [$0df0: jp      p,$0e4f] no, skip ahead [why P, instead of NC ?]

* else we are drawing a ladder

	move.b	unknown_63b2,d0                 	| [$0df3: ld      a,(unknown_63b2)] load A with ???
	sub.b	#0x10,d0                         	| [$0df6: sub     $10] subtract #10
	move.b	d0,d1                           	| [$0df8: ld      b,a] copy answer to B
	move.b	original_data_item__63af,d0     	| [$0df9: ld      a,(original_data_item__63af)] load A with ???
	add.b	d1,d0                            	| [$0dfc: add     a,b] add B
	move.b	d0,unknown_63b2                 	| [$0dfd: ld      (unknown_63b2),a] store into ???
	move.b	original_data_item__63af,d0     	| [$0e00: ld      a,(original_data_item__63af)] load A with ??? computed above
	add.b	#0xf0,d0                         	| [$0e03: add     a,$f0] add #F0
	MOVE_TO_REG	current_screen_address_63ab,d7             	| [$0e05: ld      hl,(current_screen_address_63ab)] load HL with VRAM address to begin drawing
	jbsr	osd_w_videoram                         	| [$0e08: ld      (hl),a] draw element to screen = girder above top of ladder ?
	addq.b	#1,d7                           	| [$0e09: inc     l] next location
	sub.b	#0x30,d0                         	| [$0e0a: sub     $30] subtract #30.  now the element to draw is a ladder
	jbsr	osd_w_videoram                         	| [$0e0c: ld      (hl),a] draw element to screen = top of ladder
	move.b	original_data_item_63b3,d0      	| [$0e0d: ld      a,(original_data_item_63b3)] load A with original data item
	cmp.b	#0x01,d0                         	| [$0e10: cp      $01] == 1 ? (is this a broken ladder?)
	jne	l_0e19                             	| [$0e12: jp      nz,$0e19] no, skip next 2 steps

	clr.b	d0                               	| [$0e15: xor     a] A := 0
	move.b	d0,unknown_63b2                 	| [$0e16: ld      (unknown_63b2),a] store into ???

l_0e19:
	                 	| [$0e19: ld      a,(unknown_63b2)] load A with ???
	sub.b	#0x08,unknown_63b2                         	| [$0e1c: sub     $08] subtract 8
	                 	| [$0e1e: ld      (unknown_63b2),a] store.  are we done?
	jcs	l_0e2a                             	| [$0e21: jp      c,$0e2a] yes, skip ahead

	addq.b	#1,d7                           	| [$0e24: inc     l] next HL
	move.b	#0xc0,d0                      	| [$0e25: ld      (hl),$c0] draw ladder to screen
	jbsr	osd_w_videoram
	jra	l_0e19                             	| [$0e27: jp      $0e19] loop again

l_0e2a:
	move.b	unknown_63b0,d0                 	| [$0e2a: ld      a,(unknown_63b0)] load A with ???
	add.b	#0xd0,d0                         	| [$0e2d: add     a,$d0] add #D0
	MOVE_TO_REG	unknown_63ad,d7             	| [$0e2f: ld      hl,(unknown_63ad)]
	jbsr	osd_w_videoram                         	| [$0e32: ld      (hl),a]
	move.b	original_data_item_63b3,d0      	| [$0e33: ld      a,(original_data_item_63b3)] load A with original data item
	cmp.b	#0x01,d0                         	| [$0e36: cp      $01] == 1 ?  (is this a broken ladder ?)
	jne	l_0e3f                             	| [$0e38: jp      nz,$0e3f] no, skip next 3 steps

* this is a broken ladder.  draw bottom part of ladder

	subq.b	#1,d7                           	| [$0e3b: dec     l] decrease HL
	move.b	#0xc0,d0                      	| [$0e3c: ld      (hl),$c0] set HL to #C0 - draws bottom part of broken ladder to screen
	jbsr		osd_w_videoram
	addq.b	#1,d7                           	| [$0e3e: inc     l] increase HL

l_0e3f:
	move.b	unknown_63b0,d0                 	| [$0e3f: ld      a,(unknown_63b0)] load A with ???
	                               	| [$0e42: cp      $00] == 0 ?
	jeq	l_0e4b                             	| [$0e44: jp      z,$0e4b] yes, skip next 3 steps

	add.b	#0xe0,d0                         	| [$0e47: add     a,$e0] add #E0
	addq.b	#1,d7                           	| [$0e49: inc     l] next HL
	jbsr		osd_w_videoram                   	| [$0e4a: ld      (hl),a] store into ???

l_0e4b:
	addq.w	#1,a1                           	| [$0e4b: inc     de] next table entry
	jra	draw_the_screen_0da7                             	| [$0e4c: jp      $0da7] loop again

* arrive from #0DF0

l_0e4f:
	move.b	original_data_item_63b3,d0      	| [$0e4f: ld      a,(original_data_item_63b3)] load A with original data item [why do this again ?  it was loaded just before coming here]
	cmp.b	#0x02,d0                         	| [$0e52: cp      $02] == 2 ?
	jne	l_0ee8                             	| [$0e54: jp      nz,$0ee8] no, skip ahead

* else data item type 2 = girder ???

	move.b	original_data_item__63af,d0     	| [$0e57: ld      a,(original_data_item__63af)] load A with original data item #2, masked to be between 0 and 7
	add.b	#0xf0,d0                         	| [$0e5a: add     a,$f0] add #F0
	move.b	d0,unknown_63b5                 	| [$0e5c: ld      (unknown_63b5),a] store into ???
	MOVE_TO_REG	current_screen_address_63ab,d7             	| [$0e5f: ld      hl,(current_screen_address_63ab)] load HL with screen address to being drawing the item

l_0e62:
	move.b	unknown_63b5,d0                 	| [$0e62: ld      a,(unknown_63b5)] load A with ???
	jbsr		osd_w_videoram                         	| [$0e65: ld      (hl),a] draw element to screen
	addq.w	#1,d7                           	| [$0e66: inc     hl] next screen location
	move.b	d7,d0                           	| [$0e67: ld      a,l] A := L
	and.b	#0x1f,d0                         	| [$0e68: and     $1f] mask bits, now between 0 and #1F.  at zero ?
	jeq	l_0e78                             	| [$0e6a: jp      z,$0e78] yes, skip ahead

	move.b	unknown_63b5,d0                 	| [$0e6d: ld      a,(unknown_63b5)] load A with ???
	cmp.b	#0xf0,d0                         	| [$0e70: cp      $f0] == #F0 ?
	jeq	l_0e78                             	| [$0e72: jp      z,$0e78] yes, skip next 2 steps

	sub.b	#0x10,d0                         	| [$0e75: sub     $10] subtract #10
	jbsr		osd_w_videoram                         	| [$0e77: ld      (hl),a] store

l_0e78:
	move.w	#0x1f,d1                        	| [$0e78: ld      bc,$001f] load BC with offset 31
	add.w	d1,d7                            	| [$0e7b: add     hl,bc] add offset to HL
	move.b	result_63b1,d0                  	| [$0e7c: ld      a,(result_63b1)] load A with ???
	sub.b	#0x08,d0                         	| [$0e7f: sub     $08] subtract 8.  done?
	jcs	l_0ecf                             	| [$0e81: jp      c,$0ecf] yes, skip ahead for next

	move.b	d0,result_63b1                  	| [$0e84: ld      (result_63b1),a] store A into ???
	move.b	unknown_63b2,d0                 	| [$0e87: ld      a,(unknown_63b2)] load A with ???
	                               	| [$0e8a: cp      $00] == 0 ? [why written this way?]
	jeq	l_0e62                             	| [$0e8c: jp      z,$0e62] yes, jump back and draw another [of same?]

	move.b	unknown_63b5,d0                 	| [$0e8f: ld      a,(unknown_63b5)]
	jbsr		osd_w_videoram                         	| [$0e92: ld      (hl),a] draw element to screen
	addq.w	#1,d7                           	| [$0e93: inc     hl] next screen location
	move.b	d7,d0                           	| [$0e94: ld      a,l] A := L
	and.b	#0x1f,d0                         	| [$0e95: and     $1f] mask bits, now between 0 and #1F.  at zero?
	jeq	l_0ea0                             	| [$0e97: jp      z,$0ea0] yes, skip next 3 steps

	move.b	unknown_63b5,d0                 	| [$0e9a: ld      a,(unknown_63b5)] load A with ???
	sub.b	#0x10,d0                         	| [$0e9d: sub     $10] subtract #10
	jbsr		osd_w_videoram                         	| [$0e9f: ld      (hl),a] store to screen.  draws bottom half of a girder

l_0ea0:
	move.w	#0x1f,d1                        	| [$0ea0: ld      bc,$001f] load BC with offset 31
	add.w	d1,d7                            	| [$0ea3: add     hl,bc] add offset for next screen element
	move.b	result_63b1,d0                  	| [$0ea4: ld      a,(result_63b1)] load A with ???
	sub.b	#0x08,d0                         	| [$0ea7: sub     $08] subtract 8.  done?
	jcs	l_0ecf                             	| [$0ea9: jp      c,$0ecf] yes, skip ahead for next

	move.b	d0,result_63b1                  	| [$0eac: ld      (result_63b1),a] store A into ???
	move.b	unknown_63b2,d0                 	| [$0eaf: ld      a,(unknown_63b2)] load A with ???
	btst.b	#7,d0                           	| [$0eb2: bit     7,a] test bit 7.  is it zero?
	jne	l_0ed3                             	| [$0eb4: jp      nz,$0ed3] no, skip ahead

	move.b	unknown_63b5,d0                 	| [$0eb7: ld      a,(unknown_63b5)] load A with ???
	addq.b	#1,d0                           	| [$0eba: inc     a] increase
	move.b	d0,unknown_63b5                 	| [$0ebb: ld      (unknown_63b5),a] store result
	cmp.b	#0xf8,d0                         	| [$0ebe: cp      $f8] == #F8 ?
	jne	l_0ec9                             	| [$0ec0: jp      nz,$0ec9] no, skip next 3 steps

	addq.w	#1,d7                           	| [$0ec3: inc     hl] next screen location
	move.b	#0xf0,d0                        	| [$0ec4: ld      a,$f0] A := #F0
	move.b	d0,unknown_63b5                 	| [$0ec6: ld      (unknown_63b5),a] store into ???

l_0ec9:
	move.b	d7,d0                           	| [$0ec9: ld      a,l] A := L
	and.b	#0x1f,d0                         	| [$0eca: and     $1f] mask bits.  now between 0 and #1F.  at zero?
	jne	l_0e62                             	| [$0ecc: jp      nz,$0e62] no, jump back

l_0ecf:
	addq.w	#1,a1                           	| [$0ecf: inc     de] next table entry
	jra	draw_the_screen_0da7                             	| [$0ed0: jp      $0da7] loop back for more

l_0ed3:
	move.b	unknown_63b5,d0                 	| [$0ed3: ld      a,(unknown_63b5)] load A with ???
	subq.b	#1,d0                           	| [$0ed6: dec     a] decrease
	move.b	d0,unknown_63b5                 	| [$0ed7: ld      (unknown_63b5),a] store result
	cmp.b	#0xf0,d0                         	| [$0eda: cp      $f0] compare to #F0.  is the sign positive?
	jpl	l_0ee5                             	| [$0edc: jp      p,$0ee5] yes, skip next 3 steps [why?  #0EE5 is a jump - it should jump directly instead]

	subq.w	#1,d7                           	| [$0edf: dec     hl]
	move.b	#0xf7,d0                        	| [$0ee0: ld      a,$f7] A := #F7
	move.b	d0,unknown_63b5                 	| [$0ee2: ld      (unknown_63b5),a] store into ???

l_0ee5:
	jra	l_0e62                             	| [$0ee5: jp      $0e62] jump back

* arrive from #0E54

l_0ee8:
	move.b	original_data_item_63b3,d0      	| [$0ee8: ld      a,(original_data_item_63b3)] load A with original data item [why load it again ? A already has #63B3]
	cmp.b	#0x03,d0                         	| [$0eeb: cp      $03] == 3?
	jne	l_0f1b                             	| [$0eed: jp      nz,$0f1b] no, skip ahead

* we are drawing a conveyor

	MOVE_TO_REG	current_screen_address_63ab,d7             	| [$0ef0: ld      hl,(current_screen_address_63ab)] load HL with VRAM screen address to begin drawing
	move.b	#0xb3,d0                        	| [$0ef3: ld      a,$b3] A := #B3 = code graphic for conveyor
	jbsr		osd_w_videoram                         	| [$0ef5: ld      (hl),a] draw on screen
	move.w	#0x20,d1                        	| [$0ef6: ld      bc,$0020] load BC with offset 32
	add.w	d1,d7                            	| [$0ef9: add     hl,bc] add offset to HL
	move.b	result_63b1,d0                  	| [$0efa: ld      a,(result_63b1)] load A with ???
	sub.b	#0x10,d0                         	| [$0efd: sub     $10] subtract #10.  done ?

l_0eff:
	jcs	l_0f14                             	| [$0eff: jp      c,$0f14] yes, skip ahead

	move.b	d0,result_63b1                  	| [$0f02: ld      (result_63b1),a]
	move.b	#0xb1,d0                        	| [$0f05: ld      a,$b1] A := #B1 conveyor belts
	jbsr		osd_w_videoram                         	| [$0f07: ld      (hl),a] store into ???
	                        	| [$0f08: ld      bc,$0020] load BC with offset 32
	                        	| [$0f08: ld      bc,$0020] load BC with offset 32
	add.w	#0x20,d7                            	| [$0f0b: add     hl,bc] add offset to HL: to the right
	move.b	result_63b1,d0                  	| [$0f0c: ld      a,(result_63b1)] load A with ???
	sub.b	#0x08,d0                         	| [$0f0f: sub     $08] subtract 8
	jra	l_0eff                             	| [$0f11: jp      $0eff] loop again

l_0f14:
	move.b	#0xb2,d0                        	| [$0f14: ld      a,$b2] A := #B2
	jbsr		osd_w_videoram                         	| [$0f16: ld      (hl),a] store (onscreen???)
	addq.w	#1,a1                           	| [$0f17: inc     de] next table entry
	jra	draw_the_screen_0da7                             	| [$0f18: jp      $0da7] loop back for more

* arrive from #0EED

l_0f1b:
	move.b	original_data_item_63b3,d0      	| [$0f1b: ld      a,(original_data_item_63b3)] load A with original data item [why load it again ? A already has #63B3]
	cmp.b	#0x07,d0                         	| [$0f1e: cp      $07] <= 7 ?
	jpl	l_0ecf                             	| [$0f20: jp      p,$0ecf] no, skip back and loop for next data item

	cmp.b	#0x04,d0                         	| [$0f23: cp      $04] first data item == 4 ?
	jeq	l_0f4c                             	| [$0f25: jp      z,$0f4c] yes, skip ahead to handle

	cmp.b	#0x05,d0                         	| [$0f28: cp      $05] first data item == 5 ?
	jeq	l_0f51                             	| [$0f2a: jp      z,$0f51] yes, skip ahead to handle

* redraws screen when rivets has been completed

	move.b	#0xfe,d0                        	| [$0f2d: ld      a,$fe] A := #FE

l_0f2f:
	move.b	d0,unknown_63b5                 	| [$0f2f: ld      (unknown_63b5),a] store into ???
	MOVE_TO_REG	current_screen_address_63ab,d7             	| [$0f32: ld      hl,(current_screen_address_63ab)] load HL with ???

l_0f35:
	move.b	unknown_63b5,d0                 	| [$0f35: ld      a,(unknown_63b5)] load A with ???
	jbsr		osd_w_videoram                         	| [$0f38: ld      (hl),a] store into ???
	                        	| [$0f39: ld      bc,$0020] set offset to #20 32
	add.w	#0x20,d7                            	| [$0f3c: add     hl,bc] add offset for next
	                  	| [$0f3d: ld      a,(result_63b1)] load A with ???
	sub.b	#0x08,result_63b1                         	| [$0f40: sub     $08] subtract 8
                  	| [$0f42: ld      (result_63b1),a] store result.  done ?
	jcc	l_0f35                             	| [$0f45: jp      nc,$0f35] no, loop again

	addq.w	#1,a1                           	| [$0f48: inc     de] else increase DE
	jra	draw_the_screen_0da7                             	| [$0f49: jp      $0da7] jump back

l_0f4c:
	move.b	#0xe0,d0                        	| [$0f4c: ld      a,$e0] A := #E0
	jra	l_0f2f                             	| [$0f4e: jp      $0f2f] jump back

l_0f51:
	move.b	#0xb0,d0                        	| [$0f51: ld      a,$b0] A := #B0
	jra	l_0f2f                             	| [$0f53: jp      $0f2f] jump back

* called from #0D5F
* clears memories from #6200 - 6227 and #6280 to 6B00
* [why are #6280 - #6280+40 cleared?  they are set immediately after]
* computes initial timer
* initializes all sprites

l_0f56:
	move.b	#0x27,d1                        	| [$0f56: ld      b,$27] for B = 1 to #27
	lea	mario_array_6200,a0            	| [$0f58: ld      hl,mario_array_6200] load HL with start of address
	clr.b	d0                               	| [$0f5b: xor     a] A := #00

l_0f5c:
	move.b	d0,(a0)+                         	| [$0f5c: ld      (hl),a] clear memory
											| [$0f5d: inc     l] next
	subq.b	#1,d1                           	| [...]
	jne	l_0f5c                             	| [$0f5e: djnz    $0f5c] next B

	move.b	#0x11,d2                        	| [$0f60: ld      c,$11] For C = 1 to 11
	move.b	#0x80,d3                        	| [$0f62: ld      d,$80] load D with 80, used to reset B in inner loop
	lea	left_side_rectractable_ladder_6280,a0	| [$0f64: ld      hl,left_side_rectractable_ladder_6280] start of memory to clear
l_0f67:
	move.b	d3,d1                           	| [$0f67: ld      b,d] For B = 1 to #80

l_0f68:
	move.b	d0,(a0)+                         	| [$0f68: ld      (hl),a] clear (HL)
	                           	| [$0f69: inc     hl] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_0f68                             	| [$0f6a: djnz    $0f68] Next B

	subq.b	#1,d2                           	| [$0f6c: dec     c] Next C
	jne	l_0f67                             	| [$0f6d: jr      nz,$0f67] loop until done

	lea	game_rom+0x3d9c,a0                      	| [$0f6f: ld      hl,$3d9c] source addr. = #3D9C - table data
	lea	left_side_rectractable_ladder_6280,a1	| [$0f72: ld      de,left_side_rectractable_ladder_6280] Destination = #6280
	move.w	#0x40,d1                        	| [$0f75: ld      bc,$0040] counter = #40 Bytes 64
	jbsr	ldir                              	| [$0f78: ldir] copy


* values are copied into #6280 through #6280 + #40
*     3D9C:                                      00 00 23 68
*     3DA0:  01 11 00 00 00 10 DB 68 01 40 00 00 08 01 01 01
*     3DB0:  01 01 01 01 01 01 00 00 00 00 00 00 80 01 C0 FF
*     3DC0:  01 FF FF 34 C3 39 00 67 80 69 1A 01 00 00 00 00
*     3DD0:  00 00 00 00 04 00 10 00 00 00 00 00
*

* set up initial timer
* timer is either 5000, 6000, 7000 or 8000 depending on level

	move.b	level_number_6229,d0       	| [$0f7a: ld      a,(level_number_6229)] load level number
	move.b	d0,d1                           	| [$0f7d: ld      b,a] copy to B
	tst.b	d0                               	| [$0f7e: and     a] clear carry flag
	CLEAR_XC_FLAGS	| clear carry is not enough
	roxl.b	#1,d0                           	| [$0f7f: rla] rotate A left (double =2x)
	                               	| [$0f80: and     a] clear carry flag
	CLEAR_XC_FLAGS	| clear carry is not enough
	roxl.b	#1,d0                           	| [$0f81: rla] rotate A left (double again =4x)
	                               	| [$0f82: and     a] clear carry flag
	CLEAR_XC_FLAGS	| clear carry is not enough
	roxl.b	#1,d0                           	| [$0f83: rla] rotate A left (double again = 8x)
	add.b	d1,d0                            	| [$0f84: add     a,b] add B into A  (add once = 9x)
	add.b	d1,d0                            	| [$0f85: add     a,b] add B  into A  (add again = 10x)
	add.b	#0x28,d0                         	| [$0f86: add     a,$28] add #28 (40 decimal) to A
	jcc		0f
	* integer wraps at level 22 (10*22+40 = 260)
	* to avoid kill screen, saturate it, allowing to play theorically forever
	move.b	#0x50,d0
0:
	cmp.b	#0x51,d0                         	| [$0f88: cp      $51] < #51 ?
	jcs	l_0f8e                             	| [$0f8a: jr      c,$0f8e] yes, skip next step

	move.b	#0x50,d0                        	| [$0f8c: ld      a,$50] otherwise load A with #50 (80 decimal)

l_0f8e:
	lea	initial_clock_value_62b0,a0    	| [$0f8e: ld      hl,initial_clock_value_62b0] load HL with start of timers
	move.b	#0x03,d1                        	| [$0f91: ld      b,$03] For B = 1 to 3

l_0f93:
	move.b	d0,(a0)+                         	| [$0f93: ld      (hl),a] store A into timer memory
	                           	| [$0f94: inc     l] next memory
	subq.b	#1,d1                           	| [...]
	jne	l_0f93                             	| [$0f95: djnz    $0f93] Next B

	add.b	d0,d0                            	| [$0f97: add     a,a] add A with A (double a).  A is now #64, #78, #8C, or #A0
	move.b	d0,d1                           	| [$0f98: ld      b,a] copy to B
	move.b	#0xdc,d0                        	| [$0f99: ld      a,$dc] A := #DC (220 decimal)
	sub.b	d1,d0                            	| [$0f9b: sub     b] subtract B.  answers are #78, #64, #50, or #3C
	cmp.b	#0x28,d0                         	| [$0f9c: cp      $28] is this less than #28 (40 decimal) ?  (will never get this ... ???)
	jcc	l_0fa2                             	| [$0f9e: jr      nc,$0fa2] no, skip next step

	move.b	#0x28,d0                        	| [$0fa0: ld      a,$28] else load a with #28 (40). minimum value (never get this ... ?????)

l_0fa2:
	move.b	d0,(a0)+                         	| [$0fa2: ld      (hl),a] store A into address of HL=#62B3 which controls timers
	                           	| [$0fa3: inc     l] HL := #62B4
	move.b	d0,(a0)                         	| [$0fa4: ld      (hl),a] store A into the timer control
	lea	unknown_6209,a0                	| [$0fa5: ld      hl,unknown_6209] load HL with #6209
	move.b	#0x04,(a0)+                      	| [$0fa8: ld      (hl),$04] store 4 into #6209
	                           	| [$0faa: inc     l] HL := #620A
	move.b	#0x08,(a0)                      	| [$0fab: ld      (hl),$08] store 8 into #620A
	move.b	screen_number_6227,d0           	| [$0fad: ld      a,(screen_number_6227)] load A with screen number
	move.b	d0,d2                           	| [$0fb0: ld      c,a] copy to C, used at #0FCB
	btst.b	#2,d0                           	| [$0fb1: bit     2,a] is this the rivets ?
	jne	l_0fcb                             	| [$0fb3: jr      nz,$0fcb] yes, skip ahead [would be better to jump to #1131, or JR to #0FCC]

* draw 3 black sprites above the top kongs ladder
* effect to erase the 2 girders at the top of kong's ladder

	lea	blank_space_sprite_6a00,a0     	| [$0fb5: ld      hl,blank_space_sprite_6a00] else load HL sprite RAM - used for blank space sprite
	move.b	#0x4f,d0                        	| [$0fb8: ld      a,$4f] A := #4F = X position of this sprite
	move.b	#0x03,d1                        	| [$0fba: ld      b,$03] For B = 1 to 3

l_0fbc:
	move.b	d0,(a0)+                         	| [$0fbc: ld      (hl),a] set the sprite X position
	                           	| [$0fbd: inc     l] next address = sprite type
	move.b	#0x3a,(a0)+                      	| [$0fbe: ld      (hl),$3a] set sprite type as blank square
	                           	| [$0fc0: inc     l] next address = sprite color
	move.b	#0x0f,(a0)+                      	| [$0fc1: ld      (hl),$0f] set color to black
	                           	| [$0fc3: inc     l] next address = sprite Y position
	move.b	#0x18,(a0)+                      	| [$0fc4: ld      (hl),$18] set sprite Y position to #18
	                           	| [$0fc6: inc     l] next memory
	add.b	#0x10,d0                         	| [$0fc7: add     a,$10] A := A + #10 to adjust for next X position
	subq.b	#1,d1                           	| [...]
	jne	l_0fbc                             	| [$0fc9: djnz    $0fbc] Next B

l_0fcb:
	move.b	d2,d0                           	| [$0fcb: ld      a,c] load A with screen number
	jbsr	rst_28                            	| [$0fcc: rst     $28] jump depending on the screen

* jump table data

	.long	0			| unused
    .long	l_0FD7                        | #0FD7 for girders
    .long	l_101F                        | #101F for conveyors
    .long	l_1087                        | #1087 for elevators
    .long	l_1131                        | #1131 for rivets

* arrive here when playing girders
l_0FD7:
	lea	game_rom+0x3ddc,a0                      	| [$0fd7: ld      hl,$3ddc] source - has the information about the barrel pile at #3DDC
	lea	extra_barrels_sprites_69a8,a1  	| [$0fda: ld      de,extra_barrels_sprites_69a8] destination = sprites
	move.w	#0x10,d1                        	| [$0fdd: ld      bc,$0010] counter is #10 16
	jbsr	ldir                              	| [$0fe0: ldir] draws the barrels pile next to kong

	lea	game_rom+0x3dec,a0                      	| [$0fe2: ld      hl,$3dec] set up a copy job from table in #3DEC
	lea	unknown_6407,a1                	| [$0fe5: ld      de,unknown_6407] destination in memory is #6407
	move.b	#0x1c,d2                        	| [$0fe8: ld      c,$1c] #1C is a secondary counter
	move.b	#0x05,d1                        	| [$0fea: ld      b,$05] #05 is a secondary counter
	jbsr	l_122a                            	| [$0fec: call    $122a] copy

	lea	game_rom+0x3df4,a0                      	| [$0fef: ld      hl,$3df4] load HL with table data start for initial fire locations
	jbsr	l_11fa                            	| [$0ff2: call    $11fa] ???

	lea	game_rom+0x3e00,a0                      	| [$0ff5: ld      hl,$3e00] source table at #3E00 = oil can
	lea	unknown_sprite_69fc,a1         	| [$0ff8: ld      de,unknown_sprite_69fc] destination sprite at #69FC
	move.w	#0x04,d1                        	| [$0ffb: ld      bc,$0004] 4 bytes 4
	jbsr	ldir                              	| [$0ffe: ldir] draw to screen

	lea	game_rom+0x3e0c,a0                      	| [$1000: ld      hl,$3e0c] load HL with table data for hammers on girders
	jbsr	draw_hammers_11a6                            	| [$1003: call    $11a6] ???

	lea	game_rom+0x101b,a0                      	| [$1006: ld      hl,$101b] set up copy job from table in #101B
	lea	destination_6707,a1            	| [$1009: ld      de,destination_6707] set destination ?
	move.b	#0x08,d1                        	| [$100c: ld      bc,$081c] set counters ? 2076
	move.b	#0x1c,d2                        	| [$100c: ld      bc,$081c] set counters ? 2076
	jbsr	l_122a                            	| [$100f: call    $122a] copy

	lea	destination_6807,a1            	| [$1012: ld      de,destination_6807] set destination ?
	move.b	#0x02,d1                        	| [$1015: ld      b,$02] set counter to 2
	jbsr	l_122a                            	| [$1017: call    $122a] copy
	rts                                    	| [$101a: ret] return

* data used in sub at #1006

l_101b:
	.byte	0x00
	.byte	0x00
	.byte	0x02
	.byte	0x02

* arrive here when conveyors starts
* draws parts of the screen

l_101F:
	lea	game_rom+0x3dec,a0                      	| [$101f: ld      hl,$3dec] set up a copy job from table in #3DEC
	lea	unknown_6407,a1                	| [$1022: ld      de,unknown_6407] desitnation in memory is #6407
	move.b	#0x05,d1                        	| [$1025: ld      bc,$051c] counters are #05 and #1C 1308
	move.b	#0x1c,d2                        	| [$1025: ld      bc,$051c] counters are #05 and #1C 1308
	jbsr	l_122a                            	| [$1028: call    $122a] copy

	jbsr	l_1186                            	| [$102b: call    $1186]

	lea	game_rom+0x3e18,a0                      	| [$102e: ld      hl,$3e18] set up copy job from table in #3E18
	lea	destination_is_65a7_65a7,a1    	| [$1031: ld      de,destination_is_65a7_65a7] destination is #65A7
	move.b	#0x06,d1                        	| [$1034: ld      bc,$060c] counters are #05 and #0C 1548
	move.b	#0x0c,d2                        	| [$1034: ld      bc,$060c] counters are #05 and #0C 1548
	jbsr	l_122a                            	| [$1037: call    $122a] copy

	lea	start_of_pies_65a0,a2          	| [$103a: ld      ix,start_of_pies_65a0] load IX with start of pies
	lea	start_of_pie_sprites_69b8,a0   	| [$103e: ld      hl,start_of_pie_sprites_69b8] load HL with sprites for pies
	move.w	#0x0010,d3                      	| [$1041: ld      de,$0010] DE := #10 16
	move.b	#NB_PIES,d1                        	| [$1044: ld      b,$06] B := 6
	jbsr	l_11d3                            	| [$1046: call    $11d3]

	lea	game_rom+0x3dfa,a0                      	| [$1049: ld      hl,$3dfa] load HL with start of table data
	jbsr	l_11fa                            	| [$104c: call    $11fa] set fireball sprite

	lea	game_rom+0x3e04,a0                      	| [$104f: ld      hl,$3e04] set up copy job from table in #3E04 = oil can sprite
	lea	unknown_sprite_69fc,a1         	| [$1052: ld      de,unknown_sprite_69fc] destination is #69FC = sprite
	move.w	#0x04,d1                        	| [$1055: ld      bc,$0004] four bytes to copy 4
	jbsr	ldir                              	| [$1058: ldir] draw oil can

	lea	game_rom+0x3e1c,a0                      	| [$105a: ld      hl,$3e1c] load HL with start of table data
	lea	sprite_start_for_moving_ladders_6944,a1	| [$105d: ld      de,sprite_start_for_moving_ladders_6944] load DE with sprite start for moving ladders
	move.w	#0x08,d1                        	| [$1060: ld      bc,$0008] set byte counter to 8
	jbsr	ldir                              	| [$1063: ldir] draw moving ladders

	lea	game_rom+0x3e24,a0                      	| [$1065: ld      hl,$3e24] set source table data
	lea	start_of_pulley_sprites_69e4,a1	| [$1068: ld      de,start_of_pulley_sprites_69e4] set destination RAM sprites
	move.w	#0x18,d1                        	| [$106b: ld      bc,$0018] set counter 24
	jbsr	ldir                              	| [$106e: ldir] draw pulleys

	lea	game_rom+0x3e10,a0                      	| [$1070: ld      hl,$3e10] load HL with table data for hammers on conveyors
	jbsr	draw_hammers_11a6                            	| [$1073: call    $11a6] ???

	lea	game_rom+0x3e3c,a0                      	| [$1076: ld      hl,$3e3c] load HL with table data for bonus items on conveyors
	lea	start_of_bonus_items_6a0c,a1   	| [$1079: ld      de,start_of_bonus_items_6a0c] load DE with sprite destination
	move.w	#0x0c,d1                        	| [$107c: ld      bc,$000c] 3 items x 4 bytes = 12 bytes (#0C) 12
	jbsr	ldir                              	| [$107f: ldir] draw bonus item sprites

	move.b	#0x01,d0                        	| [$1081: ld      a,$01] A := 1
	move.b	d0,fire_release_62b9            	| [$1083: ld      (fire_release_62b9),a] store into fire release
	rts                                    	| [$1086: ret] return

* arrive here when elevators starts

l_1087:
	lea	game_rom+0x3dec,a0                      	| [$1087: ld      hl,$3dec] load HL with start of table data
	lea	unknown_6407,a1                	| [$108a: ld      de,unknown_6407] set destination ???
	move.b	#0x05,d1                        	| [$108d: ld      bc,$051c] set counters 1308
	move.b	#0x1c,d2                        	| [$108d: ld      bc,$051c] set counters 1308
	jbsr	l_122a                            	| [$1090: call    $122a] copy ???

	jbsr	l_1186                            	| [$1093: call    $1186]

	lea	elevator_array_start_6600,a0   	| [$1096: ld      hl,elevator_array_start_6600] load HL with start of elevator sprites ???
	move.w	#0x0010,d3                      	| [$1099: ld      de,$0010] load DE with offset to add 16
	move.b	#0x01,d0                        	| [$109c: ld      a,$01] A := 1
	move.b	#0x06,d1                        	| [$109e: ld      b,$06] for B = 1 to 6

l_10a0:
	move.b	d0,(a0)                         	| [$10a0: ld      (hl),a] write value into memory
	add.w	d3,a0                            	| [$10a1: add     hl,de] add offset for next
	subq.b	#1,d1                           	| [...]
	jne	l_10a0                             	| [$10a2: djnz    $10a0] next B

	move.b	#0x02,d2                        	| [$10a4: ld      c,$02] For C = 1 to 2
	move.b	#0x08,d0                        	| [$10a6: ld      a,$08] A := 8
l_10a8:
	move.b	#0x03,d1                        	| [$10a8: ld      b,$03] for B = 1 to 3
	lea	unknown_660d,a0                	| [$10aa: ld      hl,unknown_660d] load HL with ???

l_10ad:
	move.b	d0,(a0)                         	| [$10ad: ld      (hl),a] write value into memory
	add.w	d3,a0                            	| [$10ae: add     hl,de] add offset for next
	subq.b	#1,d1                           	| [...]
	jne	l_10ad                             	| [$10af: djnz    $10ad] next B

	move.b	#0x08,d0                        	| [$10b1: ld      a,$08] A := 8 [why?  A is already 8]
	subq.b	#1,d2                           	| [$10b3: dec     c] next C
	jne	l_10a8                             	| [$10b4: jp      nz,$10a8] loop until done

* used to draw elevator platforms???

* #6600 - 665F  = the 6 elevator values.  6610, 6620, 6630, 6640 ,6650 are starting values
*       + 3 is the X position, + 5 is the Y position

	lea	game_rom+0x3e64,a0                      	| [$10b7: ld      hl,$3e64] start of table data
	lea	destination_sprite_x_positions_6603,a1	| [$10ba: ld      de,destination_sprite_x_positions_6603] Destination sprite ? X positions ?
	move.b	#0x06,d1                        	| [$10bd: ld      bc,$060e] Counter = #06, offset = #0E 1550
	move.b	#0x0e,d2                        	| [$10bd: ld      bc,$060e] Counter = #06, offset = #0E 1550
	jbsr	l_11ec                            	| [$10c0: call    $11ec] set items from data table

	lea	game_rom+0x3e60,a0                      	| [$10c3: ld      hl,$3e60] start of table data
	lea	destination_sprite_6607,a1   	| [$10c6: ld      de,destination_sprite_6607] Destination sprite ?
	move.b	#0x06,d1                        	| [$10c9: ld      bc,$060c] B = 6 is loop variable, C = offset ? 1548
	move.b	#0x0c,d2                        	| [$10c9: ld      bc,$060c] B = 6 is loop variable, C = offset ? 1548
	jbsr	l_122a                            	| [$10cc: call    $122a]

	lea	elevator_array_start_6600,a2   	| [$10cf: ld      ix,elevator_array_start_6600] load IX with ???
	lea	elevator_sprites_6958,a0       	| [$10d3: ld      hl,elevator_sprites_6958] load HL with elevator sprites start
	move.b	#0x06,d1                        	| [$10d6: ld      b,$06] B := 6
	move.w	#0x0010,d3                      	| [$10d8: ld      de,$0010] load offset with #10 16
	jbsr	l_11d3                            	| [$10db: call    $11d3] ???

	lea	game_rom+0x3e48,a0                      	| [$10de: ld      hl,$3e48] source is data table for bonus items on elevators
	lea	start_of_bonus_items_6a0c,a1   	| [$10e1: ld      de,start_of_bonus_items_6a0c] destination is RAM area for bonus items
	move.w	#0x0c,d1                        	| [$10e4: ld      bc,$000c] counter set for #0C bytes 12
	jbsr	ldir                              	| [$10e7: ldir] copy

* set up the 2 fireballs

	lea	start_of_fires_table_6400,a2   	| [$10e9: ld      ix,start_of_fires_table_6400] load IX with start of fire #1
	move.b	#0x01,(a2)                 	| [$10ed: ld      (ix+$00),$01] set fire active
	move.b	#0x58,(0x03,a2)                 	| [$10f1: ld      (ix+$03),$58] set fire X position
	move.b	#0x58,(0x0e,a2)                 	| [$10f5: ld      (ix+$0e),$58] set fire X position #2
	move.b	#0x80,(0x05,a2)                 	| [$10f9: ld      (ix+$05),$80] set fire Y position
	move.b	#0x80,(0x0f,a2)                 	| [$10fd: ld      (ix+$0f),$80] set fire Y position #2

* set up 2nd fireball

	move.b	#0x01,(0x20,a2)                 	| [$1101: ld      (ix+$20),$01] set fire active
	move.b	#0xeb,(0x23,a2)                 	| [$1105: ld      (ix+$23),$eb] set fire X position
	move.b	#0xeb,(0x2e,a2)                 	| [$1109: ld      (ix+$2e),$eb] set fire X position
	move.b	#0x60,(0x25,a2)                 	| [$110d: ld      (ix+$25),$60] set fire Y position
	move.b	#0x60,(0x2f,a2)                 	| [$1111: ld      (ix+$2f),$60] set fire Y position

	lea	sprites_used_at_top_and_bottom_of_elevators_6970,a1	| [$1115: ld      de,sprites_used_at_top_and_bottom_of_elevators_6970] destination #6970 (sprites used at top and bottom of elevators)
	lea	game_rom+0x1121,a0                      	| [$1118: ld      hl,$1121] source data at table below
	move.w	#0x10,d1                        	| [$111b: ld      bc,$0010] byte counter at #10 16
	jbsr	ldir                              	| [$111e: ldir] copy
	rts                                    	| [$1120: ret] return

* data used above for top and bottom of elevator shafts

l_1121:
	.byte	0x37,0x45,0x0F,0x60                       | X = #37, color = #45, sprite = #F, Y = #60
	.byte	0x37,0x45,0x8F,0xF7
	.byte	0x77,0x45,0x0F,0x60
	.byte	0x77,0x45,0x8F,0xF7

* arrive here when rivets starts from #0FCC

l_1131:
	lea	game_rom+0x3df0,a0                      	| [$1131: ld      hl,$3df0] load HL with start of table data
	lea	unknown_6407,a1                	| [$1134: ld      de,unknown_6407] load DE with destination ?
	move.b	#0x05,d1                        	| [$1137: ld      bc,$051c] set counters 1308
	move.b	#0x1c,d2                        	| [$1137: ld      bc,$051c] set counters 1308

	jbsr	l_122a                            	| [$113a: call    $122a] copy fire location data to screen?

	lea	game_rom+0x3e14,a0                      	| [$113d: ld      hl,$3e14] load HL with start of table data for hammer locations
	jbsr	draw_hammers_11a6                            	| [$1140: call    $11a6] draw the hammers

	lea	game_rom+0x3e54,a0                      	| [$1143: ld      hl,$3e54] load HL with start of bonus items for rivets
	lea	start_of_bonus_items_6a0c,a1   	| [$1146: ld      de,start_of_bonus_items_6a0c] set destination sprite address
	move.w	#0x0c,d1                        	| [$1149: ld      bc,$000c] set counter to #C bytes to copy 12
	jbsr	ldir                              	| [$114c: ldir] draw purse, umbrella, hat to screen
 
	lea	game_rom+0x1182,a0                      	| [$114e: ld      hl,$1182] load HL with start of data table
	lea	destination_64a3,a1          	| [$1151: ld      de,destination_64a3] load DE with destination ?
	move.b	#0x02,d1                        	| [$1154: ld      bc,$021e] set counters 542
	move.b	#0x1e,d2                        	| [$1154: ld      bc,$021e] set counters 542
	jbsr	l_11ec                            	| [$1157: call    $11ec] copy

* draws black squares next to kong???

	lea	game_rom+0x117e,a0                      	| [$115a: ld      hl,$117e] load HL with start of data table
	lea	set_destination_sprites_64a7,a1	| [$115d: ld      de,set_destination_sprites_64a7] set destination sprites
	move.b	#0x02,d1                        	| [$1160: ld      bc,$021c] set counters B := 2, C := #1C 540
	move.b	#0x1c,d2                        	| [$1160: ld      bc,$021c] set counters B := 2, C := #1C 540
	jbsr	l_122a                            	| [$1163: call    $122a] copy

	lea	address_of_black_square_sprite_start_64a0,a2	| [$1166: ld      ix,address_of_black_square_sprite_start_64a0] load IX with address of black square sprite start
	move.b	#0x01,(a2)                 	| [$116a: ld      (ix+$00),$01] store 1 into #64A0 = turn on first sprite
	move.b	#0x01,(0x20,a2)                 	| [$116e: ld      (ix+$20),$01] store 1 into #64C0 = turn on second sprite

	lea	start_of_hammers_6950,a0       	| [$1172: ld      hl,start_of_hammers_6950] load HL with ???
	move.b	#0x02,d1                        	| [$1175: ld      b,$02] set counter to 2
	move.w	#0x0020,d3                      	| [$1177: ld      de,$0020] set offset to #20 32
	jbsr	l_11d3                            	| [$117a: call    $11d3] draw items ???

	rts                                    	| [$117d: ret] return

* data used above for black space next to kong

l_117e:
	.byte	0x3F,0x0C,0x08,0x08                       | sprite code #3F (invisible square), color = #0C (black), size = 8x8 ???
	.byte	0x73,0x50,0x8D,0x50                       | 1st is at #73,#50 and the 2nd is at #8D,#50

* called from #102B and #1093

l_1186:
	lea	game_rom+0x11a2,a0                      	| [$1186: ld      hl,$11a2] load HL with start of data table
	lea	destination_6507,a1            	| [$1189: ld      de,destination_6507] load DE with destination
	move.b	#0x0a,d1                        	| [$118c: ld      bc,$0a0c] set counters 2572
	move.b	#0x0c,d2                        	| [$118c: ld      bc,$0a0c] set counters 2572
	jbsr	l_122a                            	| [$118f: call    $122a] copy

	lea	start_of_bouncer_memory_area_6500,a2	| [$1192: ld      ix,start_of_bouncer_memory_area_6500] load IX with ???
	lea	start_of_bouncers_or_barrels_sprites_6980,a0	| [$1196: ld      hl,start_of_bouncers_or_barrels_sprites_6980] load HL with sprite start (???)
	move.b	#NB_BARRELS,d1                        	| [$1199: ld      b,$0a] B := #A
	move.w	#0x0010,d3                      	| [$119b: ld      de,$0010] load DE with offset 16
	jbsr	l_11d3                            	| [$119e: call    $11d3] copy

	rts                                    	| [$11a1: ret] return

* data table used above

l_11a2:
	.byte		0x3B,0x00,0x02,0x02

* called from 3 locations with HL preloaded with address of locations to draw to

draw_hammers_11a6:
	lea	sprite_destination_address_unknown_6683,a1	| [$11a6: ld      de,sprite_destination_address_unknown_6683] load DE with sprite destination address ???
	move.b	#0x02,d1                        	| [$11a9: ld      bc,$020e] B := 2 for the 2 hammers.  C := #E for ??? 526
	move.b	#0x0e,d2                        	| [$11a9: ld      bc,$020e] B := 2 for the 2 hammers.  C := #E for ??? 526
	jbsr	l_11ec                            	| [$11ac: call    $11ec]

	lea	game_rom+0x3e08,a0                      	| [$11af: ld      hl,$3e08] set source
	lea	unknown_6687,a1                	| [$11b2: ld      de,unknown_6687] set destination
	move.b	#0x02,d1                        	| [$11b5: ld      bc,$020c] set counters 524
	move.b	#0x0c,d2                        	| [$11b5: ld      bc,$020c] set counters 524
	jbsr	l_122a                            	| [$11b8: call    $122a] copy table data from #3E08 into #6687 with counters #02 and #0C

	lea	software_address_of_hammer_sprite_6680,a2	| [$11bb: ld      ix,software_address_of_hammer_sprite_6680] load IX with start of hammer array
	move.b	#0x01,(a2)                 	| [$11bf: ld      (ix+$00),$01] set hammer 1 active
	move.b	#0x01,(0x10,a2)                 	| [$11c3: ld      (ix+$10),$01] set hammer 2 active
	lea	hardware_address_of_hammer_sprite_6a18,a0	| [$11c7: ld      hl,hardware_address_of_hammer_sprite_6a18] set destination for hammer sprites ?
	move.b	#0x02,d1                        	| [$11ca: ld      b,$02] set counter to 2
	move.w	#0x0010,d3                      	| [$11cc: ld      de,$0010] set offset to #10 16
	jbsr	l_11d3                            	| [$11cf: call    $11d3] draw hammers

	rts                                    	| [$11d2: ret] return

* subroutine uses HL, DE, IX
* B used for loop counter (how many times to loop before returning)
* DE used as an offset for the next set of items to copy
* used to draw hammers initially on each level that has them ?
*

l_11d3:
	move.b	(0x03,a2),d0                    	| [$11d3: ld      a,(ix+$03)] Load A with item's X position
	move.b	d0,(a0)+                         	| [$11d6: ld      (hl),a] store into HL = sprite X position
	                           	| [$11d7: inc     l] next HL
	move.b	(0x07,a2),d0                    	| [$11d8: ld      a,(ix+$07)] load A with item's sprite value
	move.b	d0,(a0)+                         	| [$11db: ld      (hl),a] store into sprite value
	                           	| [$11dc: inc     l] next HL
	move.b	(0x08,a2),d0                    	| [$11dd: ld      a,(ix+$08)] load A with item color
	move.b	d0,(a0)+                         	| [$11e0: ld      (hl),a] store into sprite color
	                           	| [$11e1: inc     l] next HL
	move.b	(0x05,a2),d0                    	| [$11e2: ld      a,(ix+$05)] load A with Y position
	move.b	d0,(a0)+                         	| [$11e5: ld      (hl),a] store into sprite Y position
	                           	| [$11e6: inc     l] next HL
	add.w	d3,a2                            	| [$11e7: add     ix,de] add offset into IX for next set of data
	subq.b	#1,d1                           	| [...]
	jne	l_11d3                             	| [$11e9: djnz    $11d3] loop until B == 0

	rts                                    	| [$11eb: ret] return

* draw umbrella, etc to screen on rivets level?
* also used on elevators, called from #10C0

l_11ec:
	and.w	#0xFF,d2
0:
	move.b	(a0)+,d0                         	| [$11ec: ld      a,(hl)] load A with first table data
	move.b	d0,(a1)                         	| [$11ed: ld      (de),a] store into (DE) = sprite ?
	                           	| [$11ee: inc     hl] next table data
	addq.w	#2,a1                           	| [$11ef: inc     e] * 2
	move.b	(a0)+,d0                         	| [$11f1: ld      a,(hl)] load next data
	move.b	d0,(a1)                         	| [$11f2: ld      (de),a] store                           	| [$11f3: inc     hl] next data
	                           	| [$11f4: ld      a,e] load A with E
	add.w	d2,a1                            	| [$11f5: add     a,c] add C (offset for next sprite) |  EG #0E
	                           	| [$11f6: ld      e,a] store into E
	subq.b	#1,d1                           	| [...]
	jne	0b                             	| [$11f7: djnz    $11ec] loop until done

	rts                                    	| [$11f9: ret] return

*
* called from #104C for conveyors
* called from #0FF2 for girders
* draw stuff in conveyors and girders
* HL is preloaded with #3DFA for conveyors and #3DF4 for girders = table data for intial fire location
* 3DF4:  27 70 01 E0 00 00      | initial data for fires on girders ?
* 3DFA:  7F 40 01 78 02 00      | initial data for conveyors to release a fire ?
*

l_11fa:
	lea	oil_can_address_66a0,a2        	| [$11fa: ld      ix,oil_can_address_66a0] load IX with sprite memory array for fire above the barrel
	lea	hardware_sprite_memory_for_same_fire_6a28,a1	| [$11fe: ld      de,hardware_sprite_memory_for_same_fire_6a28] load DE with hardware sprite memory for same fire
	move.b	#0x01,(a2)                 	| [$1201: ld      (ix+$00),$01] enable the sprite
	move.b	(a0)+,d0                         	| [$1205: ld      a,(hl)] load A with table data
	move.b	d0,(0x03,a2)                    	| [$1206: ld      (ix+$03),a] store into sprite X position
	move.b	d0,(a1)+                         	| [$1209: ld      (de),a] store into sprite X position
	                           	| [$120a: inc     e] next DE
	                           	| [$120b: inc     hl] next HL
	move.b	(a0)+,d0                         	| [$120c: ld      a,(hl)] load A with table data
	move.b	d0,(0x07,a2)                    	| [$120d: ld      (ix+$07),a] store into sprite graphic
	move.b	d0,(a1)+                         	| [$1210: ld      (de),a] store into sprite graphic
	                           	| [$1211: inc     e] next DE
	                           	| [$1212: inc     hl] next HL
	move.b	(a0)+,d0                         	| [$1213: ld      a,(hl)] load A with table data
	move.b	d0,(0x08,a2)                    	| [$1214: ld      (ix+$08),a] store into sprite color
	move.b	d0,(a1)+                         	| [$1217: ld      (de),a] store into sprite color
	                           	| [$1218: inc     e] next DE
	                           	| [$1219: inc     hl] next HL
	move.b	(a0)+,d0                         	| [$121a: ld      a,(hl)] load A with table data
	move.b	d0,(0x05,a2)                    	| [$121b: ld      (ix+$05),a] store into sprite Y position
	move.b	d0,(a1)                         	| [$121e: ld      (de),a] store into sprite Y position
	                           	| [$121f: inc     hl] next HL
	move.b	(a0)+,d0                         	| [$1220: ld      a,(hl)] load A with table data
	move.b	d0,(0x09,a2)                    	| [$1221: ld      (ix+$09),a] store into size (width?) ???
	                           	| [$1224: inc     hl] next HL
	move.b	(a0),d0                         	| [$1225: ld      a,(hl)] load A with table data
	move.b	d0,(0x0a,a2)                    	| [$1226: ld      (ix+$0a),a] store into size? (height?) ??
	rts                                    	| [$1229: ret] return


* Subroutine from #10CC
* Copies Data from Table in HL into the Destination at DE in chunks of 4
* B is used for the second loop variable
* C is used to specify the difference between the tables, assumed to be 4 or 5 or 0 ?
* used for example to place the hammers ???

l_122a:

	move.l	a0,-(sp)                        	| [$122a: push    hl] Save HL
	movem.w	d1/d2,-(sp)                    	| [$122b: push    bc] Save BC
	move.b	#0x04,d1                        	| [$122c: ld      b,$04] For B = 1 to 4

l_122e:
	move.b	(a0)+,(a1)+                         	| [$122e: ld      a,(hl)] load A with the Contents of HL table data
										| [$122f: ld      (de),a] store data into address DE
	                           	| [$1230: inc     hl] next table data
	                           	| [$1231: inc     e] next destination
	subq.b	#1,d1                           	| [...]
	jne	l_122e                             	| [$1232: djnz    $122e] Next B


	movem.w	(sp)+,d1/d2                    	| [$1234: pop     bc] Restore BC - For B = 1 to Initial B value
	move.l	(sp)+,a0                        	| [$1235: pop     hl] Restore HL
	and.w	#0xFF,d2
											| [$1236: ld      a,e] A := E
	add.w	d2,a1                            	| [$1237: add     a,c] add C
											| [$1238: ld      e,a] store result into E
	subq.b	#1,d1                           	| [...]
	jne	l_122a                             	| [$1239: djnz    $122a] Loop again if not zero

	rts                                    	| [$123b: ret] Return

* set initial mario sprite position and draw remaining lives and level

l_123c:
	jbsr	rst_18                            	| [$123c: rst     $18] count down WaitTimerMSB and only continue when 0
	move.b	screen_number_6227,d0           	| [$123d: ld      a,(screen_number_6227)] load a with screen number
	move.b	#0xe0,d1                        	| [$1242: ld      bc,$e016] B := #E0, C := #16.  used for X,Y coordinates 57366
	move.b	#0x16,d2                        	| [$1242: ld      bc,$e016] B := #E0, C := #16.  used for X,Y coordinates 57366
	cmp.b	#0x03,d0                         	| [$1240: cp      $03] is this the elevators?
	jeq	l_124b                             	| [$1245: jp      z,$124b] if elevators skip next step

	move.b	#0xf0,d1                        	| [$1248: ld      bc,$f03f] else load alternate coordinates for elevators 61503
	move.b	#0x3f,d2                        	| [$1248: ld      bc,$f03f] else load alternate coordinates for elevators 61503

l_124b:
	lea	mario_array_6200,a2            	| [$124b: ld      ix,mario_array_6200] set IX to mario sprite array
	lea	mario_sprite_x_position_694c,a0	| [$124f: ld      hl,mario_sprite_x_position_694c] load HL with address for mario sprite X value
	move.b	#0x01,(a2)                 	| [$1252: ld      (ix+$00),$01] turn on sprite
	move.b	d2,(0x03,a2)                    	| [$1256: ld      (ix+$03),c] store X position
	move.b	d2,(a0)+                         	| [$1259: ld      (hl),c] store X position
	                           	| [$125a: inc     l] next
	move.b	#0x80,(0x07,a2)                 	| [$125b: ld      (ix+$07),$80] store sprite graphic
	move.b	#0x80,(a0)+                      	| [$125f: ld      (hl),$80] store sprite graphic
												| [$1261: inc     l] next
	move.b	#0x02,(0x08,a2)                 	| [$1262: ld      (ix+$08),$02] store sprite color
	move.b	#0x02,(a0)+                      	| [$1266: ld      (hl),$02] store sprite color
												| [$1268: inc     l] next
	move.b	d1,(0x05,a2)                    	| [$1269: ld      (ix+$05),b] store Y position
	move.b	d1,(a0)                         	| [$126c: ld      (hl),b] store Y position
	move.b	#0x01,(0x0f,a2)                 	| [$126d: ld      (ix+$0f),$01] turn this on (???)
	lea	gamemode2_600a,a0              	| [$1271: ld      hl,gamemode2_600a] load HL with game mode2 address
	addq.b	#1,(a0)                         	| [$1274: inc     (hl)] increase game mode2 = start game
	move.w  #0x0601,d3                      	| [$1275: ld      de,$0601] set task #6, parameter 1 to draw lives-1 and level
	jbsr	insert_task_309f                            	| [$1278: call    $309f] insert task
	rts                                    	| [$127b: ret] return

* jump here from #0701 when GameMode2 == #D
* mario died ?
mario_died_127c:
	jbsr	check_for_bonus_items_1dbd                            	| [$127c: call    $1dbd] check for bonus items and jumping scores, rivets
	move.b	death_indicator_639d,d0         	| [$127f: ld      a,(death_indicator_639d)] load A with this normally 0.  1 while mario dying, 2 when dead
	jbsr	rst_28                            	| [$1282: rst     $28] jump based on A

	.long	l_128b	| #128B         | 0 normal
	.long	mario_dying_12ac	| #12AC         | 1 mario dying
	.long	mario_dead_12de	| #12DE         | 2 mario dead
	.long	0		| unused ?

l_128b:
	jbsr	rst_18                            	| [$128b: rst     $18] count down WaitTimerMSB and only continue when 0
	lea	mario_sprite_value_694d,a0     	| [$128c: ld      hl,mario_sprite_value_694d] load HL with mario sprite value
	CLEAR_XC_FLAGS
	move.b	#0xf0,d0                        	| [$128f: ld      a,$f0] A := #F0
	move.b	(a0),d7
	roxl.b	#1,d7                         	| [$1291: rl      (hl)] rotate left (HL)
    *move.b	d7,(a0)  | result is not important
	roxr.b	#1,d0                           	| [$1293: rra] rotate right that carry bit into A
	move.b	d0,(a0)                         	| [$1294: ld      (hl),a] store result into mario sprite
	lea	death_indicator_639d,a0        	| [$1295: ld      hl,death_indicator_639d] load HL with mario death indicator
	addq.b	#1,(a0)                         	| [$1298: inc     (hl)] increase.  mario is now dying
	move.b	#0x0d,d0                        	| [$1299: ld      a,$0d] A := #D (13 decimal)
	move.b	d0,load_counter_639e            	| [$129b: ld      (load_counter_639e),a] store into counter for number of times to rotate mario (?)
	move.b	#0x08,d0                        	| [$129e: ld      a,$08] load A with 8 frames of delay
	move.b	d0,waittimermsb_6009            	| [$12a0: ld      (waittimermsb_6009),a] store into timer for sound delay
	jbsr	l_30bd                            	| [$12a3: call    $30bd] clear sprites ?
	                        	| [$12a6: ld      a,$03] load A with duration of sound
	move.w	#DEAD_TUNE_SND,d0
	jbsr	osd_sound_start
	        	| [$12a8: ld      (play_death_sound_6088),a] play death sound
	rts                                    	| [$12ab: ret] return

* arrive here when mario dies
* animates mario

mario_dying_12ac:
	jbsr	rst_18                            	| [$12ac: rst     $18] count down WaitTimerMSB and only continue when 0
	move.b	#0x08,d0                        	| [$12ad: ld      a,$08] load A with 8 frames of delay
	move.b	d0,waittimermsb_6009            	| [$12af: ld      (waittimermsb_6009),a] store into timer for sound delays
	lea	load_counter_639e,a0           	| [$12b2: ld      hl,load_counter_639e] load counter
	subq.b	#1,(a0)                         	| [$12b5: dec     (hl)] decrease.  are we done ?
	jeq	l_12cb                             	| [$12b6: jp      z,$12cb] yes, skip ahead

	CLEAR_XC_FLAGS
	lea	mario_sprite_value_694d,a0     	| [$12b9: ld      hl,mario_sprite_value_694d] load HL with mario sprite value
	move.b	(a0),d0                         	| [$12bc: ld      a,(hl)] get the value
	roxr.b	#1,d0                           	| [$12bd: rra] roll right = div 2
	move.b	#0x02,d0                        	| [$12be: ld      a,$02] load A with 2
	roxr.b	#1,d0                           	| [$12c0: rra] roll right , A now has 1
	move.b	d0,d1                           	| [$12c1: ld      b,a] copy to B
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$12c2: xor     (hl)] toggle HL rightmost bit
	move.b	d0,(a0)+                         	| [$12c3: ld      (hl),a] save new sprite value
												| [$12c4: inc     l] next HL
	move.b	d1,d0                           	| [$12c5: ld      a,b] load A with B
	and.b	#0x80,d0                         	| [$12c6: and     $80] apply mask
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$12c8: xor     (hl)] toggle HL
	move.b	d0,(a0)                         	| [$12c9: ld      (hl),a] save new value
	rts                                    	| [$12ca: ret] return

* mario done rotating after death

l_12cb:
	CLEAR_XC_FLAGS
	lea	mario_sprite_value_694d,a0     	| [$12cb: ld      hl,mario_sprite_value_694d] load HL with mario sprite value
	move.b	#0xf4,d0                        	| [$12ce: ld      a,$f4] load A with #F4
	move.b	(a0),d7
	roxl.b	#1,d7                         	| [$12d0: rl      (hl)] rotate left HL (goes from F8 to F0)
	* we don't care about result being updated
	roxr.b	#1,d0                           	| [$12d2: rra] roll right A.  A becomes FA
	move.b	d0,(a0)                         	| [$12d3: ld      (hl),a] store into sprite value (mario dead)
	lea	death_indicator_639d,a0        	| [$12d4: ld      hl,death_indicator_639d] load HL with death indicator
	addq.b	#1,(a0)                         	| [$12d7: inc     (hl)] increase.  mario now dead
	move.b	#0x80,d0                        	| [$12d8: ld      a,$80] load A with delay of 80
	move.b	d0,waittimermsb_6009            	| [$12da: ld      (waittimermsb_6009),a] store into sound delay counter
	rts                                    	| [$12dd: ret] return

* mario is completely dead

mario_dead_12de:
	jbsr	rst_18                            	| [$12de: rst     $18] count down WaitTimerMSB and only continue when 0
	jbsr	l_30db                            	| [$12df: call    $30db] clear mario and elevator sprites from screen
	lea	gamemode2_600a,a0              	| [$12e2: ld      hl,gamemode2_600a] set HL to game mode2
	move.b	playerturnb_600e,d0             	| [$12e5: ld      a,(playerturnb_600e)] load A with current player
	                               	| [$12e8: and     a] is this player 1 ?
	jeq	l_12ed                             	| [$12e9: jp      z,$12ed] yes, skip next step

	addq.b	#1,(a0)                         	| [$12ec: inc     (hl)] increase game mode

l_12ed:
	addq.b	#1,(a0)                         	| [$12ed: inc     (hl)] increase game mode
												| [$12ee: dec     hl] load HL with WaitTimerMSB
	move.b	#0x01,-(a0)                      	| [$12ef: ld      (hl),$01] store 1 into timer
	rts                                    	| [$12f1: ret] return

* jump here from #0701
* player 1 died
* clear sounds, decrease life, check for and handle game over
l_12f2:
	jbsr	clear_all_sounds_011c                            	| [$12f2: call    $011c] clear all sounds
	clr.b	d0                               	| [$12f5: xor     a] A := 0
	move.b	d0,game_start_flag_622c         	| [$12f6: ld      (game_start_flag_622c),a] store into game start flag
	lea	number_of_lives_remaining_6228,a0	| [$12f9: ld      hl,number_of_lives_remaining_6228] load HL with address for number of lives remaining
	tst.b	infinite_lives_flag
	bne.b	0f
	subq.b	#1,(a0)                         	| [$12fc: dec     (hl)] one less life
0:
	move.b	(a0),d0                         	| [$12fd: ld      a,(hl)] load A with number of lives left
	lea	p1numlives_6040,a1             	| [$12fe: ld      de,p1numlives_6040] set destination address
	move.w	#0x08,d1                        	| [$1301: ld      bc,$0008] set counter 8
	jbsr	ldir                              	| [$1304: ldir] copy (#6228) to (#6230) into (P1NumLives) to (P2NumLives).  copies data from player area to storage area for player 1
	tst.b	d0                               	| [$1306: and     a] number of lives == 0 ?
	jne	l_1334                             	| [$1307: jp      nz,$1334] no, skip ahead

* game over for this player [?]

	move.b	#0x01,d0                        	| [$130a: ld      a,$01] A := 1
	lea	player_1_score_address_60b2,a0 	| [$130c: ld      hl,player_1_score_address_60b2] load HL with player 1 score address
	jbsr	compute_highscore_insertion_position_13ca                            	| [$130f: call    $13ca] check for high score entry ???
	move.w	#0x76d4,d7                      	| [$1312: ld      hl,$76d4] load HL with screen VRAM address ???
	move.b	twoplayergame_600f,d0           	| [$1315: ld      a,(twoplayergame_600f)] load A with number of players
	                               	| [$1318: and     a] 1 player game?
	jeq	l_1322                             	| [$1319: jr      z,$1322] yes, skip next 3 steps

	move.w  #0x0302,d3                      	| [$131b: ld      de,$0302] load task data for text #2 "PLAYER <I>"
	jbsr	insert_task_309f                            	| [$131e: call    $309f] insert task to draw text
	subq.w	#1,d7                           	| [$1321: dec     hl] HL := #76D3

l_1322:
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$1322: call    $1826] clear an area of the screen
	move.w  #0x0300,d3                      	| [$1325: ld      de,$0300] load task data for text #0 "GAME OVER"
	jbsr	insert_task_309f                            	| [$1328: call    $309f] insert task to draw text
	lea	waittimermsb_6009,a0           	| [$132b: ld      hl,waittimermsb_6009] load HL with timer
	move.b	#0xc0,(a0)+                      	| [$132e: ld      (hl),$c0] set timer to #C0
	                           	| [$1330: inc     hl] HL := GameMode2
	move.b	#0x10,(a0)                      	| [$1331: ld      (hl),$10] set game mode2 to #10
	rts                                    	| [$1333: ret] return

l_1334:
	move.b	#0x08,d2                        	| [$1334: ld      c,$08] C := 8
	move.b	twoplayergame_600f,d0           	| [$1336: ld      a,(twoplayergame_600f)] load A with number of players
	                               	| [$1339: and     a] 1 player game?
	jeq	l_133f                             	| [$133a: jp      z,$133f] yes, skip next step

	move.b	#0x17,d2                        	| [$133d: ld      c,$17] C := #17

l_133f:
	move.b	d2,d0                           	| [$133f: ld      a,c] A := C
	move.b	d0,gamemode2_600a               	| [$1340: ld      (gamemode2_600a),a] store into game mode2
	rts                                    	| [$1343: ret] return

* arrive from #0701 when GameMode2 == #F
* clear sounds, clear game start flag, draw game over if needed, set game mode2 accordingly

l_1344:
	jbsr	clear_all_sounds_011c                            	| [$1344: call    $011c] clear all sounds
	clr.b	d0                               	| [$1347: xor     a] A := 0
	move.b	d0,game_start_flag_622c         	| [$1348: ld      (game_start_flag_622c),a] store into game start flag
	lea	number_of_lives_remaining_6228,a0	| [$134b: ld      hl,number_of_lives_remaining_6228] load HL with number of lives remaining
	tst.b	infinite_lives_flag
	bne.b	0f
	subq.b	#1,(a0)                         	| [$134e: dec     (hl)] decrease
0:
	move.b	(a0),d0                         	| [$134f: ld      a,(hl)] load A with the number of lives remaining
	lea	p2numlives_6048,a1             	| [$1350: ld      de,p2numlives_6048] load DE with destination address
	move.w	#0x08,d1                        	| [$1353: ld      bc,$0008] set counter to 8 8
	jbsr	ldir                              	| [$1356: ldir] copy
	tst.b	d0                               	| [$1358: and     a] any lives left?
	jne	l_137f                             	| [$1359: jp      nz,$137f] yes, skip ahead

* game over

	move.b	#0x03,d0                        	| [$135c: ld      a,$03] A := 3
	lea	player_2_score_address_60b5,a0 	| [$135e: ld      hl,player_2_score_address_60b5] load HL with player 2 score address
	jbsr	compute_highscore_insertion_position_13ca                            	| [$1361: call    $13ca] check for high score entry ???
	move.w  #0x0303,d3                      	| [$1364: ld      de,$0303] load task data for text #3 "PLAYER <II>"
	jbsr	insert_task_309f                            	| [$1367: call    $309f] insert task to draw text
	move.w  #0x0300,d3                      	| [$136a: ld      de,$0300] load task data for text #0 "GAME OVER"
	jbsr	insert_task_309f                            	| [$136d: call    $309f] insert task to draw text
	move.w	#0x76d3,d7                      	| [$1370: ld      hl,$76d3] load HL with screen address ???
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$1373: call    $1826] clear an area of the screen
	lea	waittimermsb_6009,a0           	| [$1376: ld      hl,waittimermsb_6009] load HL with timer
	move.b	#0xc0,(a0)+                      	| [$1379: ld      (hl),$c0] set timer to #C0
	                           	| [$137b: inc     hl] HL := GameMode2
	move.b	#0x11,(a0)                      	| [$137c: ld      (hl),$11] set game mode2 to #11
	rts                                    	| [$137e: ret] return

l_137f:
	move.b	#0x17,d2                        	| [$137f: ld      c,$17] C := #17
	move.b	p1numlives_6040,d0              	| [$1381: ld      a,(p1numlives_6040)] load A with number of lives left for player 1
	                               	| [$1384: and     a] player 1 has lives remaining?
	jne	l_138a                             	| [$1385: jp      nz,$138a] yes, skip next step

	move.b	#0x08,d2                        	| [$1388: ld      c,$08] C := 8

l_138a:
	move.b	d2,d0                           	| [$138a: ld      a,c] A := C
	move.b	d0,gamemode2_600a               	| [$138b: ld      (gamemode2_600a),a] store A into game mode2
	rts                                    	| [$138e: ret] return

* arrive from #0701 when GameMode2 == #10
* when 2 player game has ended

l_138f:
	jbsr	rst_18                            	| [$138f: rst     $18] count down timer and only continue here if zero, else RET
	move.b	#0x17,d2                        	| [$1390: ld      c,$17] C := #17
	move.b	p2numlives_6048,d0              	| [$1392: ld      a,(p2numlives_6048)] load A with number of lives for player 2

l_1395:
	addq.b	#1,(a0)                         	| [$1395: inc     (hl)] increase timer ??? [EG HL = WaitTimerMSB]
	tst.b	d0                               	| [$1396: and     a] player has lives remaining ?
	jne	l_139c                             	| [$1397: jp      nz,$139c] yes, skip next step

	move.b	#0x14,d2                        	| [$139a: ld      c,$14] else C := #14

l_139c:
	move.b	d2,d0                           	| [$139c: ld      a,c] A := C
	move.b	d0,gamemode2_600a               	| [$139d: ld      (gamemode2_600a),a] store into game mode2
	rts                                    	| [$13a0: ret] return


* arrive from #0701 when GameMode2 == #11

l_13a1:
	jbsr	rst_18                            	| [$13a1: rst     $18] count down timer and only continue here if zero, else RET
	move.b	#0x17,d2                        	| [$13a2: ld      c,$17] C := #17
	move.b	p1numlives_6040,d0              	| [$13a4: ld      a,(p1numlives_6040)] load A with number of lives remaining for player1
	jra	l_1395                             	| [$13a7: jp      $1395] jump back, rest of this sub is above


* arrive from #0701 when GameMode2 == 12
* flip screen if needed, reset game mode2 to zero, set player 2

l_13aa:
	move.b	uprightcab_6026,d0              	| [$13aa: ld      a,(uprightcab_6026)] load A with upright/cocktail
	move.b	d0,reg_flipscreen               	| [$13ad: ld      (reg_flipscreen),a] store into hardware screen flip
	clr.b	d0                               	| [$13b0: xor     a] A := 0
	move.b	d0,gamemode2_600a               	| [$13b1: ld      (gamemode2_600a),a] set game mode2 to 0
	                      	| [$13b4: ld      hl,$0101] HL := #101
	move.b	#0x1,playerturna_600d             	| [$13b7: ld      (playerturna_600d),hl] store 1 into PlayerTurnA (set player2) and PlayerTurnB (set player2)
	move.b	#0x1,playerturna_600d+1             	| [$13b7: ld      (playerturna_600d),hl] store 1 into PlayerTurnA (set player2) and PlayerTurnB (set player2)
	rts                                    	| [$13ba: ret] return

* arrive from #0701 when GameMode2 == 13
* set player 1, reset game mode2 to zero, set screen flip to not flipped

l_13bb:
	clr.b	d0                               	| [$13bb: xor     a] A := 0
	move.b	d0,playerturna_600d             	| [$13bc: ld      (playerturna_600d),a] set for player 1
	move.b	d0,playerturnb_600e             	| [$13bf: ld      (playerturnb_600e),a] store into current player number 1
	move.b	d0,gamemode2_600a               	| [$13c2: ld      (gamemode2_600a),a] set game mode2 to 0
	addq.b	#1,d0                           	| [$13c5: inc     a] A := 1
	move.b	d0,reg_flipscreen               	| [$13c6: ld      (reg_flipscreen),a] store into screen flip for no flipping
	rts                                    	| [$13c9: ret] return

* causes the player's score to percolate up the high score list
* [but it is never read from ???]

* called from #1361, HL is preloaded with #60B5 = player 2 score address, A is preloaded with 3
* called from #130F, HL is preloaded with #60B2 = player 1 score address, A is preloaded with 1

* this sub copies player score into #61C7-#61C9
* then it breaks the score into component digits and stores them into #61B1 through #61B6
* then it sets #61B7 through #61C4 to #10 (???)
*

compute_highscore_insertion_position_13ca:
	lea	address_for_unknown_61c6,a1    	| [$13ca: ld      de,address_for_unknown_61c6] load DE with address for ???
	move.b	d0,(a1)                         	| [$13cd: ld      (de),a] store A into it
	jbsr	rst_08                            	| [$13ce: rst     $8] continue if there are credits or the game is being played, else RET


	addq.w	#1,a1                           	| [$13cf: inc     de] DE := #61C7
	move.w	#0x03,d1                        	| [$13d0: ld      bc,$0003] set counter to 3 3
	jbsr	ldir                              	| [$13d3: ldir] copy players score into this area
	move.b	#0x03,d1                        	| [$13d5: ld      b,$03] for B = 1 to 3
	lea	score_and_name_line_61b1,a0    	| [$13d7: ld      hl,score_and_name_line_61b1] load HL with ???

l_13da:
	                           	| [$13da: dec     de] count down DE.  first time it has #61C9 after the DEC
	move.b	-(a1),d0                         	| [$13db: ld      a,(de)] load A with this
	ror.b	#4,d0                            	| [$13dc: rrca] * 4
	and.b	#0x0f,d0                         	| [$13e0: and     $0f] mask bits, now between 0 and #F.  this will give the thousands of the score on the 2nd loop.
	move.b	d0,(a0)+                         	| [$13e2: ld      (hl),a] store into (HL) ???
	                           	| [$13e3: inc     hl] next
	move.b	(a1),d0                         	| [$13e4: ld      a,(de)] load A with this
	and.b	#0x0f,d0                         	| [$13e5: and     $0f] mask bits.  this will give the hundreds of the score on the 2nd loop
	move.b	d0,(a0)+                         	| [$13e7: ld      (hl),a] store into (HL)
											| [$13e8: inc     hl] next
	subq.b	#1,d1                           	| [...]
	jne	l_13da                             	| [$13e9: djnz    $13da] next B

* sets #61B7 through #61C4 to #10

	move.b	#0x0e,d1                        	| [$13eb: ld      b,$0e] for B = 1 to #E

	* blank chars for the name
l_13ed:
	move.b	#0x10,(a0)                      	| [$13ed: ld      (hl),$10] store #10 into memory at (HL)
	addq.w	#1,a0                           	| [$13ef: inc     hl] next HL
	subq.b	#1,d1                           	| [...]
	jne	l_13ed                             	| [$13f0: djnz    $13ed] next B


	move.b	#0x3f,(a0)                      	| [$13f2: ld      (hl),$3f] store #3F into #61C5 = end code for score string

	move.b	#0x05,d1                        	| [$13f4: ld      b,$05] for B = 1 to 5.  Do for each high score in top 5 (at worst)
	lea	lowest_high_score_address_61a5,a0	| [$13f6: ld      hl,lowest_high_score_address_61a5] load HL with lowest high score address
	lea	copy_of_player_score_61c7,a1   	| [$13f9: ld      de,copy_of_player_score_61c7] load DE with copy of player score

l_13fc:
	move.b	(a1)+,d0                         	| [$13fc: ld      a,(de)] load A with a digit of player's score
	sub.b	(a0)+,d0                          	| [$13fd: sub     (hl)] subtract next lowest high score
												| [$13fe: inc     hl] next
												| [$13ff: inc     de] next
	move.b	(a1)+,d0                         	| [$1400: ld      a,(de)] load A with next digit of player's score
	move.b	(a0)+,d7
	subx.b	d7,d0                         		| [$1401: sbc     a,(hl)] subtract with carry next lowest high score
												| [$1402: inc     hl] next
												| [$1403: inc     de] next
	move.b	(a1),d0                         	| [$1404: ld      a,(de)] load A with next digit of player's score
	move.b	(a0),d7
	subx.b	d7,d0                         	| [$1405: sbc     a,(hl)] subtract with carry next lowest high score
	bcc.b	0f                               	| [...]
	rts                                    	| [$1406: ret     c] if player has not made this high score, return [...]
0:

* player has made a high score for entry in top 5
* D1 = 5 at start

	move.w	d1,-(sp)                    	| [$1407: push    bc] else save BC

	move.b	#0x19,d1                          	| [$1408: ld      b,#$19] for B = 1 to #19

        * exchange the values in (HL) and (DE) for #19 bytes
        * this causes the high score to percolate up the high score list

l_140a:
	move.b	(a0),d2                         	| [$140a: ld      c,(hl)] C := (HL)
	move.b	(a1),d0                         	| [$140b: ld      a,(de)] A := (DE)
	move.b	d0,(a0)                         	| [$140c: ld      (hl),a] (HL) := A
	move.b	d2,d0                           	| [$140d: ld      a,c] A := C
	move.b	d0,(a1)                         	| [$140e: ld      (de),a] (DE) := A
	subq.w	#1,a0                           	| [$140f: dec     hl] next HL
	subq.w	#1,a1                           	| [$1410: dec     de] next DE
	subq.b	#1,d1                           	| [...]
	jne		l_140a                               	| [$1411: djnz    #140A] Next B

	move.w	#11,d1                        	| [$1413: ld      bc,$fff5] load BC with -#B 65525
	sub.w	d1,a0                            	| [$1416: add     hl,bc] add to HL.  HL now has #B less than before
	                              	| [$1417: ex      de,hl] DE <> HL
	sub.w	d1,a1                            	| [$1418: add     hl,bc] add to HL, now has #B less than before
	                              	| [$1419: ex      de,hl] DE <> HL

	move.w	(sp)+,d1                    	| [$141a: pop     bc] restore BC
	subq.b	#1,d1                           	| [...]
	jne	l_13fc                             	| [$141b: djnz    $13fc] Next B

	rts                                    	| [$141d: ret] return

* jump here from #0701 when GameMode2 == #14 (game is over)
* draw credits on screen, clears screen and sprites, checks for high score, flips screen if necessary

check_for_a_high_score_141e:
	jbsr	l_0616                            	| [$141e: call    $0616] draw credits on screen
	jbsr	rst_18                            	| [$1421: rst     $18] count down timer and only continue here if zero, else RET

	jbsr	clear_screen_and_sprites_0874                            	| [$1422: call    $0874] clears the screen and sprites
	clr.b	d0                               	| [$1425: ld      a,$00] A := 0
	move.b	d0,playerturnb_600e             	| [$1427: ld      (playerturnb_600e),a] set player number 1
	move.b	d0,playerturna_600d             	| [$142a: ld      (playerturna_600d),a] set player1
	lea	address_of_high_score_indicator_611c,a0	| [$142d: ld      hl,address_of_high_score_indicator_611c] load HL with high score entry indicator
	move.w	#0x0022,d3                      	| [$1430: ld      de,$0022] offset to add is #22 34
	move.b	#0x05,d1                        	| [$1433: ld      b,$05] for B = 1 to 5
	move.b	#0x01,d0                        	| [$1435: ld      a,$01] A := 1 = code for a new high score for player 1

l_1437:
	cmp.b	(a0),d0                          	| [$1437: cp      (hl)] compare (HL) to 1 .  equal ?
	jeq	l_1459                             	| [$1438: jp      z,$1459] yes, jump to high score entry for player 1

	add.w	d3,a0                            	| [$143b: add     hl,de] else next HL
	subq.b	#1,d1                           	| [...]
	jne	l_1437                             	| [$143c: djnz    $1437] next B

	lea	address_of_high_score_indicator_611c,a0	| [$143e: ld      hl,address_of_high_score_indicator_611c] load HL with high score entry indicator
	move.b	#0x05,d1                        	| [$1441: ld      b,$05] For B = 1 to 5
	move.b	#0x03,d0                        	| [$1443: ld      a,$03] A := 3 = code for a new high score for player 2

l_1445:
	cmp.b	(a0),d0                          	| [$1445: cp      (hl)] compare.  same?
	jeq	l_144f                             	| [$1446: jp      z,$144f] yes, skip ahead and being high score entry for pl2

	add.w	d3,a0                            	| [$1449: add     hl,de] add offset for next table high score entry
	subq.b	#1,d1                           	| [...]
	jne	l_1445                             	| [$144a: djnz    $1445] Next B

	jra	l_1475                             	| [$144c: jp      $1475] skip ahead, no high score was achieved

* high score achieved ?

l_144f:
	move.b	#0x01,d0                        	| [$144f: ld      a,$01] A := 1
	move.b	d0,playerturnb_600e             	| [$1451: ld      (playerturnb_600e),a] set player #2
	move.b	d0,playerturna_600d             	| [$1454: ld      (playerturna_600d),a] set player2
	clr.b	d0                               	| [$1457: ld      a,$00] A := 0

l_1459:
	lea	uprightcab_6026,a0             	| [$1459: ld      hl,uprightcab_6026] load HL with address for upright/cocktail
	or.b	(a0),d0                           	| [$145c: or      (hl)] mix with A
	move.b	d0,reg_flipscreen               	| [$145d: ld      (reg_flipscreen),a] store A into screen flip setting
	clr.b	d0                               	| [$1460: ld      a,$00] A := 0
	move.b	d0,waittimermsb_6009            	| [$1462: ld      (waittimermsb_6009),a] clear timer
	lea	gamemode2_600a,a0              	| [$1465: ld      hl,gamemode2_600a] load HL with game mode2 address
	addq.b	#1,(a0)                         	| [$1468: inc     (hl)] increase game mode2 to #15
	move.w	#0x030d,d3                      	| [$1469: ld      de,$030d] load task data for text #D "NAME REGISTRATION"
	move.b	#0x0c,d1                        	| [$146c: ld      b,$0c] set counter for #0C items (12 decimal)

l_146e:
	jbsr	insert_task_309f                            	| [$146e: call    $309f] insert task to draw text
	addq.w	#1,d3                           	| [$1471: inc     de] next text set
	subq.b	#1,d1                           	| [...]
	jne	l_146e                             	| [$1472: djnz    $146e] next B

	rts                                    	| [$1474: ret] return

* jump here from #144C

l_1475:
	move.b	#0x01,d0                        	| [$1475: ld      a,$01] A := 1
	move.b	d0,reg_flipscreen               	| [$1477: ld      (reg_flipscreen),a] set screen flip setting
	move.b	d0,gamemode1_6005               	| [$147a: ld      (gamemode1_6005),a] store into game mode1
	move.b	d0,nocredits_6007               	| [$147d: ld      (nocredits_6007),a] set indicator for no credits
	clr.b	d0                               	| [$1480: ld      a,$00] A := 0
	move.b	d0,gamemode2_600a               	| [$1482: ld      (gamemode2_600a),a] reset game mode2 to 0.  game is now totally over.
	rts                                    	| [$1485: ret] return


* jump from #0701 when GameMode2 == #15
* game is over - high score entry


enter_initials_1486:
	jbsr	l_0616                            	| [$1486: call    $0616] draw credits on screen
	lea	waittimermsb_6009,a0           	| [$1489: ld      hl,waittimermsb_6009] load HL with timer
	move.b	(a0),d0                         	| [$148c: ld      a,(hl)] load A with timer value
	                               	| [$148d: and     a] == 0 ?
	jne	l_14dc                             	| [$148e: jp      nz,$14dc] no, skip ahead

	move.b	d0,reg_palette_a                	| [$1491: ld      (reg_palette_a),a] set palette bank selector
	move.b	d0,reg_palette_b                	| [$1494: ld      (reg_palette_b),a] set palette bank selector
	jbsr	osd_update_palette_bank
	move.b	#0x01,(a0)                      	| [$1497: ld      (hl),$01] set timer to 1
	lea	hscursordelay_6030,a0          	| [$1499: ld      hl,hscursordelay_6030] load HL with HSCursorDelay
	move.b	#0x0a,(a0)+                      	| [$149c: ld      (hl),$0a]
	                           	| [$149e: inc     hl] HL := HSBlinkToggle
	clr.b	(a0)+                             	| [$149f: ld      (hl),$00]
	                           	| [$14a1: inc     hl] HL := HSBlinkTimer
	move.b	#0x10,(a0)+                      	| [$14a2: ld      (hl),$10]
	                           	| [$14a4: inc     hl] HL := HSRegiTime
	move.b	#0x1e,(a0)+                      	| [$14a5: ld      (hl),$1e]
	                           	| [$14a7: inc     hl] HL := HSTimer
	move.b	#0x3e,(a0)+                      	| [$14a8: ld      (hl),$3e] set outer loop timer
	                           	| [$14aa: inc     hl] HL := HSCursorPos
	clr.b	(a0)                             	| [$14ab: ld      (hl),$00] set high score digit selected
	move.w	#0x75e8,d7                      	| [$14ad: ld      hl,$75e8] load HL with screen position for first player initial
	move.w	d7,hsinitialpos_6036            	| [$14b0: ld      (hsinitialpos_6036),hl] save into this indicator
	lea	address_of_high_score_indicator_611c,a0	| [$14b3: ld      hl,address_of_high_score_indicator_611c] load HL with address of high score indicator
	move.b	playerturnb_600e,d0             	| [$14b6: ld      a,(playerturnb_600e)] load A with current player number
	rol.b	#1,d0                            	| [$14b9: rlca] rotate left
	addq.b	#1,d0                           	| [$14ba: inc     a] increase
	move.b	d0,d2                           	| [$14bb: ld      c,a] copy to C.  C now has 1 for player 1, 3 for player 2
	move.w	#0x0022,d3                      	| [$14bc: ld      de,$0022] load DE with offset 34
	move.b	#0x04,d1                        	| [$14bf: ld      b,$04] for B = 1 to 4

l_14c1:
	move.b	(a0),d0                         	| [$14c1: ld      a,(hl)] load A with high score indicator
	cmp.b	d2,d0                            	| [$14c2: cp      c] == current player number ?
	jeq	l_14c9                             	| [$14c3: jp      z,$14c9] yes, skip next 2 steps - this is the one

	add.w	d3,a0                            	| [$14c6: add     hl,de] add offset for next HL
	subq.b	#1,d1                           	| [...]
	jne	l_14c1                             	| [$14c7: djnz    $14c1] Next B

l_14c9:
	STORE_RAM_ADDRESS_LE	a0,highscore_entry_address_6038 	| [$14c9: ld      (highscore_entry_address_6038),hl]
	move.w	#0xfff3,d3                      	| [$14cc: ld      de,$fff3] load DE with offset of -#13
	add.w	d3,a0                            	| [$14cf: add     hl,de] add offset
	STORE_RAM_ADDRESS_LE	a0,unknown_ram_address_603a                 	| [$14d0: ld      (unknown_ram_address_603a),hl] store result into ???
	clr.b	d1                               	| [$14d3: ld      b,$00] B := 0
	move.b	hscursorpos_6035,d0             	| [$14d5: ld      a,(hscursorpos_6035)] load A with high score entry digit selected
	move.b	d0,d2                           	| [$14d8: ld      c,a] copy to C
	jbsr	set_letter_selector_sprite_15fa                            	| [$14d9: call    $15fa] ???

l_14dc:
	lea	hstimer_6034,a0                	| [$14dc: ld      hl,hstimer_6034] load HL with outer loop timer
	subq.b	#1,(a0)                         	| [$14df: dec     (hl)] count down timer.  at zero?
	jne	l_14fc                             	| [$14e0: jp      nz,$14fc] no, skip ahead

	move.b	#0x3e,(a0)                      	| [$14e3: ld      (hl),$3e] reset outer loop timer
												| [$14e5: dec     hl] HL := HSRegiTime
	subq.b	#1,-(a0)                         	| [$14e6: dec     (hl)] decrease.  at zero?
	jeq	l_15c6                             	| [$14e7: jp      z,$15c6] yes, skip ahead to handle

	move.b	(a0),d0                         	| [$14ea: ld      a,(hl)] else load A with time remaining
	st.b	d1                                	| [$14eb: ld      b,$ff] B := #FF.  used to count 10's

l_14ed:
	addq.b	#1,d1                           	| [$14ed: inc     b] increase B
	sub.b	#0x0a,d0                         	| [$14ee: sub     $0a] subtract #0A (10 decimal).  gone under?
	jcc	l_14ed                             	| [$14f0: jp      nc,$14ed] no, loop again.  B will have number of 10's

	add.b	#0x0a,d0                         	| [$14f3: add     a,$0a] add #0A to make between 0 and 9
	WRITE_TO_SCREEN 0x7552                       	| [$14f5: ld      ($7552),a] draw digit to screen
	move.b	d1,d0                           	| [$14f8: ld      a,b] A := B = 10's of time left
	WRITE_TO_SCREEN	0x7572                       	| [$14f9: ld      ($7572),a] draw digit to screen

l_14fc:
	lea	hscursordelay_6030,a0          	| [$14fc: ld      hl,hscursordelay_6030] load HL with HSCursorDelay
	move.b	(a0),d1                         	| [$14ff: ld      b,(hl)] load B with the value
	move.b	#0x0a,(a0)                      	| [$1500: ld      (hl),$0a] store #A into it
	move.b	inputstate_6010,d0              	| [$1502: ld      a,(inputstate_6010)] load A with input
	btst.b	#7,d0                           	| [$1505: bit     7,a] is jump button pressed?
	jne	l_1546                             	| [$1507: jp      nz,$1546] yes, skip ahead

	and.b	#0x03,d0                         	| [$150a: and     $03] mask bits.  check for a left or right direction pressed
	jne	l_1514                             	| [$150c: jp      nz,$1514] if direction, skip next 3 steps

	addq.b	#1,d0                           	| [$150f: inc     a] else increase A
	move.b	d0,(a0)                         	| [$1510: ld      (hl),a] store into HSCursorDelay
	jra	l_158a                             	| [$1511: jp      $158a] skip ahead

* left or right pressed while in high score entry

l_1514:
	subq.b	#1,d1                           	| [$1514: dec     b] decrease B.  at zero?
	jeq	l_151d                             	| [$1515: jp      z,$151d] yes, skip next 3 steps

	move.b	d1,d0                           	| [$1518: ld      a,b] A := B
	move.b	d0,(a0)                         	| [$1519: ld      (hl),a] store into ???
	jra	l_158a                             	| [$151a: jp      $158a] skip ahead

l_151d:
	btst.b	#1,d0                           	| [$151d: bit     1,a] is direction == left ?
	jne	l_1539                             	| [$151f: jp      nz,$1539] yes, skip ahead

	move.b	hscursorpos_6035,d0             	| [$1522: ld      a,(hscursorpos_6035)] load A with high score entry digit selected
	addq.b	#1,d0                           	| [$1525: inc     a] increase
	cmp.b	#0x1e,d0                         	| [$1526: cp      $1e] == #1E ?  (have we gone past END ?)
	jne	l_152d                             	| [$1528: jp      nz,$152d] no, skip next step

	clr.b	d0                               	| [$152b: ld      a,$00] A := 0 [why this way and not XOR A ?] - reset this counter to "A" in the table

l_152d:
	move.b	d0,hscursorpos_6035             	| [$152d: ld      (hscursorpos_6035),a] store into high score entry digit selected
	move.b	d0,d2                           	| [$1530: ld      c,a] C := A
	clr.b	d1                               	| [$1531: ld      b,$00] B := 0
	jbsr	set_letter_selector_sprite_15fa                            	| [$1533: call    $15fa] ???
	jra	l_158a                             	| [$1536: jp      $158a] skip ahead

l_1539:
	move.b	hscursorpos_6035,d0             	| [$1539: ld      a,(hscursorpos_6035)] load A with high score entry digit selected
	subq.b	#0x01,d0                        	| [$153c: sub     $01] decrease [why written this way?  DEC A is standard...]
	jpl	l_152d                             	| [$153e: jp      p,$152d] if sign positive, loop again

	move.b	#0x1d,d0                        	| [$1541: ld      a,$1d] A := #1D
	jra	l_152d                             	| [$1543: jp      $152d] jump back

* jump pressed in high score entry

l_1546:
	move.b	hscursorpos_6035,d0             	| [$1546: ld      a,(hscursorpos_6035)] load A with high score entry digit selected
	cmp.b	#0x1c,d0                         	| [$1549: cp      $1c] == #1C ? = code for backspace ?
	jeq	l_156d                             	| [$154b: jp      z,$156d] yes, skip ahead to handle

	cmp.b	#0x1d,d0                         	| [$154e: cp      $1d] == #1D ? = code for END
	jeq	l_15c6                             	| [$1550: jp      z,$15c6] yes, skip ahead to hanlde

	move.w	hsinitialpos_6036,d7        	| [$1553: ld      hl,(hsinitialpos_6036)] else load HL with VRAM address of the initial being entered
	                        	| [$1556: ld      bc,$7588] load BC with screen address 30088
	                               	| [$1559: and     a] clear carry flag
	cmp.w	#0x7588,d7                            	| [$155a: sbc     hl,bc] subtract.  equal?
	jeq	l_158a                             	| [$155c: jp      z,$158a] yes, skip ahead

	                            	| [$155f: add     hl,bc] else add it back
	add.b	#0x11,d0                         	| [$1560: add     a,$11] add ascii offset of #11 to A
	jbsr	osd_w_videoram                         	| [$1562: ld      (hl),a] write letter to screen
	                        	| [$1563: ld      bc,$ffe0] load BC with offset for next column 65504
	                        	| [$1563: ld      bc,$ffe0] load BC with offset for next column 65504
	add.w	#0xFFE0,d7                            	| [$1566: add     hl,bc] set HL to next column

l_1567:
	move.w	d7,hsinitialpos_6036            	| [$1567: ld      (hsinitialpos_6036),hl] store HL back into VRAM address of the initial being entered
	jra	l_158a                             	| [$156a: jp      $158a] skip ahead

* backspace selected in high score entry

l_156d:
	move.w	hsinitialpos_6036,d7        	| [$156d: ld      hl,(hsinitialpos_6036)] else load HL with VRAM address of the initial being entered
	                        	| [$1570: ld      bc,$0020] load offset of #20 32
	                        	| [$1570: ld      bc,$0020] load offset of #20 32
	add.w	#0x20,d7                            	| [$1573: add     hl,bc] add offset
	tst.b	d0                               	| [$1574: and     a] clear carry flag
	                        	| [$1575: ld      bc,$7608] load BC with screen address 30216
	                        	| [$1575: ld      bc,$7608] load BC with screen address 30216
	cmp.w	#0x7608,d7                            	| [$1578: sbc     hl,bc] subtract.  equal?
	jne	l_1586                             	| [$157a: jp      nz,$1586] no, skip ahead

	move.w	#0x75e8,d7                      	| [$157d: ld      hl,$75e8] else load HL with other screen address

l_1580:
	move.b	#0x10,d0                        	| [$1580: ld      a,$10] A := #10 = blank code
	jbsr	osd_w_videoram                         	| [$1582: ld      (hl),a] clear the screen at this position
	jra	l_1567                             	| [$1583: jp      $1567] jump back

l_1586:
	                            	| [$1586: add     hl,bc] restore HL back to what it was
	jra	l_1580                             	| [$1587: jp      $1580] jump back

* jump here from #156A and #155C and #1536 and #151A and #1511

l_158a:
	lea	hsblinktimer_6032,a0           	| [$158a: ld      hl,hsblinktimer_6032] load HL with HSBlinkTimer
	subq.b	#1,(a0)                         	| [$158d: dec     (hl)] decrease.  at zero ?
	jne	l_15f9                             	| [$158e: jp      nz,$15f9] no, jump to RET. [RET NZ would be faster and more compact]

* Blink the high score in high score table
	move.b	hsblinktoggle_6031,d0           	| [$1591: ld      a,(hsblinktoggle_6031)]
	                               	| [$1594: and     a] Is HSBlinkToggle zero?
	jne	l_15b8                             	| [$1595: jp      nz,$15b8] no, skip ahead

	move.b	#0x01,d0                        	| [$1598: ld      a,$01] A := 1
	move.b	d0,hsblinktoggle_6031           	| [$159a: ld      (hsblinktoggle_6031),a] store into HSBlinkToggle
	lea	game_rom+0x01bf,a1                      	| [$159d: ld      de,$01bf]

l_15a0:
	LOAD_RAM_ADDRESS_LE	highscore_entry_address_6038,a3             	| [$15a0: ld      iy,(highscore_entry_address_6038)] load IY with Unk6038
	move.b	(0x04,a3),d6                    	| [$15a4: ld      l,(iy+$04)]
	move.b	(0x05,a3),d5                    	| [$15a7: ld      h,(iy+$05)]
	LOAD_D5_16_FROM_D5D6
	move.w	d5,a2                        	| [$15aa: push    hl] screen address
											| [$15ab: pop     ix] load IX with HL
	jbsr	l_057c                            	| [$15ad: call    $057c] ???
	move.b	#0x10,d0                        	| [$15b0: ld      a,$10] A := #10
	move.b	d0,hsblinktimer_6032            	| [$15b2: ld      (hsblinktimer_6032),a] store into HSBlinkTimer
	jra	l_15f9                             	| [$15b5: jp      $15f9] jump to RET [RET would be faster and more compact]

l_15b8:
	clr.b	d0                               	| [$15b8: xor     a] A := 0
	move.b	d0,hsblinktoggle_6031           	| [$15b9: ld      (hsblinktoggle_6031),a] store into HSBlinkToggle
	LOAD_RAM_ADDRESS_LE		highscore_entry_address_6038,a1             	| [$15bc: ld      de,(highscore_entry_address_6038)]
	addq.w	#3,a1                           	| [$15c0: inc     de] * 3
	jra	l_15a0                             	| [$15c3: jp      $15a0] jump back

* arrive here from #14E7
* high score entry complete ???

l_15c6:
	LOAD_RAM_ADDRESS_LE	highscore_entry_address_6038,a1             	| [$15c6: ld      de,(highscore_entry_address_6038)] load DE with address of high score entry indicator
	clr.b	d0                               	| [$15ca: xor     a] A := 0
	move.b	d0,(a1)                         	| [$15cb: ld      (de),a] store.  this clears the high score indicator
	lea	waittimermsb_6009,a0           	| [$15cc: ld      hl,waittimermsb_6009] load HL with timer
	move.b	#0x80,(a0)+                      	| [$15cf: ld      (hl),$80] set time to #80
											| [$15d1: inc     hl] HL := GameMode2
	subq.b	#1,(a0)                         	| [$15d2: dec     (hl)] decrease game mode2
	move.b	#0x0c,d1                        	| [$15d3: ld      b,$0c] for B = 1 to #C (12 decimal)
	move.w	#0x75e8,d7                      	| [$15d5: ld      hl,$75e8] load HL with screen vram address
	LOAD_RAM_ADDRESS_LE	unknown_ram_address_603a,a3             	| [$15d8: ld      iy,(unknown_ram_address_603a)] load IY with ???
 	move.w	#0xffe0,d3                      	| [$15dc: ld      de,$ffe0] load DE with offset of -#20

l_15df:
	jbsr	osd_r_videoram                         	| [$15df: ld      a,(hl)] load A with
	move.b	d0,(a3)+                    	| [$15e0: ld      (iy+$00),a] store
	                           	| [$15e3: inc     iy] next
	add.w	d3,d7                            	| [$15e5: add     hl,de] add offset
	subq.b	#1,d1                           	| [...]
	jne	l_15df                             	| [$15e6: djnz    $15df] next B

	* now is a good time to save highscore
	lea		high_score_ram_6100,a0
	jbsr	osd_write_high_scores
	
	move.b	#0x05,d1                        	| [$15e8: ld      b,$05] For B = 1 to 5
	move.w	#0x0314,d3                      	| [$15ea: ld      de,$0314] load task data for text #14 - start of high score table

l_15ed:
	jbsr	insert_task_309f                            	| [$15ed: call    $309f] insert task to draw text
	addq.w	#1,d3                           	| [$15f0: inc     de] next high score
	subq.b	#1,d1                           	| [...]
	jne	l_15ed                             	| [$15f1: djnz    $15ed] next B

	move.w  #0x031a,d3                      	| [$15f3: ld      de,$031a] load task data for text #1A - "YOUR NAME WAS REGISTERED"
	jbsr	insert_task_309f                            	| [$15f6: call    $309f] insert task to draw text
l_15f9:
	rts                                    	| [$15f9: ret] return

* sets the sprite to the square selector for intials entry
* called from #14D9 and #1533

set_letter_selector_sprite_15fa:
	move.l	a1,-(sp)                        	| [$15fa: push    de] save DE

	move.l	a0,-(sp)                        	| [$15fb: push    hl] save HL
	and.w	#0xFF,d2
	asl.b	#1,d2                            	| [$15fc: sla     c]
	lea	game_rom+0x360f,a0                      	| [$15fe: ld      hl,$360f] start of table data
	add.w	d2,a0                            	| [$1601: add     hl,bc]
	exg	a1,a0                              	| [$1602: ex      de,hl]
	lea	unknown_6974,a0                	| [$1603: ld      hl,unknown_6974]
	move.b	(a1)+,d0                         	| [$1606: ld      a,(de)] load A with table data
	                           	| [$1607: inc     de] next table entry
	move.b	d0,(a0)+                         	| [$1608: ld      (hl),a] store
	                           	| [$1609: inc     hl] next location
	move.b	#0x72,(a0)+                      	| [$160a: ld      (hl),$72]
	                           	| [$160c: inc     hl]
	move.b	#0x0c,(a0)+                      	| [$160d: ld      (hl),$0c]
	                           	| [$160f: inc     hl]
	move.b	(a1),d0                         	| [$1610: ld      a,(de)]
	move.b	d0,(a0)                         	| [$1611: ld      (hl),a]
	move.l	(sp)+,a0                        	| [$1612: pop     hl] restore HL
	move.l	(sp)+,a1                        	| [$1613: pop     de] restore DE
	rts                                    	| [$1614: ret] return

* arrive when GameMode2 == #16 (level completed).  called from #0701

end_of_level_animations_1615:
	jbsr	l_30bd                            	| [$1615: call    $30bd] clear sprites
	move.b	screen_number_6227,d0           	| [$1618: ld      a,(screen_number_6227)] load a with screen number
	ror.b	#1,d0                            	| [$161b: rrca] roll right with carry.  is this the rivets or the conveyors?
	jcc	l_162f                             	| [$161c: jp      nc,$162f] yes, skip ahead to #162F

                                        * handle for girders or elevators, they are same here

	move.b	end_of_level_counter_6388,d0    	| [$161f: ld      a,(end_of_level_counter_6388)] load A with this counter usually zero, counts from 1 to 5 when the level is complete
	jbsr	rst_28                            	| [$1622: rst     $28] jump based on A

	.long	l_1654 | #1654         | 0
	.long	l_1670 | #1670         | 1
	.long	l_168a | #168A         | 2
	.long	l_1732 | #1732         | 3
	.long	l_1757 | #1757         | 4
	.long	l_178e | #178E         | 5

l_162f:
	ror.b	#1,d0                            	| [$162f: rrca] roll right again.  is this the rivets ?
	jcc	l_1641                             	| [$1630: jp      nc,$1641] yes, skip ahead

* else the conveyors

	move.b	end_of_level_counter_6388,d0    	| [$1633: ld      a,(end_of_level_counter_6388)] load A with this usually zero, counts from 1 to 5 when the level is complete
	jbsr	rst_28                            	| [$1636: rst     $28] jump based on A

	.long	l_16a3   | #16A3         | 0
	.long	l_16bb   | #16BB         | 1
	.long	l_1732   | #1732         | 2
	.long	l_1757   | #1757         | 3
	.long	l_178e   | #178E         | 4

* rivets

l_1641:
	jbsr	check_for_bonus_items_1dbd                            	| [$1641: call    $1dbd] check for bonus items and jumping scores, rivets
	move.b	end_of_level_counter_6388,d0    	| [$1644: ld      a,(end_of_level_counter_6388)] load A with usually zero, counts from 1 to 5 when the level is complete

	jbsr	rst_28                            	| [$1647: rst     $28] jump based on A

	.long	l_17b6  | #17B6         | 0
	.long	l_3069  | #3069         | 1
	.long	l_1839  | #1839         | 2
	.long	l_186f  | #186F         | 3
	.long	l_1880  | #1880         | 4
	.long	l_18c6  | #18C6         | 5

* jump here from #1622 when girders or elevators is finished.  step 1 of 6
l_1654:
	jbsr	l_1708                            	| [$1654: call    $1708] clear all sounds, draw heart sprite, redraw girl sprite, clear "help", play end of level sound
	lea	game_rom+0x385c,a0                      	| [$1657: ld      hl,$385c] load HL with start of kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$165a: call    $004e] update kong's sprites
	move.b	#0x20,d0                        	| [$165d: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$165f: ld      (waittimermsb_6009),a] set timer to #20

l_1662:
	lea	end_of_level_counter_6388,a0   	| [$1662: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$1665: inc     (hl)] increase counter
	move.b	#0x01,d0                        	| [$1666: ld      a,$01] A := 1 = code for girders
	jbsr	only_continues_if_given_level_0030                            	| [$1668: rst     $30] if girders, continue below.  else RET

	lea	kong_sprite_array_690b,a0      	| [$1669: ld      hl,kong_sprite_array_690b] load HL with start of kong sprite
	move.b	#0xfc,d2                        	| [$166c: ld      c,$fc] set movement for -4 pixels
	jbsr	rst_38                            	| [$166e: rst     $38] move kong
	rts                                    	| [$166f: ret] return

* jump here from #1622 when girders or elevators is finished.  step 2 of 6

l_1670:
	jbsr	rst_18                            	| [$1670: rst     $18] count down timer and only continue here if zero, else RET
	lea	game_rom+0x3932,a0                      	| [$1671: ld      hl,$3932] load HL with start of kong's sprites table data
	jbsr	update_kong_sprites_004e                            	| [$1674: call    $004e] update kong's sprites
	move.b	#0x20,d0                        	| [$1677: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$1679: ld      (waittimermsb_6009),a] set timer to #20
	lea	end_of_level_counter_6388,a0   	| [$167c: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$167f: inc     (hl)] increase counter
	move.b	#0x04,d0                        	| [$1680: ld      a,$04] A := 4 = 100 code for elevators
	jbsr	only_continues_if_given_level_0030                            	| [$1682: rst     $30] only continue here if elevators, else RET

	lea	kong_sprite_array_690b,a0      	| [$1683: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	move.b	#0x04,d2                        	| [$1686: ld      c,$04] set to move by 4
	jbsr	rst_38                            	| [$1688: rst     $38] move kong by +4
	rts                                    	| [$1689: ret] return

* jump here from #1622 when girders or elevators is finished.  step 3 of 6

l_168a:
	jbsr	rst_18                            	| [$168a: rst     $18] count down timer and only continue here if zero, else RET
	lea	game_rom+0x388c,a0                      	| [$168b: ld      hl,$388c] load HL with start of table data for kong
	jbsr	update_kong_sprites_004e                            	| [$168e: call    $004e] update kong's sprites
	move.b	#0x66,d0                        	| [$1691: ld      a,$66] A := #66
	move.b	d0,clear_kongs_top_right_sprite_690c	| [$1693: ld      (clear_kongs_top_right_sprite_690c),a] store into kong's right arm sprite
	clr.b	d0                               	| [$1696: xor     a] A := 0
	clr.b	kongs_right_arm_sprite_for_carrying_girl_6924	| [$1697: ld      (kongs_right_arm_sprite_for_carrying_girl_6924),a] clear the other side of kongs arm
	clr.b	girl_being_carried_sprite_692c	| [$169a: ld      (girl_being_carried_sprite_692c),a] clear the girl sprite that kong is carrying
	clr.b	kong_misc_counter_62af   	| [$169d: ld      (kong_misc_counter_62af),a] clear the kong climbing counter
	jra	l_1662                             	| [$16a0: jp      $1662] jump back

* jump here from #1622 when conveyors is finished.  step 1 of 5

l_16a3:
	jbsr	l_1708                            	| [$16a3: call    $1708] clear all sounds, draw heart sprite, redraw girl sprite, clear "help", play end of level sound
	move.b	kongs_x_position_6910,d0        	| [$16a6: ld      a,(kongs_x_position_6910)] load A with kong's X position
	sub.b	#0x3b,d0                         	| [$16a9: sub     $3b] subtract #3B
	lea	game_rom+0x385c,a0                      	| [$16ab: ld      hl,$385c] load HL with kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$16ae: call    $004e] update kong's sprites to default kong graphic
	lea	start_of_kong_sprite_6908,a0   	| [$16b1: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	move.b	d0,d2                           	| [$16b4: ld      c,a] load C with offset computed above to move kong back where he was
	jbsr	rst_38                            	| [$16b5: rst     $38] move Kong
	lea	end_of_level_counter_6388,a0   	| [$16b6: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$16b9: inc     (hl)] increase counter
	rts                                    	| [$16ba: ret] return

* jump here from #1622 when conveyors is finished.  step 2 of 5

l_16bb:
	clr.b	d0                               	| [$16bb: xor     a] A := 0
	move.b	d0,top_conveyor_counter_62a0    	| [$16bc: ld      (top_conveyor_counter_62a0),a] clear top conveyor counter
	move.b	top_conveyor_direction_vector_63a3,d0	| [$16bf: ld      a,(top_conveyor_direction_vector_63a3)] load A with direction vector for top conveyor
	move.b	d0,d2                           	| [$16c2: ld      c,a] copy to C
	move.b	kongs_x_position_6910,d0        	| [$16c3: ld      a,(kongs_x_position_6910)] load A with kong's X position
	cmp.b	#0x5a,d0                         	| [$16c6: cp      $5a] < #5A ?
	jcc	l_16e1                             	| [$16c8: jp      nc,$16e1] yes, skip ahead

	btst.b	#7,d2                           	| [$16cb: bit     7,c]
	jeq	l_16d5                             	| [$16cd: jp      z,$16d5] yes, skip next 2 steps

l_16d0:
	move.b	#0x01,d0                        	| [$16d0: ld      a,$01] A := 1
	move.b	d0,top_conveyor_counter_62a0    	| [$16d2: ld      (top_conveyor_counter_62a0),a] store into top conveyor counter

l_16d5:
	jbsr	l_2602                            	| [$16d5: call    $2602] ???
	move.b	top_conveyor_direction_vector_63a3,d0	| [$16d8: ld      a,(top_conveyor_direction_vector_63a3)] load A with direction vector for top conveyor
	move.b	d0,d2                           	| [$16db: ld      c,a] C := 1
	lea	start_of_kong_sprite_6908,a0   	| [$16dc: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	jbsr	rst_38                            	| [$16df: rst     $38] move kong
	rts                                    	| [$16e0: ret] return

l_16e1:
	cmp.b	#0x5d,d0                         	| [$16e1: cp      $5d] < #5D ?
	jcs	l_16ee                             	| [$16e3: jp      c,$16ee] no, skip ahead

	btst.b	#7,d2                           	| [$16e6: bit     7,c] is bit 7 of C zero?
	jeq	l_16d0                             	| [$16e8: jp      z,$16d0] yes, jump back

	jra	l_16d5                             	| [$16eb: jp      $16d5] jump back

l_16ee:
	lea	game_rom+0x388c,a0                      	| [$16ee: ld      hl,$388c] load HL with start of table data for kong
	jbsr	update_kong_sprites_004e                            	| [$16f1: call    $004e] update kong's sprites
	move.b	#0x66,d0                        	| [$16f4: ld      a,$66] A := #66
	move.b	d0,clear_kongs_top_right_sprite_690c	| [$16f6: ld      (clear_kongs_top_right_sprite_690c),a] store into kong's right arm sprite for climbing
	clr.b	d0                               	| [$16f9: xor     a] A := 0
	move.b	d0,kongs_right_arm_sprite_for_carrying_girl_6924	| [$16fa: ld      (kongs_right_arm_sprite_for_carrying_girl_6924),a] clear kong's arm sprite
	move.b	d0,girl_being_carried_sprite_692c	| [$16fd: ld      (girl_being_carried_sprite_692c),a] clear girl under kong's arm
	move.b	d0,kong_misc_counter_62af   	| [$1700: ld      (kong_misc_counter_62af),a] clear kong climbing counter
	lea	end_of_level_counter_6388,a0   	| [$1703: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$1706: inc     (hl)] increase counter
	rts                                    	| [$1707: ret] return

* called from #1654 and #16A3
* clears all sounds, draws heart sprite, redraws girl sprite, clear "help", play end of level sound

l_1708:
	jbsr	clear_all_sounds_011c                            	| [$1708: call    $011c] clear all sounds
	lea	heart_sprite_x_position_6a20,a0	| [$170b: ld      hl,heart_sprite_x_position_6a20] load HL with heart sprite
	move.b	#0x80,(a0)+                      	| [$170e: ld      (hl),$80] set heart sprite X position
	                           	| [$1710: inc     hl] next
	move.b	#0x76,(a0)+                      	| [$1711: ld      (hl),$76] set heart sprite
	                           	| [$1713: inc     hl] next
	move.b	#0x09,(a0)+                      	| [$1714: ld      (hl),$09] set heart sprite color
	                           	| [$1716: inc     hl] next
	move.b	#0x20,(a0)                      	| [$1717: ld      (hl),$20] set heart sprite Y position
	lea	girls_sprite_6905,a0           	| [$1719: ld      hl,girls_sprite_6905] load HL with girl's sprite
	move.b	#0x13,(a0)                      	| [$171c: ld      (hl),$13] set girl's sprite
	move.w	#0x75c4,d7                      	| [$171e: ld      hl,$75c4] load HL with VRAM screen address
	move.w	#0x0020,d3                      	| [$1721: ld      de,$0020] DE := #20 32
	move.b	#0x10,d0                        	| [$1724: ld      a,$10] A := #10
	jbsr	clear_help_0514                            	| [$1726: call    $0514] clear "help" that the girl yells
	lea	sound_buffer_address_608a,a0   	| [$1729: ld      hl,sound_buffer_address_608a] load sound address
	
	move.b	#MUS_FANFARE,d0
	move.b	d0,(a0)+                      	| [$172c: ld      (hl),$07] play sound for end of level
	jbsr	osd_sound_start
	                           	| [$172e: inc     hl] HL now has sound duration
	move.b	#0x03,(a0)                      	| [$172f: ld      (hl),$03] set duration to 3
	rts                                    	| [$1731: ret] return

* jump here from #1622 when girders or elevators is finished.  step 4 of 6
* jump here from #1622 when conveyors is finished.  step 3 of 5

l_1732:
	jbsr	kong_climbing_ladder_with_girl_306f                            	| [$1732: call    $306f] animate kong climbing up the ladder with girl under arm
	move.b	kong_sprite_y_position_6913,d0  	| [$1735: ld      a,(kong_sprite_y_position_6913)] load A with kong sprite Y position
	cmp.b	#0x2c,d0                         	| [$1738: cp      $2c] < #2C ? (level of the girl)
	bcs.b	0f                               	| [...]
	rts                                    	| [$173a: ret     nc] yes, return [...]
0:

* else kong has grabbed the girl on the way out

	clr.b	d0                               	| [$173b: xor     a] A := #00
	move.b	d0,girls_head_sprite_6900       	| [$173c: ld      (girls_head_sprite_6900),a] clear girl's head sprite
	move.b	d0,girls_body_sprite_6904       	| [$173f: ld      (girls_body_sprite_6904),a] clear girl's body sprite
	move.b	d0,clear_kongs_top_right_sprite_690c	| [$1742: ld      (clear_kongs_top_right_sprite_690c),a] clear kong's top right sprite
	move.b	#0x6b,d0                        	| [$1745: ld      a,$6b] A := #6B = code for sprite with kong's arm out
	move.b	d0,kongs_right_arm_sprite_for_carrying_girl_6924	| [$1747: ld      (kongs_right_arm_sprite_for_carrying_girl_6924),a] store into kong's right arm sprite for carrying girl
	subq.b	#1,d0                           	| [$174a: dec     a] A := #6A = code for sprite with girl being carried
	move.b	d0,girl_being_carried_sprite_692c	| [$174b: ld      (girl_being_carried_sprite_692c),a] store into girl being carried sprite
	lea	heart_sprite_6a21,a0           	| [$174e: ld      hl,heart_sprite_6a21] load HL with heart sprite
	addq.b	#1,(a0)                         	| [$1751: inc     (hl)] change heart to broken
	lea	end_of_level_counter_6388,a0   	| [$1752: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$1755: inc     (hl)] increase counter
	rts                                    	| [$1756: ret] return

* jump here from #1622 when girders or elevators is finished.  step 5 of 6
* jump here from #1622 when conveyors is finished.  step 4 of 5

l_1757:
	jbsr	kong_climbing_ladder_with_girl_306f                            	| [$1757: call    $306f] animate kong climbing up the ladder with girl under arm
	jbsr	l_176c                            	| [$175a: call    $176c] ???
	addq.w	#1,a0                           	| [$175d: inc     hl]
	addq.w	#1,d3                           	| [$175e: inc     de]
	jbsr	l_1783                            	| [$175f: call    $1783] ???
	move.b	#0x40,d0                        	| [$1762: ld      a,$40] A := #40
	move.b	d0,waittimermsb_6009            	| [$1764: ld      (waittimermsb_6009),a] set timer to #40
	lea	end_of_level_counter_6388,a0   	| [$1767: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$176a: inc     (hl)] increase counter
	rts                                    	| [$176b: ret] return

* called from #175A, above

l_176c:
	move.w	#0x0003,d3                      	| [$176c: ld      de,$0003] load DE with offset to subtract 3
	lea	girl_under_kongs_arm_y_position_692f,a0	| [$176f: ld      hl,girl_under_kongs_arm_y_position_692f] load HL with girl under kong's arm Y position.  counting down, it will go through all of kong's body
	move.b	#0x0a,d1                        	| [$1772: ld      b,$0a] for B = 1 to #0A

l_1774:
	tst.b	d0                               	| [$1774: and     a] clear carry flag
	move.b	(a0),d0                         	| [$1775: ld      a,(hl)] load A with Y position
	sub.w	d3,a0                            	| [$1776: sbc     hl,de] next offset
	cmp.b	#0x19,d0                         	| [$1778: cp      $19] girl still on screen?
	jcc	l_177f                             	| [$177a: jp      nc,$177f] yes, skip next step

	clr.b	(a0)                             	| [$177d: ld      (hl),$00] set Y position to 0 = clear from screen ?

l_177f:
	subq.w	#1,a0                           	| [$177f: dec     hl] previous data
	subq.b	#1,d1                           	| [...]
	jne	l_1774                             	| [$1780: djnz    $1774] Next B

	rts                                    	| [$1782: ret] return

* called from #175F

l_1783:
	move.b	#0x0a,d1                        	| [$1783: ld      b,$0a] for B = 1 to #A

l_1785:
	move.b	(a0),d0                         	| [$1785: ld      a,(hl)] load A with ???
	                               	| [$1786: and     a] == 0 ?
	jne	l_0026                             	| [$1787: jp      nz,$0026] no, jump to #0026.  This will effectively RET twice

	add.w	d3,a0                            	| [$178a: add     hl,de] else add offset for next memory
	subq.b	#1,d1                           	| [...]
	jne	l_1785                             	| [$178b: djnz    $1785] next B

	rts                                    	| [$178d: ret] return

* jump here from #1622 when girders or elevators is finished.  step 6 of 6
* jump here from #1622 when conveyors is finished.  step 5 of 5

l_178e:
	jbsr	rst_18                            	| [$178e: rst     $18] count down timer and only continue here if zero, else RET
	LOAD_ROM_ADDRESS_LE	store_622a,a0               	| [$178f: ld      hl,(store_622a)] load HL with address for this screen/level
	addq.w	#1,a0                           	| [$1792: inc     hl] next screen
	move.b	(a0),d0                         	| [$1793: ld      a,(hl)] load A with the screen for next
	cmp.b	#0x7f,d0                         	| [$1794: cp      $7f] at end ?
	jne	l_179d                             	| [$1796: jp      nz,$179d] no, skip next 2 steps

	lea	game_rom+0x3a73,a0                      	| [$1799: ld      hl,$3a73] load HL with table for screens/levels for level 5+
	move.b	(a0),d0                         	| [$179c: ld      a,(hl)] load A with the screen

l_179d:
	STORE_ROM_ADDRESS_LE	a0,store_622a                   	| [$179d: ld      (store_622a),hl] store screen address lookup for next time
	move.b	d0,screen_number_6227           	| [$17a0: ld      (screen_number_6227),a] store A into screen number
	move.w  #0x0500,d3                      	| [$17a3: ld      de,$0500] load task #5, parameter 0 | adds bonus to player's score
	jbsr	insert_task_309f                            	| [$17a6: call    $309f] insert task
	clr.b	d0                               	| [$17a9: xor     a] A := 0
	move.b	d0,end_of_level_counter_6388    	| [$17aa: ld      (end_of_level_counter_6388),a] clear end of level counter
	lea	waittimermsb_6009,a0           	| [$17ad: ld      hl,waittimermsb_6009] load HL with timer addr.
	move.b	#0x30,(a0)+                      	| [$17b0: ld      (hl),$30] set timer to #30
	                           	| [$17b2: inc     hl] HL := GameMode2
	move.b	#0x08,(a0)                      	| [$17b3: ld      (hl),$08] set game mode2 to 8
	rts                                    	| [$17b5: ret] return

l_17b6:
	                                    	| [$17b6: nop]

* arrive when rivets is cleared

	jbsr	clear_all_sounds_011c                            	| [$17b7: call    $011c] clear all sounds
	lea	sound_buffer_address_608a,a0   	| [$17ba: ld      hl,sound_buffer_address_608a] load HL with sound address
	move.b	#MUS_DK_FALLS,d0
	jbsr	osd_sound_start
	move.b	d0,(a0)+                      	| [$17bd: ld      (hl),$0e] play sound for rivets falling and kong beating chest
												| [$17bf: inc     hl] HL := #608B = sound duration
	move.b	#0x03,(a0)                      	| [$17c0: ld      (hl),$03] set duration to 3
	move.b	#0x10,d0                        	| [$17c2: ld      a,$10] A := #10 = code for clear space
	move.w	#0x0020,d3                      	| [$17c4: ld      de,$0020] DE := #20 32
	move.w	#0x7623,d7                      	| [$17c7: ld      hl,$7623] load HL with video RAM location
	jbsr	clear_help_0514                            	| [$17ca: call    $0514] clear "help" on left side of girl
	move.w	#0x7583,d7                      	| [$17cd: ld      hl,$7583] load HL with video RAM location
	jbsr	clear_help_0514                            	| [$17d0: call    $0514] clear "help of right side of girl
	move.w	#0x76da,d7                      	| [$17d3: ld      hl,$76da] load HL with center area of video ram
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$17d6: call    $1826] clear screen area
	lea	game_rom+0x3a47,a1                      	| [$17d9: ld      de,$3a47] load DE with start of table data
	jbsr	draw_the_screen_0da7                            	| [$17dc: call    $0da7] draw the screen
	move.w	#0x76d5,d7                      	| [$17df: ld      hl,$76d5] load HL with center area of video ram
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$17e2: call    $1826] clear screen area
	lea	game_rom+0x3a4d,a1                      	| [$17e5: ld      de,$3a4d] load DE with start of table data
	jbsr	draw_the_screen_0da7                            	| [$17e8: call    $0da7] draw the screen
	move.w	#0x76d0,d7                      	| [$17eb: ld      hl,$76d0] load HL with center area of video ram
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$17ee: call    $1826] clear screen area
	lea	game_rom+0x3a53,a1                      	| [$17f1: ld      de,$3a53] load DE with start of table data
	jbsr	draw_the_screen_0da7                            	| [$17f4: call    $0da7] draw the screen
	move.w	#0x76cb,d7                      	| [$17f7: ld      hl,$76cb] load HL with center area of video ram
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$17fa: call    $1826] clear screen area
	lea	game_rom+0x3a59,a1                      	| [$17fd: ld      de,$3a59] load DE with start of table data
	jbsr	draw_the_screen_0da7                            	| [$1800: call    $0da7] draw the screen
	lea	game_rom+0x385c,a0                      	| [$1803: ld      hl,$385c] load HL with start of kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$1806: call    $004e] update kong's sprites
	lea	start_of_kong_sprite_6908,a0   	| [$1809: ld      hl,start_of_kong_sprite_6908] load HL with start of kong sprites
	move.b	#0x44,d2                        	| [$180c: ld      c,$44] load offset of #44
	jbsr	rst_38                            	| [$180e: rst     $38] move kong
	lea	girls_sprite_6905,a0           	| [$180f: ld      hl,girls_sprite_6905] load HL with girl's sprite
	move.b	#0x13,(a0)                      	| [$1812: ld      (hl),$13] set girl's sprite
	move.b	#0x20,d0                        	| [$1814: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$1816: ld      (waittimermsb_6009),a] set timer to #20
	move.b	#0x80,d0                        	| [$1819: ld      a,$80] A := #80
	move.b	d0,timer_unknown_6390           	| [$181b: ld      (timer_unknown_6390),a] store into timer ???
	lea	end_of_level_counter_6388,a0   	| [$181e: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$1821: inc     (hl)] increase counter
	STORE_RAM_ADDRESS_LE	a0,timer_unknown_63c0           	| [$1822: ld      (timer_unknown_63c0),hl] store into ???
	rts                                    	| [$1825: ret] return

* called from several places with HL preloaded with a video RAM address
* used to clear sections of the rivets screen when it is completed

clear_sections_of_rivets_screen_1826:
	move.w	#0xffdb,d3                      	| [$1826: ld      de,$ffdb] load DE with offset for each column
	move.b	#0x0e,d2                        	| [$1829: ld      c,$0e] for C = 1 to #0E
	move.b	#0x10,d0                        	| [$182b: ld      a,$10] A := #10 (clear space on screen)

l_182d:
	move.b	#0x05,d1                        	| [$182d: ld      b,$05] for B = 1 to 5

l_182f:
	jbsr	osd_w_videoram                         	| [$182f: ld      (hl),a] store A into (HL) - clears the screen element
	addq.w	#1,d7                           	| [$1830: inc     hl] next HL
	subq.b	#1,d1                           	| [...]
	jne	l_182f                             	| [$1831: djnz    $182f] next B

	add.w	d3,d7                            	| [$1833: add     hl,de] add offset to HL
	subq.b	#1,d2                           	| [$1834: dec     c] next C
	jne	l_182d                             	| [$1835: jp      nz,$182d] loop until done

	rts                                    	| [$1838: ret] return

* arrive from #1647 when #6388 == 2

l_1839:
	lea	timer_unknown_6390,a0          	| [$1839: ld      hl,timer_unknown_6390] load HL with timer ???
	addq.b	#1,(a0)                         	| [$183c: inc     (hl)] increase.  at zero?
	jeq	l_1859                             	| [$183d: jp      z,$1859] yes, skip ahead

	move.b	(a0),d0                         	| [$1840: ld      a,(hl)] load A with the timer value
	and.b	#0x07,d0                         	| [$1841: and     $07] mask bits, now between 0 and 7.  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$1843: ret     nz] no, return [...]
0:

* kong is beating his chest after rivets have been cleared

	lea	game_rom+0x39cf,a1                      	| [$1844: ld      de,$39cf] load DE with start of table data
	btst.b	#3,(a0)                         	| [$1847: bit     3,(hl)] test bit 3.  True?
	jne	l_184e                             	| [$1849: jr      nz,$184e] Yes, skip next step

	lea	game_rom+0x39f7,a1                      	| [$184b: ld      de,$39f7] else load DE with other table start

l_184e:
	exg	a1,a0                              	| [$184e: ex      de,hl] DE <> HL
	jbsr	update_kong_sprites_004e                            	| [$184f: call    $004e] update kong's sprites
	lea	start_of_kong_sprite_6908,a0   	| [$1852: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	move.b	#0x44,d2                        	| [$1855: ld      c,$44] C := #44
	jbsr	rst_38                            	| [$1857: rst     $38] move kong
	rts                                    	| [$1858: ret] return

l_1859:
	lea	game_rom+0x385c,a0                      	| [$1859: ld      hl,$385c] load HL with start of kong graphic table data
	jbsr	update_kong_sprites_004e                            	| [$185c: call    $004e] update kong's sprites
	lea	start_of_kong_sprite_6908,a0   	| [$185f: ld      hl,start_of_kong_sprite_6908] load HL with start of Kong sprite
	move.b	#0x44,d2                        	| [$1862: ld      c,$44] C := #44
	jbsr	rst_38                            	| [$1864: rst     $38] move kong
	move.b	#0x20,d0                        	| [$1865: ld      a,$20] A := #20
	move.b	d0,waittimermsb_6009            	| [$1867: ld      (waittimermsb_6009),a] store into timer
	lea	end_of_level_counter_6388,a0   	| [$186a: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$186d: inc     (hl)] increase counter
	rts                                    	| [$186e: ret] return

* rivets has been cleared and kong is falling upside down
* arrive from #1647

l_186f:
	jbsr	rst_18                            	| [$186f: rst     $18] count down timer and only continue here if zero, else RET

	lea	game_rom+0x3a1f,a0                      	| [$1870: ld      hl,$3a1f] start of table data for kong upside down
	jbsr	update_kong_sprites_004e                            	| [$1873: call    $004e] update kong's sprites
	move.b	#0x03,d0                        	| [$1876: ld      a,$03] A := 3
	move.b	d0,play_sound_for_falling_bouncer_6084	| [$1878: ld      (play_sound_for_falling_bouncer_6084),a] play falling sound
	move.w	#BOUNCER_FALLS_SND,d0
	jbsr	osd_sound_start
	lea	end_of_level_counter_6388,a0   	| [$187b: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$187e: inc     (hl)] increase
	rts                                    	| [$187f: ret] return

* arrive from #1647 when #6388 == 4

l_1880:
	lea	kong_sprite_array_690b,a0      	| [$1880: ld      hl,kong_sprite_array_690b] load HL with kong start sprite
	move.b	#0x01,d2                        	| [$1883: ld      c,$01] load C with 1 pixel to move
	jbsr	rst_38                            	| [$1885: rst     $38] move kong
	move.b	unknown_691b,d0                 	| [$1886: ld      a,(unknown_691b)] load A with ???
	cmp.b	#0xd0,d0                         	| [$1889: cp      $d0] == #D0 ?
	beq.b	0f                               	| [...]
	rts                                    	| [$188b: ret     nz] no, return [...]
0:

	move.b	#0x20,d0                        	| [$188c: ld      a,$20] A := #20
	move.b	d0,unknown_6919                 	| [$188e: ld      (unknown_6919),a] store into kong's face sprite - kong is now bigmouthed with crazy eyes
	lea	sprite_address_used_for_kong_aching_head_lines_6a24,a0	| [$1891: ld      hl,sprite_address_used_for_kong_aching_head_lines_6a24] load HL with sprite address used for kong's aching head lines
	move.b	#0x7f,(a0)+                      	| [$1894: ld      (hl),$7f] set sprite X value
	                           	| [$1896: inc     l] next
	move.b	#0x39,(a0)+                      	| [$1897: ld      (hl),$39] set sprite color
	                           	| [$1899: inc     l] next
	move.b	#0x01,(a0)+                      	| [$189a: ld      (hl),$01] set sprite value
	                           	| [$189c: inc     l] next
	move.b	#0xd8,(a0)+                      	| [$189d: ld      (hl),$d8] set sprite Y value
	move.w	#0x76c6,d7                      	| [$189f: ld      hl,$76c6] load HL with start of screen location to clear
	jbsr	clear_sections_of_rivets_screen_1826                            	| [$18a2: call    $1826] clear the top part of rivets
	lea	game_rom+0x3a5f,a1                      	| [$18a5: ld      de,$3a5f] load DE with table data for sections to clear after rivets done
	jbsr	draw_the_screen_0da7                            	| [$18a8: call    $0da7] draw the top girder where mario and girl meet

	move.w	#0x0004,d3                      	| [$18ab: ld      de,$0004] load counters 4
	move.b	#0x02,d1                        	| [$18ae: ld      bc,$0228] load counters 552
	move.b	#0x28,d2                        	| [$18ae: ld      bc,$0228] load counters 552
	lea	sprite_girl_table_data_y_position_6903,a0	| [$18b1: ld      hl,sprite_girl_table_data_y_position_6903] set sprite girl table data Y position
	jbsr	l_003d                            	| [$18b4: call    $003d] move the girl down

	clr.b	d0                               	| [$18b7: ld      a,$00] A := 0 [why written this way?]
	move.b	d0,kong_misc_counter_62af   	| [$18b9: ld      (kong_misc_counter_62af),a] store into kong climbing counter
	move.b	#0x03,d0                        	| [$18bc: ld      a,$03] set boom sound duration
	move.b	d0,boom_sound_address_6082      	| [$18be: ld      (boom_sound_address_6082),a] play boom sound
	lea	end_of_level_counter_6388,a0   	| [$18c1: ld      hl,end_of_level_counter_6388] load HL with end of level counter
	addq.b	#1,(a0)                         	| [$18c4: inc     (hl)] increase counter
	rts                                    	| [$18c5: ret] return

* arrive from #1647 when level is complete, last of 5 steps

l_18c6:
	lea	kong_misc_counter_62af,a0  	| [$18c6: ld      hl,kong_misc_counter_62af] load HL with kong climbing counter address
	subq.b	#1,(a0)                         	| [$18c9: dec     (hl)] decrease.  zero?
	jeq	l_193d                             	| [$18ca: jp      z,$193d] yes, skip ahead, handle next level routine

	move.b	(a0),d0                         	| [$18cd: ld      a,(hl)] load A with kong climbing counter
	and.b	#0x07,d0                         	| [$18ce: and     $07] mask bits, now between 0 and 7.  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$18d0: ret     nz] no , return [...]
0:

	lea	unknown_6a25,a0                	| [$18d1: ld      hl,unknown_6a25] load HL with ???
	move.b	(a0),d0                         	| [$18d4: ld      a,(hl)] get value
	eor.b	#0x80,d0                         	| [$18d5: xor     $80] toggle bit 7
	move.b	d0,(a0)                         	| [$18d7: ld      (hl),a] store result

	lea	unknown_6919,a0                	| [$18d8: ld      hl,unknown_6919] load HL with ???
	move.b	(a0),d1                         	| [$18db: ld      b,(hl)] load B with this value
	bclr.b	#5,d1                           	| [$18dc: res     5,b] clear bit 5 of B
	clr.b	d0                               	| [$18de: xor     a] A := 0
	jbsr	l_3009                            	| [$18df: call    $3009] ???
	or.b	#0x20,d0                          	| [$18e2: or      $20] turn on bit 5
	move.b	d0,(a0)                         	| [$18e4: ld      (hl),a] store result

	lea	kong_misc_counter_62af,a0  	| [$18e5: ld      hl,kong_misc_counter_62af] load HL with kong climbing counter
	move.b	(a0),d0                         	| [$18e8: ld      a,(hl)] get value
	cmp.b	#0xe0,d0                         	| [$18e9: cp      $e0] == #E0 ?
	jne	l_1910                             	| [$18eb: jp      nz,$1910] no, skip ahead

	move.b	#0x50,d0                        	| [$18ee: ld      a,$50] A := #50
	move.b	d0,mario_sprite_y_value_694f    	| [$18f0: ld      (mario_sprite_y_value_694f),a] store into mario sprite Y value
	clr.b	d0                               	| [$18f3: ld      a,$00] A := 0
	move.b	d0,mario_sprite_value_694d      	| [$18f5: ld      (mario_sprite_value_694d),a] store into mario sprite value
	move.b	#0x9f,d0                        	| [$18f8: ld      a,$9f] A := #9F
	move.b	d0,mario_sprite_x_position_694c 	| [$18fa: ld      (mario_sprite_x_position_694c),a] set mario sprite X value at #9F
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$18fd: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario X position
	cmp.b	#0x80,d0                         	| [$1900: cp      $80] < 80 ?
	jcc	l_190f                             	| [$1902: jp      nc,$190f] yes, skip next 4 steps

	move.b	#0x80,d0                        	| [$1905: ld      a,$80] A := #80
	move.b	d0,mario_sprite_value_694d      	| [$1907: ld      (mario_sprite_value_694d),a] store into mario sprite value
	move.b	#0x5f,d0                        	| [$190a: ld      a,$5f] A := #5F
	move.b	d0,mario_sprite_x_position_694c 	| [$190c: ld      (mario_sprite_x_position_694c),a] store into mario sprite X value

l_190f:
	move.b	(a0),d0                         	| [$190f: ld      a,(hl)] load A with ???

l_1910:
	cmp.b	#0xc0,d0                         	| [$1910: cp      $c0] == #C0 ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1912: ret     nz] no, return [...]
0:

	lea	sound_buffer_address_608a,a0   	| [$1913: ld      hl,sound_buffer_address_608a] load HL with sound address
	move.b	#MUS_ENDING2,d7                      	| [$1916: ld      (hl),$0c] play sound for rivets cleared
	move.b	level_number_6229,d0       	| [$1918: ld      a,(level_number_6229)] load A with level #
	ror.b	#1,d0                            	| [$191b: rrca] roll a right .  is this an odd level ?
	jcs	l_1920                             	| [$191c: jr      c,$1920] Yes, skip next step
	move.b	#MUS_ENDING1,d7
l_1920:
	move.b	d7,(a0)                      	| [$191e: ld      (hl),$05] else play sound for even numbered rivets
	move.b	d7,d0
	jbsr	osd_sound_start
	addq.w	#1,a0                           	| [$1920: inc     hl] HL := #608B = sound duration
	move.b	#0x03,(a0)                      	| [$1921: ld      (hl),$03] set duration to 3
	lea	heart_sprite_6a23,a0           	| [$1923: ld      hl,heart_sprite_6a23] load HL with heart sprite
	move.b	#0x40,(a0)                      	| [$1926: ld      (hl),$40] set heart sprite Y position
                           	| [$1928: dec     hl] decrement HL
	move.b	#0x09,-(a0)                      	| [$1929: ld      (hl),$09] set heart sprite color
                           	| [$192b: dec     hl] decrement HL
	move.b	#0x76,-(a0)                      	| [$192c: ld      (hl),$76] set heart sprite
                           	| [$192e: dec     hl] decrement HL
	move.b	#0x8f,-(a0)                      	| [$192f: ld      (hl),$8f] set heart sprite X position
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1931: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario X position
	cmp.b	#0x80,d0                         	| [$1934: cp      $80] is mario on the left side of the screen?
	bcs.b	0f                               	| [...]
	rts                                    	| [$1936: ret     nc] yes, return [...]
0:

	move.b	#0x6f,d0                        	| [$1937: ld      a,$6f] else A := #6F
	move.b	d0,heart_sprite_x_position_6a20 	| [$1939: ld      (heart_sprite_x_position_6a20),a] store A into heart sprite X position
	rts                                    	| [$193c: ret] return from sub

* kong has climbed off the screen at end of level

l_193d:
	LOAD_ROM_ADDRESS_LE	store_622a,a0               	| [$193d: ld      hl,(store_622a)] load HL with contents of #622A.  this is a pointer to the levels/screens data
	addq.w	#1,a0                           	| [$1940: inc     hl] increase HL.  = next level
	move.b	(a0),d0                         	| [$1941: ld      a,(hl)] load A with contents of HL = the screen we are going to play next
	cmp.b	#0x7f,d0                         	| [$1942: cp      $7f] is this the end code ?
	jne	l_194b                             	| [$1944: jp      nz,$194b] no, skip next 2 steps

	lea	game_rom+0x3a73,a0                      	| [$1947: ld      hl,$3a73] yes, load HL with #3A73 = start of table data for screens/levels for level 5+
	move.b	(a0),d0                         	| [$194a: ld      a,(hl)] load A with screen number from table

l_194b:
	STORE_ROM_ADDRESS_LE	a0,store_622a                   	| [$194b: ld      (store_622a),hl] store
	move.b	d0,screen_number_6227           	| [$194e: ld      (screen_number_6227),a] store A into screen number
	lea	level_number_6229,a0      	| [$1951: ld      hl,level_number_6229] load HL with level number address
	addq.b	#1,(a0)                         	| [$1954: inc     (hl)] increase #6229 by one
	move.w  #0x0500,d3                      	| [$1955: ld      de,$0500] load task #5, parameter 0 | adds bonus to player's score
	jbsr	insert_task_309f                            	| [$1958: call    $309f] insert task
	clr.b	d0                               	| [$195b: xor     a] A := 0
	move.b	d0,number_of_goofys_to_draw_622e	| [$195c: ld      (number_of_goofys_to_draw_622e),a] store into number of goofys to draw
	move.b	d0,end_of_level_counter_6388    	| [$195f: ld      (end_of_level_counter_6388),a] store into end of level counter
	lea	waittimermsb_6009,a0           	| [$1962: ld      hl,waittimermsb_6009] load HL with timer
	move.b	#0xe0,(a0)+                      	| [$1965: ld      (hl),$e0] set timer to #E0
	                           	| [$1967: inc     hl] increase HL to GameMode2
	move.b	#0x08,(a0)                      	| [$1968: ld      (hl),$08] set game mode2 to 8
	rts                                    	| [$196a: ret] return

* arrive from jump table at #0701 when GameMode2 == #17

l_196b:
	jbsr	l_0852                            	| [$196b: call    $0852] clear screen and all sprites
	move.b	playerturnb_600e,d0             	| [$196e: ld      a,(playerturnb_600e)] load A with current player number.  0 = player 1, 1 = player 2
	add.b	#0x12,d0                         	| [$1971: add     a,$12] add #12
	move.b	d0,gamemode2_600a               	| [$1973: ld      (gamemode2_600a),a] store into game mode2, now had #12 for player 1 or #13 for player 2
	rts                                    	| [$1976: ret] return

* main routine

l_1977:
	jbsr	l_21ee                            	| [$1977: call    $21ee] used during attract mode only.  sets virtual input.

* arrive here from #0701 when playing

l_197a:
	jbsr	check_for_bonus_items_1dbd                            	| [$197a: call    $1dbd] check for bonus items and jumping scores, rivets
	jbsr	handle_item_hit_with_hammer_1e8c                            	| [$197d: call    $1e8c] do stuff for items hit with hammer
	jbsr	l_1ac3                            	| [$1980: call    $1ac3] check for jumping
	jbsr	handle_barrel_rolls_1f72         	| [$1983: call    $1f72] roll barrels
	jbsr	handle_barrel_rolls_2c8f 	     	| [$1986: call    $2c8f] roll barrels ?
	jbsr	l_2c03                            	| [$1989: call    $2c03] do barrel deployment ?
	jbsr	l_30ed                            	| [$198c: call    $30ed] update fires if needed
	jbsr	update_bouncers_if_on_elevators_2e04 | [$198f: call    $2e04] update bouncers if on elevators
	jbsr	l_24ea                            	| [$1992: call    $24ea] do stuff for pie factory
	jbsr	l_2ddb                            	| [$1995: call    $2ddb] deploy fireball/firefoxes for conveyors and rivets
	jbsr	handle_hammer_2ed4                	| [$1998: call    $2ed4] do stuff for hammer
	jbsr	l_2207                            	| [$199b: call    $2207] do stuff for conveyors
	jbsr	check_running_over_rivets_1a33    	| [$199e: call    $1a33] check for and handle running over rivets
	jbsr	check_for_mario_falling_2a85        | [$19a1: call    $2a85] check for mario falling
	jbsr	handle_mario_falling_1f46           | [$19a4: call    $1f46] handle mario falling
	jbsr	handle_elevators_26fa                            	| [$19a7: call    $26fa] do stuff for elevators
	jbsr	l_25f2                            	| [$19aa: call    $25f2] handle conveyor directions, adjust Mario's speed based on conveyor directions
	jbsr	check_bonus_items_pick_19da                            	| [$19ad: call    $19da] check for mario picking up bonus item
	jbsr	l_03fb                            	| [$19b0: call    $03fb] check for kong beating chest and animate girl and her screams
	jbsr	l_2808                            	| [$19b3: call    $2808] check for collisions with hostile sprites [set to NOPS to make mario invincible to enemy sprites]
	jbsr	handle_hammer_281d                            	| [$19b6: call    $281d] do stuff for hammers
	jbsr	l_1e57                            	| [$19b9: call    $1e57] check for end of level
	jbsr	l_1a07                            	| [$19bc: call    $1a07] handle when the bonus timer has run out
	jbsr	l_2fcb                            	| [$19bf: call    $2fcb] for non-girder levels, checks for bonus timer changes. if the bonus counts down, sets a possible new fire to be released,
                                        * sets a bouncer to be deployed, updates the bonus timer onscreen, and checks for bonus time running out
	nop                                    	| [$19c2: nop]
	nop                                    	| [$19c3: nop]
	nop                                    	| [$19c4: nop] no operations.  [a deleted call ?]

	move.b	mario_array_6200,d0             	| [$19c5: ld      a,(mario_array_6200)] load A with 0 if mario is dead, 1 if he is alive
	                               	| [$19c8: and     a] is mario alive?
	beq.b	0f                               	| [...]
	rts                                    	| [$19c9: ret     nz] yes, return to #00D2 [...]
0:

* mario died

	jbsr	clear_all_sounds_011c                            	| [$19ca: call    $011c] no, mario died.  clear all sounds
	lea	boom_sound_address_6082,a0     	| [$19cd: ld      hl,boom_sound_address_6082] load HL with boom sound address
	move.b	#0x03,(a0)                      	| [$19d0: ld      (hl),$03] play boom sound for 3 units
l_19d2:
	lea	gamemode2_600a,a0              	| [$19d2: ld      hl,gamemode2_600a] load HL with game mode2
	addq.b	#1,(a0)                         	| [$19d5: inc     (hl)] increase
	subq.w	#1,a0                           	| [$19d6: dec     hl] HL := WaitTimerMSB (timer used for sound effects)
	move.b	#0x40,(a0)                      	| [$19d7: ld      (hl),$40] set timer to wait 40 units
	rts                                    	| [$19d9: ret] return to #00D2

* called from #19AD as part of the main routine
* checks for bonus items being picked up

check_bonus_items_pick_19da:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$19da: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with Mario's X position
	move.b	#0x03,d1                        	| [$19dd: ld      b,$03] for B = 1 to 3
	lea	start_of_bonus_items_6a0c,a0   	| [$19df: ld      hl,start_of_bonus_items_6a0c] load HL with X position of first bonus

l_19e2:
	cmp.b	(a0),d0                          	| [$19e2: cp      (hl)] are they equal?
	jeq	l_19ed                             	| [$19e3: jp      z,$19ed] yes, then test the Y position too

	addq.w	#4,a0                           	| [$19e6: inc     l] * 4
	subq.b	#1,d1                           	| [...]
	jne	l_19e2                             	| [$19ea: djnz    $19e2] Loop 3 times, check for the 3 items

	rts                                    	| [$19ec: ret] return

l_19ed:
	move.b	mario_y_position_6205,d0	| [$19ed: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	addq.w	#3,a0                           	| [$19f0: inc     l] * 3
	cmp.b	(a0),d0                          	| [$19f3: cp      (hl)] are they equal?
	beq.b	0f                               	| [...]
	rts                                    	| [$19f4: ret     nz] no, return from this test [...]
0:

	subq.w	#2,a0                           	| [$19f5: dec     l] yes, decrement L 2 times to check if this item has already been picked up * 2
	btst.b	#3,(a0)                         	| [$19f7: bit     3,(hl)] test bit 3 of HL, tells whether picked up already or not.  Item not already picked up?
	beq.b	0f                               	| [...]
	rts                                    	| [$19f9: ret     nz] Item picked up already, then return [...]
0:

* bonus item has been picked up

	subq.w	#1,a0                           	| [$19fa: dec     l] decrease L.  HL now has the starting address of the sprite that was picked up
	STORE_RAM_ADDRESS_LE	a0,unknown_for_use_later_6343   	| [$19fb: ld      (unknown_for_use_later_6343),hl] store into this temp memory.  read from at #1E18
	clr.b	d0                               	| [$19fe: xor     a] A := 0
	move.b	d0,scoring_indicator_6342       	| [$19ff: ld      (scoring_indicator_6342),a] store into ???.  read from at #1DD6
	addq.b	#1,d0                           	| [$1a02: inc     a] A := 1
	move.b	d0,bonus_indicator_6340         	| [$1a03: ld      (bonus_indicator_6340),a] store into #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears
	rts                                    	| [$1a06: ret] return

* called from main routine at #19BC

l_1a07:
	move.b	time_has_run_out_indicator_6386,d0	| [$1a07: ld      a,(time_has_run_out_indicator_6386)] load A with the location which tells if the timer has run out yet.
	jbsr	rst_28                            	| [$1a0a: rst     $28] jump based on A

	.long	l_1a1e| #1A1E if zero return immediately, bonus timer has not run out
	.long	l_1a15| #1A15
	.long	l_1a1f| #1A1F
	.long	l_1a2a| #1A2A
	.long	0	| used

* arrive from #1A0A
l_1a15:
	clr.b	d0                               	| [$1a15: xor     a] A := 0
	move.b	d0,timer_address_6387           	| [$1a16: ld      (timer_address_6387),a] clear timer which counts down when the timer runs out
	move.b	#0x02,d0                        	| [$1a19: ld      a,$02] A := 2
	move.b	d0,time_has_run_out_indicator_6386	| [$1a1b: ld      (time_has_run_out_indicator_6386),a] store into the location which tells if the timer has run out yet.
l_1a1e:
	rts                                    	| [$1a1e: ret] return

* arrive from #1A0A
l_1a1f:
	lea	timer_address_6387,a0          	| [$1a1f: ld      hl,timer_address_6387] load HL with timer address
	subq.b	#1,(a0)                         	| [$1a22: dec     (hl)] decreases the timer which counts down after time has run out. time out?
	beq.b	0f                               	| [...]
	rts                                    	| [$1a23: ret     nz] no, return [...]
0:

	move.b	#0x03,d0                        	| [$1a24: ld      a,$03] A := 3
	move.b	d0,time_has_run_out_indicator_6386	| [$1a26: ld      (time_has_run_out_indicator_6386),a] store 3 into #6386 - time is up for mario!
	rts                                    	| [$1a29: ret] return

* we arrive here when the timer runs out
l_1a2a:
	move.b	jumping_status_6216,d0          	| [$1a2a: ld      a,(jumping_status_6216)] load A with jump indicator
	                               	| [$1a2d: and     a] is mario jumping ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1a2e: ret     nz] yes, return, mario never dies while jumping [...]
0:

	move.l	(sp)+,a0                        	| [$1a2f: pop     hl] no, pop HL to return to higher subroutine
	jra	l_19d2                             	| [$1a30: jp      $19d2] jump to mario died and return

* called from main routine
* check for running over rivets ?

check_running_over_rivets_1a33:
	move.b	#0x08,d0                        	| [$1a33: ld      a,$08] A := 8 = 1000 binary = code for rivets
	jbsr	only_continues_if_given_level_0030                            	| [$1a35: rst     $30] continue here only on rivets, else RET

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1a36: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	cmp.b	#0x4b,d0                         	| [$1a39: cp      $4b] == #4B = the column the left rivets are on ?
	jeq	l_1a4b                             	| [$1a3b: jp      z,$1a4b] yes, skip ahead and set the indicator

	cmp.b	#0xb3,d0                         	| [$1a3e: cp      $b3] == #B3 = the column the right rivets are on ?
	jeq	l_1a4b                             	| [$1a40: jp      z,$1a4b] yes, skip ahead and set the indicator

	move.b	column_indicator_6291,d0        	| [$1a43: ld      a,(column_indicator_6291)] else load A with rivet column indicator
	subq.b	#1,d0                           	| [$1a46: dec     a] is mario possibly traversing a column?
	jeq	l_1a51                             	| [$1a47: jp      z,$1a51] yes, skip ahead
	rts                                    	| [$1a4a: ret] else return

l_1a4b:
	move.b	#0x01,column_indicator_6291                        	| [$1a4b: ld      a,$01] A := 1
										| [$1a4d: ld      (column_indicator_6291),a] store into column indicator
	rts                                    	| [$1a50: ret] return

l_1a51:
	clr.b	column_indicator_6291        	| [$1a51: ld      (column_indicator_6291),a] clear the column indicator
	clr.b	d1                           	| [$1a54: ld      b,a] B := 0
	move.b	mario_y_position_6205,d0	| [$1a55: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	subq.b	#1,d0                           	| [$1a58: dec     a] decrement
	cmp.b	#0xd0,d0                         	| [$1a59: cp      $d0] compare with #D0.  is mario too low to go over a rivet?
	bcs.b	0f                               	| [...]
	rts                                    	| [$1a5b: ret     nc] yes, return [...]
0:

	rol.b	#1,d0                            	| [$1a5c: rlca] rotate left = mult by 2
	jcc	l_1a62                             	| [$1a5d: jp      nc,$1a62] no carry, skip next step

	bset.b	#2,d1                           	| [$1a60: set     2,b] else B := 4

l_1a62:
												| [$1a62: rlca]
	rol.b	#2,d0                            	| [$1a63: rlca] rotate left twice = mult by 4
	jcc	l_1a69                             	| [$1a64: jp      nc,$1a69] no carry, skip next step

	bset.b	#1,d1                           	| [$1a67: set     1,b] B := B + 2
l_1a69:
	and.b	#0x07,d0                         	| [$1a69: and     $07] mask bits in A, now between 0 and 7
	cmp.b	#0x06,d0                         	| [$1a6b: cp      $06] == 6 ?
	jne	l_1a72                             	| [$1a6d: jp      nz,$1a72] no, skip next step

	bset.b	#1,d1                           	| [$1a70: set     1,b] else set this bit
l_1a72:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1a72: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	rol.b	#1,d0                            	| [$1a75: rlca] rotate left
	jcc	l_1a7b                             	| [$1a76: jp      nc,$1a7b] no carry, skip next step

	bset.b	#0,d1                           	| [$1a79: set     0,b] B := B + 1
l_1a7b:
	and.w	#0xFF,d1
	lea	start_of_array_of_rivets_6292,a0	| [$1a7b: ld      hl,start_of_array_of_rivets_6292] load HL with start of array of rivets
	                           	| [$1a7e: ld      a,b] A := B
	add.w	d1,a0                            	| [$1a7f: add     a,l] add #92
	                           	| [$1a80: ld      l,a] copy to L
	move.b	(a0),d0                         	| [$1a81: ld      a,(hl)] get the status of the rivet mario is crossing
	                               	| [$1a82: and     a] has this rivet already been traversed?
	bne.b	0f                               	| [...]
	rts                                    	| [$1a83: ret     z] yes, return [...]
0:

* a rivet has been traversed: clear rivet
	clr.b	(a0)                             	| [$1a84: ld      (hl),$00] set this rivet as cleared
												| [$1a86: ld      hl,number_of_rivets_left_6290] load HL with address of number of rivets remaining
	subq.b	#1,number_of_rivets_left_6290                         	| [$1a89: dec     (hl)] decrease number of rivets
	move.b	d1,d0                           	| [$1a8a: ld      a,b] A := B
	move.w	#0x05,d1                        	| [$1a8b: ld      bc,$0005] load BC with offset of 5
	* ror doesn't work, makes value $8x ! using the 9-bit rotation that we don't have!
	lsr.b	#1,d0                           	| [$1a8e: rra] rotate right.  carry?  (is this rivet on right side?)
	jcs	l_1abd                             	| [$1a8f: jp      c,$1abd] yes, skip ahead and load HL with #012B and return to #1A95

	move.w	#0x02cb,d7                      	| [$1a92: ld      hl,$02cb] else load HL with master offset for rivets

l_1a95:
	tst.b	d0                               	| [$1a95: and     a] A == 0 ?
	jeq	l_1a9e                             	| [$1a96: jp      z,$1a9e] yes, skip next 3 steps

l_1a99:
	add.w	d1,d7                            	| [$1a99: add     hl,bc] add column offset to HL
	subq.b	#1,d0                           	| [$1a9a: dec     a] decrease A.  zero?
	jne	l_1a99                             	| [$1a9b: jp      nz,$1a99] no, loop again

l_1a9e:
	.ifeq	OPT_LEAVE_RIVETS
	                        	| [$1a9e: ld      bc,$7400] start of video RAM is #7400 29696
	add.w	#0x7400,d7                            	| [$1aa1: add     hl,bc] add offset computed based on which rivet is cleared
	move.b	#0x10,d0                        	| [$1aa2: ld      a,$10] A := #10 = clear space
	jbsr	osd_w_videoram                         	| [$1aa4: ld      (hl),a] erase the rivet
	                           	| [$1aa5: dec     l] next video memory
	subq.w	#1,d7
	jbsr	osd_w_videoram                         	| [$1aa6: ld      (hl),a] erase the top of the rivet
	addq.w	#2,d7                           	| [$1aa7: inc     l] * 2
	jbsr	osd_w_videoram                         	| [$1aa9: ld      (hl),a] erase underneath the rivet [ not needed , there is nothing there to erase ???]
	.endif
	
	move.b	#0x01,d0                        	| [$1aaa: ld      a,$01] A := 1
	move.b	d0,bonus_indicator_6340         	| [$1aac: ld      (bonus_indicator_6340),a] store into #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears
	move.b	d0,scoring_indicator_6342       	| [$1aaf: ld      (scoring_indicator_6342),a] store into scoring indicator
	move.b	d0,bonus_sound_indicator_6225   	| [$1ab2: ld      (bonus_sound_indicator_6225),a] store into bonus sound indicator
	move.b	jumping_status_6216,d0          	| [$1ab5: ld      a,(jumping_status_6216)] load A with jump indicator
	                               	| [$1ab8: and     a] is mario jumping ?
	bne.b	0f                               	| [...]
	jbsr	play_bonus_sound_1d95                            	| [$1ab9: call    z,$1d95] no, play the bonus sound
0:

	rts                                    	| [$1abc: ret] else return

* arrive from #1A8F above

l_1abd:
	move.w	#0x012b,d7                      	| [$1abd: ld      hl,$012b] load HL with alternate master offset for rivets
	jra	l_1a95                             	| [$1ac0: jp      $1a95] jump back to program and resume

* check for jumping and other movements
* called from main routine at #1980

l_1ac3:
	move.b	jumping_status_6216,d0          	| [$1ac3: ld      a,(jumping_status_6216)] load A with jump indicator
	subq.b	#1,d0                           	| [$1ac6: dec     a] is mario already jumping?
	jeq	l_1bb2                             	| [$1ac7: jp      z,$1bb2] yes, jump ahead

	move.b	jump_coming_down_indicator_621e,d0	| [$1aca: ld      a,(jump_coming_down_indicator_621e)] else load A with jump coming down indicator
	                               	| [$1acd: and     a] is the jump almost done ?
	jne	l_1b55                             	| [$1ace: jp      nz,$1b55] yes, skip way ahead

	move.b	hammer_active_6217,d0                 	| [$1ad1: ld      a,(hammer_active_6217)] load A with hammer check
	subq.b	#1,d0                           	| [$1ad4: dec     a] is hammer active?
	jeq	l_1ae6                             	| [$1ad5: jp      z,$1ae6] yes, skip ahead

	move.b	ladder_status_6215,d0           	| [$1ad8: ld      a,(ladder_status_6215)] else load A with ladder check
	subq.b	#1,d0                           	| [$1adb: dec     a] is mario on a ladder?
	jeq	l_1b38                             	| [$1adc: jp      z,$1b38] yes, skip ahead

	move.b	inputstate_6010,d0              	| [$1adf: ld      a,(inputstate_6010)] load A with input
	rol.b	#1,d0                           	| [$1ae2: rla] is player pressing jump ?
 	jcs	l_1b6e                             	| [$1ae3: jp      c,$1b6e] yes, begin jump subroutine

l_1ae6:
	jbsr	l_241f                            	| [$1ae6: call    $241f] else call this other sub which loads DE with something depending on mario's position.  ladder check?

	move.b	inputstate_6010,d0              	| [$1ae9: ld      a,(inputstate_6010)] load A with input
	subq.b	#1,d4                           	| [$1aec: dec     e] E == 1 ?
	jeq	l_1af5                             	| [$1aed: jp      z,$1af5] yes, jump ahead

	btst.b	#0,d0                           	| [$1af0: bit     0,a] test bit 0 of input.  is player pressing right ?
	jne	l_1c8f                             	| [$1af2: jp      nz,$1c8f] yes, skip ahead

l_1af5:
	subq.b	#1,d3                           	| [$1af5: dec     d] else is D == 1 ?
	jeq	l_1afe                             	| [$1af6: jp      z,$1afe] yes, skip ahead

	btst.b	#1,d0                           	| [$1af9: bit     1,a] is player pressing left ?
	jne	l_1cab                             	| [$1afb: jp      nz,$1cab] yes, skip ahead

l_1afe:
	move.b	hammer_active_6217,d0                 	| [$1afe: ld      a,(hammer_active_6217)] else load A with hammer check
	subq.b	#1,d0                           	| [$1b01: dec     a] is the hammer active?
	bne.b	0f                               	| [...]
	rts                                    	| [$1b02: ret     z] yes, return [...]
0:

	move.b	mario_y_position_6205,d0	| [$1b03: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	add.b	#0x08,d0                         	| [$1b06: add     a,$08] Add 8
	move.b	d0,d3                           	| [$1b08: ld      d,a] copy into D
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1b09: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with Mario's X position
	or.b	#0x03,d0                          	| [$1b0c: or      $03] turn on left 2 bits (0 and 1)
	bclr.b	#2,d0                           	| [$1b0e: res     2,a] turn off bit 2
	move.w	#0x15,d1                        	| [$1b10: ld      bc,$0015] load BC with #15 = number of ladders to check 21
	jbsr	check_for_ladders_nearby_236e                            	| [$1b13: call    $236e] check for ladders nearby if none, RET to higher sub.  else A := 0 if at bottom of ladder, A := 1 if at top.  C has the ladder number/type?

* mario is near a ladder

	move.w	d0,-(sp)                        	| [$1b16: push    af] save AF for later
	lea	mario_movement_indicator_sprite_value_6207,a0	| [$1b17: ld      hl,mario_movement_indicator_sprite_value_6207] load HL with movement indicator
	move.b	(a0),d0                         	| [$1b1a: ld      a,(hl)] load movement
	and.b	#0x80,d0                         	| [$1b1b: and     $80] mask bits
	or.b	#0x06,d0                          	| [$1b1d: or      $06] mask bits
	move.b	d0,(a0)                         	| [$1b1f: ld      (hl),a] store movement
	lea	moving_ladder_indicator_621a,a0	| [$1b20: ld      hl,moving_ladder_indicator_621a] load HL with ladder type address
	move.b	#0x04,d0                        	| [$1b23: ld      a,$04] A := 4
	move.b	#0x01,(a0)                      	| [$1b26: ld      (hl),$01] store 1 into ladder type = broken ladder by default
	cmp.b	d2,d0                            	| [$1b25: cp      c] compare.  is the ladder broken?
	jcc	l_1b2c                             	| [$1b28: jp      nc,$1b2c] if ladder broken, skip next step

	subq.b	#1,(a0)                         	| [$1b2b: dec     (hl)] set indicator to unbroken ladder

l_1b2c:
	move.w	(sp)+,d0                        	| [$1b2c: pop     af] restore AF
	tst.b	d0                               	| [$1b2d: and     a] A == 0 ?  is mario at bottom of ladder?
	jeq	l_1b4e                             	| [$1b2e: jp      z,$1b4e] yes, skip ahead

* else mario at top of ladder

	move.b	(a0),d0                         	| [$1b31: ld      a,(hl)] load A with broken ladder indicator
	                               	| [$1b32: and     a] is this ladder broken?
	beq.b	0f                               	| [...]
	rts                                    	| [$1b33: ret     nz] yes, return.  we can't go down broken ladders [...]
0:

* top of unbroken ladder

	addq.w	#1,a0                           	| [$1b34: inc     l] next HL := #621B
	move.b	d3,(a0)+                         	| [$1b35: ld      (hl),d] store D
												| [$1b36: inc     l] next HL := #621C
	move.b	d1,(a0)                         	| [$1b37: ld      (hl),b] store B

* if mario is on a ladder
* jump here from #1ADC

l_1b38:
	move.b	inputstate_6010,d0              	| [$1b38: ld      a,(inputstate_6010)] load A with input
	btst.b	#3,d0                           	| [$1b3b: bit     3,a] is joystick pushed down ?
	jne	l_1cf2                             	| [$1b3d: jp      nz,$1cf2] yes, skip ahead to handle

	move.b	ladder_status_6215,d0           	| [$1b40: ld      a,(ladder_status_6215)] load A with ladder status
	                               	| [$1b43: and     a] is mario on a ladder?
	bne.b	0f                               	| [...]
	rts                                    	| [$1b44: ret     z] no, return [...]
0:

l_1b45:
	move.b	inputstate_6010,d0              	| [$1b45: ld      a,(inputstate_6010)] load A with input
	btst.b	#2,d0                           	| [$1b48: bit     2,a] is joystick pushed up ?
	jne	l_1d03                             	| [$1b4a: jp      nz,$1d03] yes, skip ahead to handle

	rts                                    	| [$1b4d: ret] else return

* mario is next to bottom of ladder

l_1b4e:
	addq.w	#1,a0                           	| [$1b4e: inc     l] next HL := #621B
	move.b	d1,(a0)+                         	| [$1b4f: ld      (hl),b] store B
	                           	| [$1b50: inc     l] next HL := #621C
	move.b	d3,(a0)                         	| [$1b51: ld      (hl),d] store D
	jra	l_1b45                             	| [$1b52: jp      $1b45] loop back

l_1b55:
	lea	jump_coming_down_indicator_621e,a0	| [$1b55: ld      hl,jump_coming_down_indicator_621e] load HL with jump coming down indicator
	subq.b	#1,(a0)                         	| [$1b58: dec     (hl)] decrease.  is it zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1b59: ret     nz] no, return [...]
0:

* arrive here when jump is complete

	move.b	mario_is_grabbing_the_hammer_until_he_lands_6218,d0	| [$1b5a: ld      a,(mario_is_grabbing_the_hammer_until_he_lands_6218)] load A with hammer grabbing indicator
	move.b	d0,hammer_active_6217                 	| [$1b5d: ld      (hammer_active_6217),a] store into hammer indicator
	lea	mario_movement_indicator_sprite_value_6207,a0	| [$1b60: ld      hl,mario_movement_indicator_sprite_value_6207] load HL with movement indicator address
	move.b	(a0),d0                         	| [$1b63: ld      a,(hl)] load A with movement indicator
	and.b	#0x80,d0                         	| [$1b64: and     $80] mask bits.  we only care about bit 7, which we leave as is.  all other bits are now zero
	move.b	d0,(a0)                         	| [$1b66: ld      (hl),a] store into movement indicator.  mario is no longer jumping
	clr.b	d0                               	| [$1b67: xor     a] A := 0
	move.b	d0,put_back_6202                	| [$1b68: ld      (put_back_6202),a] set mario animation state to 0
	jra	update_mario_sprite_1da6                             	| [$1b6b: jp      $1da6] jump ahead to update mario sprite and RET

* jump initiated.  arrive from #1AE3 when jump pressed and jump not already underway etc.

l_1b6e:
	move.b	#0x01,d0                        	| [$1b6e: ld      a,$01] A := 1
	move.b	d0,jumping_status_6216          	| [$1b70: ld      (jumping_status_6216),a] set jump indicator
	lea	mario_jump_direction_6210,a0   	| [$1b73: ld      hl,mario_jump_direction_6210] load HL with mario's jump direction address
	move.b	inputstate_6010,d0              	| [$1b76: ld      a,(inputstate_6010)] load A with copy of input
	move.b	#0x00,d1                        	| [$1b79: ld      bc,$0080] B:= 0, C := #80 = codes for jumping right 128
	move.b	#0x80,d2                        	| [$1b79: ld      bc,$0080] B:= 0, C := #80 = codes for jumping right 128
	ror.b	#1,d0                           	| [$1b7c: rra] rotate input right.  is joystick moved right ?
	jcs	l_1b8a                             	| [$1b7d: jp      c,$1b8a] yes, skip ahead

* jumping left or straight up

	move.b	#0xff,d1                        	| [$1b80: ld      bc,$ff80] B := #FF, C := #80 = codes for jumping left 65408
	move.b	#0x80,d2                        	| [$1b80: ld      bc,$ff80] B := #FF, C := #80 = codes for jumping left 65408
	ror.b	#1,d0                           	| [$1b83: rra] rotate right again.  jumping to the left ?
	jcs	l_1b8a                             	| [$1b84: jp      c,$1b8a] yes, skip next step

* else jumping straight up

	move.b	#0x00,d1                        	| [$1b87: ld      bc,$0000] B := 0, C := 0 = codes for jumping straight up 0
	move.b	#0x00,d2                        	| [$1b87: ld      bc,$0000] B := 0, C := 0 = codes for jumping straight up 0

l_1b8a:
	clr.b	d0                               	| [$1b8a: xor     a] A := 0
	move.b	d1,(a0)+                         	| [$1b8b: ld      (hl),b] store B into #6210 = jump direction (0 = right, #FF = left, 0 = up)
	                           	| [$1b8c: inc     l] HL := #6211
	move.b	d2,(a0)+                         	| [$1b8d: ld      (hl),c] store C into jump direction indicator (#80 for left or right, 0 for up)
	                           	| [$1b8e: inc     l] HL := #6212
	move.b	#0x01,(a0)+                      	| [$1b8f: ld      (hl),$01] store 1 into this indicator ???
	                           	| [$1b91: inc     l] HL := #6213
	move.b	#0x48,(a0)+                      	| [$1b92: ld      (hl),$48]
	                           	| [$1b94: inc     l] HL := #6214 (jump counter)
	move.b	d0,(a0)                         	| [$1b95: ld      (hl),a] clear jump counter
	move.b	d0,unknown_6204                 	| [$1b96: ld      (unknown_6204),a]
	move.b	d0,unknown_6206                 	| [$1b99: ld      (unknown_6206),a]
	move.b	mario_movement_indicator_sprite_value_6207,d0	| [$1b9c: ld      a,(mario_movement_indicator_sprite_value_6207)] load movement indicator
	and.b	#0x80,d0                         	| [$1b9f: and     $80] clear right 4 bits and leftmost bit
	or.b	#0x0e,d0                          	| [$1ba1: or      $0e] set right bits to E = 1110
	move.b	d0,mario_movement_indicator_sprite_value_6207	| [$1ba3: ld      (mario_movement_indicator_sprite_value_6207),a] set jumping bits to indicate a jump in progress
	move.b	mario_y_position_6205,d0	| [$1ba6: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	move.b	d0,unknown_620e                 	| [$1ba9: ld      (unknown_620e),a] save mario's Y position when jump
	lea	sound_buffer_address_for_jumping_6081,a0	| [$1bac: ld      hl,sound_buffer_address_for_jumping_6081] load HL with sound buffer address for jumping
	move.b	#0x03,(a0)                      	| [$1baf: ld      (hl),$03] load sound buffer jumping sound for 3 units (3 frames?)
	move.w	#JUMPING_SND,d0
	jbsr	osd_sound_start
	rts                                    	| [$1bb1: ret] return to main routine (#1983)

* arrive here when mario is already jumping from #1AC7

l_1bb2:
	lea	mario_array_6200,a2            	| [$1bb2: ld      ix,mario_array_6200] load IX with start of array for mario
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1bb6: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	move.b	d0,(0x0b,a2)                    	| [$1bb9: ld      (ix+$0b),a] store into +B
	move.b	mario_y_position_6205,d0	| [$1bbc: ld      a,(mario_y_position_6205)] load A with mario's Y position
	move.b	d0,(0x0c,a2)                    	| [$1bbf: ld      (ix+$0c),a] store into +C = #620C = jump height
	jbsr	update_barrel_variables_239c                            	| [$1bc2: call    $239c] handle jump stuff ?
	jbsr	l_241f                            	| [$1bc5: call    $241f] loads DE with something depending on mario's position
	subq.b	#1,d3                           	| [$1bc8: dec     d] D == 1 ?
	jne	l_1bf2                             	| [$1bc9: jp      nz,$1bf2] no, skip ahead

* bounce mario off left side wall ?

	clr.b	(0x10,a2)                        	| [$1bcc: ld      (ix+$10),$00] clear jump direction
	move.b	#0x80,(0x11,a2)                 	| [$1bd0: ld      (ix+$11),$80] set +11 indicator to #80 (???)
	bset.b	#7,(0x07,a2)                    	| [$1bd4: set     7,(ix+$07)] set bit 7 of +7 = sprite used = make mario face the other way

l_1bd8:
	move.b	falling_too_far_indicator_6220,d0	| [$1bd8: ld      a,(falling_too_far_indicator_6220)] load A with falling too far indicator
	subq.b	#1,d0                           	| [$1bdb: dec     a] == 1 ? (falling too far?)
	jeq	l_1bec                             	| [$1bdc: jp      z,$1bec] yes, skip ahead

	jbsr	l_2407                            	| [$1bdf: call    $2407] ???
	move.b	d5,(0x12,a2)                    	| [$1be2: ld      (ix+$12),h]
	move.b	d6,(0x13,a2)                    	| [$1be5: ld      (ix+$13),l]
	clr.b	(0x14,a2)                        	| [$1be8: ld      (ix+$14),$00] clear the +14 indicator (???)

l_1bec:
	jbsr	update_barrel_variables_239c                            	| [$1bec: call    $239c] ???
	jra	l_1c05                             	| [$1bef: jp      $1c05] skip ahead

l_1bf2:
	subq.b	#1,d4                           	| [$1bf2: dec     e] decrease E.  at zero ?
	jne	l_1c05                             	| [$1bf3: jp      nz,$1c05] no, skip ahead

* bounce mario off right side wall ?

	move.b	#0xff,(0x10,a2)                 	| [$1bf6: ld      (ix+$10),$ff] set jump direction to left
	move.b	#0x80,(0x11,a2)                 	| [$1bfa: ld      (ix+$11),$80] set +11 indicator to #80
	bclr.b	#7,(0x07,a2)                    	| [$1bfe: res     7,(ix+$07)] reset bit 7 of +7 = sprite used = makes mario face the other way
	jra	l_1bd8                             	| [$1c02: jp      $1bd8] jump back to program

l_1c05:
	jbsr	l_2b1c                            	| [$1c05: call    $2b1c] do stuff for jumping, load A with landing indicator ?
	subq.b	#1,d0                           	| [$1c08: dec     a] decrease A.  mario landing ?
	jeq	mario_lands_1c3a                             	| [$1c09: jp      z,$1c3a] yes, skip ahead to handle

	move.b	mario_jump_apex_621f,d0         	| [$1c0c: ld      a,(mario_jump_apex_621f)] else load A with #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.
	subq.b	#1,d0                           	| [$1c0f: dec     a] decrease A.  at zero ?  is mario at apex or on way down ?
	jeq	l_1c76                             	| [$1c10: jp      z,$1c76] yes, skip ahead

	move.b	jump_counter_6214,d0            	| [$1c13: ld      a,(jump_counter_6214)] load A with jump counter
	sub.b	#0x14,d0                         	| [$1c16: sub     $14] == #14 ? (apex of jump)
	jne	l_1c33                             	| [$1c18: jp      nz,$1c33] no, skip ahead

* mario at apex of jump ?

	move.b	#0x01,d0                        	| [$1c1b: ld      a,$01] A := 1
	move.b	d0,mario_jump_apex_621f         	| [$1c1d: ld      (mario_jump_apex_621f),a] store into #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.
	jbsr	l_2853                            	| [$1c20: call    $2853] check for items under mario
	tst.b	d0                               	| [$1c23: and     a] was an item jumped?
	jeq	update_mario_sprite_1da6                             	| [$1c24: jp      z,$1da6] no, jump ahead to update mario sprite and RET

* an item was jumped

	move.b	d0,scoring_indicator_6342       	| [$1c27: ld      (scoring_indicator_6342),a] yes, barrel has been jumped, set for later use
	move.b	#0x01,d0                        	| [$1c2a: ld      a,$01] A := 1
	move.b	d0,bonus_indicator_6340         	| [$1c2c: ld      (bonus_indicator_6340),a] store into #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears
	move.b	d0,bonus_sound_indicator_6225   	| [$1c2f: ld      (bonus_sound_indicator_6225),a] store into bonus sound indicator
	move.w	#JUMPED_OVER_SND,d0
	jbsr	osd_sound_start

	nop                                    	| [$1c32: nop] No operation [what was here ???]

* can arrive from #1C18

l_1c33:
	addq.b	#1,d0                           	| [$1c33: inc     a] increase A.  Will turn to zero 1 pixel before apex of jump
	bne.b	0f                               	| [...]
	jbsr	l_2954                            	| [$1c34: call    z,$2954] if zero, call this sub to check for hammer grab
0:

	jra	update_mario_sprite_1da6                             	| [$1c37: jp      $1da6] jump ahead to update mario sprite and RET

* arrive here when mario lands.  B is preloaded with a parameter

mario_lands_1c3a:
	subq.b	#1,d1                           	| [$1c3a: dec     b] B == 1 ?
	jeq	l_1c4f                             	| [$1c3b: jp      z,$1c4f] if so, skip ahead

	addq.b	#1,d0                           	| [$1c3e: inc     a] increase A
	move.b	d0,mario_jump_apex_621f         	| [$1c3f: ld      (mario_jump_apex_621f),a] store into #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.
	clr.b	d0                               	| [$1c42: xor     a] A := 0
	lea	mario_jump_direction_6210,a0   	| [$1c43: ld      hl,mario_jump_direction_6210] load HL with jump direction
	move.b	#0x05,d1                        	| [$1c46: ld      b,$05] for B := 1 to 5

l_1c48:
	move.b	d0,(a0)+                         	| [$1c48: ld      (hl),a] clear this memory (jump direction, etc)
												| [$1c49: inc     l] next HL
	subq.b	#1,d1                           	| [...]
	jne	l_1c48                             	| [$1c4a: djnz    $1c48] next B

	jra	update_mario_sprite_1da6                             	| [$1c4c: jp      $1da6] jump ahead to update mario sprite and RET

* jump almost complete ...

l_1c4f:
	move.b	d0,jumping_status_6216          	| [$1c4f: ld      (jumping_status_6216),a] store A into jump indicator
	move.b	falling_too_far_indicator_6220,d0	| [$1c52: ld      a,(falling_too_far_indicator_6220)] load A with falling too far indicator
	eor.b	#0x01,d0                         	| [$1c55: xor     $01] toggle rightmost bit [ change to LD A, #01 to enable infinite falling without death]
	tst.b	invincible_flag
	bne.b	0f
	move.b	d0,mario_array_6200             	| [$1c57: ld      (mario_array_6200),a] store into mario life indicator.  if mario fell too far, he will die.
0:
	lea	mario_movement_indicator_sprite_value_6207,a0	| [$1c5a: ld      hl,mario_movement_indicator_sprite_value_6207] load HL with address of movement indicator
	move.b	(a0),d0                         	| [$1c5d: ld      a,(hl)] load A with movement indicator
	and.b	#0x80,d0                         	| [$1c5e: and     $80] maks bits, leave bit 7 as is.  all other bits are zeroed.
	or.b	#0x0f,d0                          	| [$1c60: or      $0f] turn on all 4 low bits
	move.b	d0,(a0)                         	| [$1c62: ld      (hl),a] store result into movement indicator
	move.b	#0x04,d0                        	| [$1c63: ld      a,$04] A := 4
	move.b	d0,jump_coming_down_indicator_621e	| [$1c65: ld      (jump_coming_down_indicator_621e),a] store into jump coming down indicator
	clr.b	d0                               	| [$1c68: xor     a] A := 0
	move.b	d0,mario_jump_apex_621f         	| [$1c69: ld      (mario_jump_apex_621f),a] store into #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.
	move.b	bonus_sound_indicator_6225,d0   	| [$1c6c: ld      a,(bonus_sound_indicator_6225)] load A with bonus sound indicator
	subq.b	#1,d0                           	| [$1c6f: dec     a] was a bonus awarded?
	bne.b	0f                               	| [...]
	jbsr	play_bonus_sound_1d95                            	| [$1c70: call    z,$1d95] yes, call this sub to play bonus sound
0:

	jra	update_mario_sprite_1da6                             	| [$1c73: jp      $1da6] jump ahead to update mario sprite and RET

* mario is on way down from jump or falling

l_1c76:
	move.b	mario_y_position_6205,d0	| [$1c76: ld      a,(mario_y_position_6205)] load A with mario's Y position
	lea	unknown_620e,a0                	| [$1c79: ld      hl,unknown_620e] load HL with mario original Y position ?
	sub.b	#0x0f,d0                         	| [$1c7c: sub     $0f] subtract #F
	cmp.b	(a0),d0                          	| [$1c7e: cp      (hl)] compare.  is mario falling too far ?
	jcs	update_mario_sprite_1da6                             	| [$1c7f: jp      c,$1da6] no, jump ahead to update mario sprite and RET

* mario falling too far on a jump

	move.b	#0x01,d0                        	| [$1c82: ld      a,$01] A := 1
	move.b	d0,falling_too_far_indicator_6220	| [$1c84: ld      (falling_too_far_indicator_6220),a] store into falling too far indicator
	lea	play_sound_for_falling_bouncer_6084,a0	| [$1c87: ld      hl,play_sound_for_falling_bouncer_6084] load HL with address for falling sound
	move.b	#0x03,(a0)                      	| [$1c8a: ld      (hl),$03] play falling sound for 3 units
	jra	update_mario_sprite_1da6                             	| [$1c8c: jp      $1da6] jump ahead to update mario sprite and RET

* arrive here when joystick is being pressed right

l_1c8f:
	move.b	#0x01,d1                        	| [$1c8f: ld      b,$01] B := 1 = movement to right
	move.b	address_of_movement_indicator_620f,d0	| [$1c91: ld      a,(address_of_movement_indicator_620f)] load A with movement indicator
	                               	| [$1c94: and     a] time to move mario ?
	jne	l_1cd2                             	| [$1c95: jp      nz,$1cd2] yes, jump ahead

	move.b	put_back_6202,d0                	| [$1c98: ld      a,(put_back_6202)] varies from 0, 2, 4, 1 when mario is walking left or right
	move.b	d0,d1                           	| [$1c9b: ld      b,a] copy into B. this is used in sub at #3009 called below
	move.b	#0x05,d0                        	| [$1c9c: ld      a,$05] A := 5
	jbsr	l_3009                            	| [$1c9e: call    $3009] ??? change A depending on where mario is?
	move.b	d0,put_back_6202                	| [$1ca1: ld      (put_back_6202),a] put back
	and.b	#0x03,d0                         	| [$1ca4: and     $03] mask bits, now between 0 and 3
	or.b	#0x80,d0                          	| [$1ca6: or      $80] turn on bit 7
	jra	l_1cc2                             	| [$1ca8: jp      $1cc2] skip ahead

* arrive here when joystick is being pressed left

l_1cab:
	st.b	d1                                	| [$1cab: ld      b,$ff] B := #FF = -1 (movement to left)
	move.b	address_of_movement_indicator_620f,d0	| [$1cad: ld      a,(address_of_movement_indicator_620f)] load A with movement indicator
	                               	| [$1cb0: and     a] time to move mario?
	jne	l_1cd2                             	| [$1cb1: jp      nz,$1cd2] yes, skip ahead and move mario

	move.b	put_back_6202,d0                	| [$1cb4: ld      a,(put_back_6202)] varies from 0, 2, 4, 1 when mario is walking left or right
	move.b	d0,d1                           	| [$1cb7: ld      b,a] copy to B.  this is used in sub at #3009 called below
	move.b	#0x01,d0                        	| [$1cb8: ld      a,$01] A := 1
	jbsr	l_3009                            	| [$1cba: call    $3009] ??? change A depending on where mario is?
	move.b	d0,put_back_6202                	| [$1cbd: ld      (put_back_6202),a] put back
	and.b	#0x03,d0                         	| [$1cc0: and     $03] mask bits. now between 0 and 3

l_1cc2:
	lea	mario_movement_indicator_sprite_value_6207,a0	| [$1cc2: ld      hl,mario_movement_indicator_sprite_value_6207] load HL with mario movement indicator/sprite value
	move.b	d0,(a0)                         	| [$1cc5: ld      (hl),a] store A into this
	ror.b	#1,d0                           	| [$1cc6: rra] rotate right.  is A odd?
 	bcc.b	0f                               	| [...]
	jbsr	l_1d8f                            	| [$1cc7: call    c,$1d8f] yes , skip ahead to start walking sound and RET
0:

	move.b	#0x02,d0                        	| [$1cca: ld      a,$02] A := 2
	move.b	d0,address_of_movement_indicator_620f	| [$1ccc: ld      (address_of_movement_indicator_620f),a] store into movement indicator (reset)
	jra	update_mario_sprite_1da6                             	| [$1ccf: jp      $1da6] jump ahead to update mario sprite and RET

l_1cd2:
	lea	jump_if_bit_7_of_mario_x_position_is_set_6203,a0	| [$1cd2: ld      hl,jump_if_bit_7_of_mario_x_position_is_set_6203] load HL with mario X position address
	move.b	(a0),d0                         	| [$1cd5: ld      a,(hl)] load A with mario X position
	add.b	d1,d0                            	| [$1cd6: add     a,b] add movement (either 1 or #FF)
	move.b	d0,(a0)                         	| [$1cd7: ld      (hl),a] store new result
	move.b	screen_number_6227,d0           	| [$1cd8: ld      a,(screen_number_6227)] load A with screen number
	subq.b	#1,d0                           	| [$1cdb: dec     a] are we on the girders?
	jne	l_1ceb                             	| [$1cdc: jp      nz,$1ceb] no, skip ahead

	move.b	(a0),d5                         	| [$1cdf: ld      h,(hl)] else load H with mario X position
	move.b	mario_y_position_6205,d0	| [$1ce0: ld      a,(mario_y_position_6205)] load A with mario Y position
	move.b	d0,d6                           	| [$1ce3: ld      l,a] copy to L.  HL now has mario X,Y
	jbsr	l_2333                            	| [$1ce4: call    $2333] check for movement up/down a girder, might also change Y position ?
	move.b	d6,d0                           	| [$1ce7: ld      a,l] load A with new Y position
	move.b	d0,mario_y_position_6205	| [$1ce8: ld      (mario_y_position_6205),a] store into Y position

l_1ceb:
	lea	address_of_movement_indicator_620f,a0	| [$1ceb: ld      hl,address_of_movement_indicator_620f] load HL with address of movement indicator
	subq.b	#1,(a0)                         	| [$1cee: dec     (hl)] decrease movement indicator
	jra	update_mario_sprite_1da6                             	| [$1cef: jp      $1da6] jump ahead to update mario sprite and RET

* mario moving down on a ladder
* jump here from #1B3D

l_1cf2:
	move.b	address_of_movement_indicator_620f,d0	| [$1cf2: ld      a,(address_of_movement_indicator_620f)] load A with movmement indicator (from 3 to 0)
	                               	| [$1cf5: and     a] == 0 ?
	jne	l_1d8a                             	| [$1cf6: jp      nz,$1d8a] no, skip ahead, decrease indicator and return

* ok for mario to move

	move.b	#0x03,d0                        	| [$1cf9: ld      a,$03] A := 3
	move.b	d0,address_of_movement_indicator_620f	| [$1cfb: ld      (address_of_movement_indicator_620f),a] reset movement indicator to 3
	move.b	#0x02,d0                        	| [$1cfe: ld      a,$02] A := 2 pixels to move down
	jra	l_1d11                             	| [$1d00: jp      $1d11] skip ahead

* mario moving up on a ladder
* jump here from #1B4A

l_1d03:
	move.b	address_of_movement_indicator_620f,d0	| [$1d03: ld      a,(address_of_movement_indicator_620f)] load A with movement indicator (from 4 to 0)
	                               	| [$1d06: and     a] time to move mario ?
	jne	l_1d76                             	| [$1d07: jp      nz,$1d76] no, skip ahead

	move.b	#0x04,d0                        	| [$1d0a: ld      a,$04] A := 4
	move.b	d0,address_of_movement_indicator_620f	| [$1d0c: ld      (address_of_movement_indicator_620f),a] reset movement indicator to 4 (slower movement going up)
	move.b	#0xfe,d0                        	| [$1d0f: ld      a,$fe] A := #FE = -2 pixels movement

l_1d11:
	lea	mario_y_position_6205,a0	| [$1d11: ld      hl,mario_y_position_6205] load HL with mario Y position address
	add.b	(a0),d0                          	| [$1d14: add     a,(hl)] add A to Y position
	move.b	d0,(a0)                         	| [$1d15: ld      (hl),a] store result into Y position
	move.b	d0,d1                           	| [$1d16: ld      b,a] copy to B
	move.b	ladder_toggle_6222,d0           	| [$1d17: ld      a,(ladder_toggle_6222)] load A with ladder toggle
	eor.b	#0x01,d0                         	| [$1d1a: xor     $01] toggle the bit
	move.b	d0,ladder_toggle_6222           	| [$1d1c: ld      (ladder_toggle_6222),a] store.  is it zero?
	jne	l_1d51                             	| [$1d1f: jp      nz,$1d51] no, skip ahead

	move.b	d1,d0                           	| [$1d22: ld      a,b] A := B =  mario Y position
	add.b	#0x08,d0                         	| [$1d23: add     a,$08] add 8 [offset for mario's actual position ???]
	lea	y_value_of_top_of_ladder_621c,a0	| [$1d25: ld      hl,y_value_of_top_of_ladder_621c] load HL with Y value of top of ladder
	cmp.b	(a0),d0                          	| [$1d28: cp      (hl)] is mario at top of ladder ?
	jeq	l_1d67                             	| [$1d29: jp      z,$1d67] yes, skip ahead to handle

	                           	| [$1d2c: dec     l] HL := #621B = Y value of bottom of ladder
	sub.b	-(a0),d0                          	| [$1d2d: sub     (hl)] is mario at bottom of ladder ?
	jeq	l_1d67                             	| [$1d2e: jp      z,$1d67] yes, skip ahead to handle

	move.b	#0x05,d1                        	| [$1d31: ld      b,$05] B := 5
	sub.b	#0x08,d0                         	| [$1d33: sub     $08] subtract 8.  zero?
	jeq	l_1d3f                             	| [$1d35: jp      z,$1d3f] yes, skip next 4 steps

	subq.b	#1,d1                           	| [$1d38: dec     b] B := 4
	subq.b	#0x04,d0                        	| [$1d39: sub     $04] subtract 4.  zero?
	jeq	l_1d3f                             	| [$1d3b: jp      z,$1d3f] yes, skip next step

	subq.b	#1,d1                           	| [$1d3e: dec     b] B := 3

l_1d3f:
	move.b	#0x80,d0                        	| [$1d3f: ld      a,$80] A := #80
	lea	mario_movement_indicator_sprite_value_6207,a0	| [$1d41: ld      hl,mario_movement_indicator_sprite_value_6207] load HL with address of mario movement indicator/sprite value
	and.b	(a0),d0                          	| [$1d44: and     (hl)] mask bits with movement
	eor.b	#0x80,d0                         	| [$1d45: xor     $80] toggle bit 7
	or.b	d1,d0                             	| [$1d47: or      b] turn on bits based on ladder position
	move.b	d0,(a0)                         	| [$1d48: ld      (hl),a] store into mario movement indicator/sprite value

l_1d49:
	move.b	#0x01,d0                        	| [$1d49: ld      a,$01] A := 1
	move.b	d0,ladder_status_6215           	| [$1d4b: ld      (ladder_status_6215),a] store into ladder status.  mario is on a ladder now
	jra	update_mario_sprite_1da6                             	| [$1d4e: jp      $1da6] jump ahead to update mario sprite and RET

l_1d51:
	subq.w	#2,a0                           	| [$1d51: dec     l]
	                           	| [$1d52: dec     l] HL := #6203
	move.b	(a0),d0                         	| [$1d53: ld      a,(hl)] load A with mario sprite value
	or.b	#0x03,d0                          	| [$1d54: or      $03] turn on bits 0 and 1
	bclr.b	#2,d0                           	| [$1d56: res     2,a] clear bit 2
	move.b	d0,(a0)                         	| [$1d58: ld      (hl),a] store into mario sprite
	move.b	store_result_6224,d0            	| [$1d59: ld      a,(store_result_6224)] load A with sound alternator
	eor.b	#0x01,d0                         	| [$1d5c: xor     $01] toggle bit 0
	move.b	d0,store_result_6224            	| [$1d5e: ld      (store_result_6224),a] store result
	bne.b	0f                               	| [...]
	jbsr	l_1d8f                            	| [$1d61: call    z,$1d8f] if zero, play walking sound for moving on ladder
0:

	jra	l_1d49                             	| [$1d64: jp      $1d49] jump back

* arrive from #1D29 when mario at top or bottom of ladder

l_1d67:
	move.b	#0x06,d0                        	| [$1d67: ld      a,$06] A := 6
	move.b	d0,mario_movement_indicator_sprite_value_6207	| [$1d69: ld      (mario_movement_indicator_sprite_value_6207),a] store into mario movement indicator/sprite value
	clr.b	d0                               	| [$1d6c: xor     a] A := 0
	move.b	d0,store_1_into_status_indicator_6219	| [$1d6d: ld      (store_1_into_status_indicator_6219),a] clear this status indicator
	move.b	d0,ladder_status_6215           	| [$1d70: ld      (ladder_status_6215),a] clear ladder status.  mario no longer on ladder
	jra	update_mario_sprite_1da6                             	| [$1d73: jp      $1da6] jump ahead to update mario sprite and RET

* jump here from #1D07 when going up a ladder but not actually moving

l_1d76:
	move.b	moving_ladder_indicator_621a,d0 	| [$1d76: ld      a,(moving_ladder_indicator_621a)] load A with this indicator.  set when mario is on moving ladder or broken ladder
	                               	| [$1d79: and     a] is mario boarding or on a retracting or broken ladder?
	jeq	l_1d8a                             	| [$1d7a: jp      z,$1d8a] no, skip ahead

* mario on or moving onto a rectracting or broken ladder

	move.b	d0,store_1_into_status_indicator_6219	| [$1d7d: ld      (store_1_into_status_indicator_6219),a] store 1 into status indicator
	move.b	y_value_of_top_of_ladder_621c,d0	| [$1d80: ld      a,(y_value_of_top_of_ladder_621c)] load A with Y value of top of ladder
	sub.b	#0x13,d0                         	| [$1d83: sub     $13] subtract #13
	lea	mario_y_position_6205,a0	| [$1d85: ld      hl,mario_y_position_6205] load HL with mario Y position address
	cmp.b	(a0),d0                          	| [$1d88: cp      (hl)] is mario at or above the top of ladder ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$1d89: ret     nc] yes, return without changing movement [...]
0:

l_1d8a:
	lea	address_of_movement_indicator_620f,a0	| [$1d8a: ld      hl,address_of_movement_indicator_620f] else load HL with address of movement indicator
	subq.b	#1,(a0)                         	| [$1d8d: dec     (hl)] decrease
	rts                                    	| [$1d8e: ret] return

* mario is walking

l_1d8f:
	move.b	#0x03,d0                        	| [$1d8f: ld      a,$03] load sound duration of 3 for walking
	move.b	d0,walking_sound_buffer_6080    	| [$1d91: ld      (walking_sound_buffer_6080),a] store into walking sound buffer
	move.w	#WALKING_SND,d0
	jbsr	osd_sound_start
	rts                                    	| [$1d94: ret] return

* arrive here when walking over a rivet, not jumping.  from #1AB9, or from #1C70

play_bonus_sound_1d95:
	move.b	d0,bonus_sound_indicator_6225   	| [$1d95: ld      (bonus_sound_indicator_6225),a] store A into bonus sound indicator.  A is zero so this clears the indicator
	move.b	screen_number_6227,d0           	| [$1d98: ld      a,(screen_number_6227)] load A with screen number
	subq.b	#1,d0                           	| [$1d9b: dec     a] is this the girders?
	bne.b	0f                               	| [...]
	rts                                    	| [$1d9c: ret     z] yes , then return, we don't play this sound for the girders [...]
0:

* play bonus sound

	lea	sound_buffer_address_608a,a0   	| [$1d9d: ld      hl,sound_buffer_address_608a] else load HL with sound address
	move.b	#JUMPED_OVER_SND,d0
	move.b	d0,(a0)+                      	| [$1da0: ld      (hl),$0d] play bonus sound
	jbsr	osd_sound_start
	                           	| [$1da2: inc     l] HL := #608B = sound duration
	move.b	#0x03,(a0)                      	| [$1da3: ld      (hl),$03] set sound duration to 3
	rts                                    	| [$1da5: ret] return

* update mario sprite

update_mario_sprite_1da6:
	lea	mario_sprite_x_position_694c,a0	| [$1da6: ld      hl,mario_sprite_x_position_694c] load HL with mario sprite X position
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1da9: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	move.b	d0,(a0)+                         	| [$1dac: ld      (hl),a] store into hardware sprite mario X position
	move.b	mario_movement_indicator_sprite_value_6207,d0	| [$1dad: ld      a,(mario_movement_indicator_sprite_value_6207)] load A with movement indicator
	                           	| [$1db0: inc     l] HL := #694D = hardware mario sprite
	move.b	d0,(a0)+                         	| [$1db1: ld      (hl),a] store into hardware mario sprite value
	move.b	mario_color_6208,d0             	| [$1db2: ld      a,(mario_color_6208)] load A with mario color
	                           	| [$1db5: inc     l] HL := #694E = hardware mario sprite color
	move.b	d0,(a0)+                         	| [$1db6: ld      (hl),a] store into mario sprite color
	move.b	mario_y_position_6205,d0	| [$1db7: ld      a,(mario_y_position_6205)] load A with mario Y position
	                           	| [$1dba: inc     l] HL := #694F = mario sprite Y position
	move.b	d0,(a0)                         	| [$1dbb: ld      (hl),a] store into mario sprite Y position
	rts                                    	| [$1dbc: ret] return


* called from main routine at #197A
* also called from other areas


check_for_bonus_items_1dbd:
	move.b	bonus_indicator_6340,d0         	| [$1dbd: ld      a,(bonus_indicator_6340)] load A with #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears
	jbsr	rst_28                            	| [$1dc0: rst     $28] jump based on A

	.long	l_1e49| #1E49 = no item.  returns immediately
	.long	l_1dc9| #1DC9 = item just picked up
	.long	l_1e4a| #1E4A = bonus appears


* an item was just picked up / jumped over / hit with hammer

l_1dc9:
	move.b	#0x40,d0                        	| [$1dc9: ld      a,$40] A := #40
	move.b	d0,timer_6341                   	| [$1dcb: ld      (timer_6341),a] store into timer
	move.b	#0x02,d0                        	| [$1dce: ld      a,$02] A := 2
	move.b	d0,bonus_indicator_6340         	| [$1dd0: ld      (bonus_indicator_6340),a] store into #6340 - usually 0, changes when mario picks up bonus item. jumps over item turns to 1 quickly, then 2 until bonus disappears
	move.b	scoring_indicator_6342,d0       	| [$1dd3: ld      a,(scoring_indicator_6342)] load A with scoring indicator
	CLEAR_XC_FLAGS
	roxr.b	#1,d0                           	| [$1dd6: rra] roll right.  is this a jumped item?
	jcs	set_scoring_sprites_3e70                             	| [$1dd7: jp      c,$3e70] yes, award points for jumping items [ patch ? orig code had JP C,#1E25 ??? ]

	roxr.b	#1,d0                           	| [$1dda: rra] else roll right
	jcs	l_1e00                             	| [$1ddb: jp      c,$1e00] award for hitting regular barrel with hammer

	roxr.b	#1,d0                           	| [$1dde: rra] roll right.  hit blue barrel with hammer?
	jcs	l_1df5                             	| [$1ddf: jp      c,$1df5] yes, skip ahead to handle

* else it was a bonus item pickup

	lea	play_sound_for_bonus_6085,a0   	| [$1de2: ld      hl,play_sound_for_bonus_6085] else load HL with bonus sound address
	move.b	#0x03,(a0)                      	| [$1de5: ld      (hl),$03] play bonus sound for 3 duration
	move.w	#JUMPED_OVER_SND,d0
	jbsr	osd_sound_start
	move.b	level_number_6229,d0       	| [$1de7: ld      a,(level_number_6229)] load A with level #
	subq.b	#1,d0                           	| [$1dea: dec     a] decrease A.  is this level 1 ?
	jeq	l_1e00                             	| [$1deb: jp      z,$1e00] yes, jump ahead for 300 pts

	subq.b	#1,d0                           	| [$1dee: dec     a] else is this level 2 ?
	jeq	l_1e08                             	| [$1def: jp      z,$1e08] yes, award 500 pts

	jra	l_1e10                             	| [$1df2: jp      $1e10] else award 800 pts

* blue barrel hit with hammer

l_1df5:
	move.b	rngtimer1_6018,d0               	| [$1df5: ld      a,(rngtimer1_6018)] load timer, a psuedo random number
	ror.b	#1,d0                           	| [$1df8: rra] roll right = 50% chance of 500 points
	jcs	l_1e08                             	| [$1df9: jp      c,$1e08] award 500 points

	ror.b	#1,d0                           	| [$1dfc: rra] roll right again, gives overall 25% chance of 800 points
	jcs	l_1e10                             	| [$1dfd: jp      c,$1e10] award 800 points

* else award 300 points

l_1e00:
	move.b	#0x7d,d1                        	| [$1e00: ld      b,$7d] set sprite for 300 points
	move.w	#0x0003,d3                      	| [$1e02: ld      de,$0003] set points at 300 3
	jra	l_1e15                             	| [$1e05: jp      $1e15] award points

* award 500 pts

l_1e08:
	move.b	#0x7e,d1                        	| [$1e08: ld      b,$7e] set sprite for 500 points
	move.w	#0x0005,d3                      	| [$1e0a: ld      de,$0005] set points at 500 5
	jra	l_1e15                             	| [$1e0d: jp      $1e15] award points

* award 800 pts

l_1e10:
	move.b	#0x7f,d1                        	| [$1e10: ld      b,$7f] set sprite for 800 points
	move.w	#0x0008,d3                      	| [$1e12: ld      de,$0008] set points at 800 8

l_1e15:
	jbsr	insert_task_309f                            	| [$1e15: call    $309f] insert task to add score

	
* arrive here when bonus item picked up or smashed with hammer

	LOAD_RAM_ADDRESS_LE	unknown_for_use_later_6343,a0	| [$1e18: ld      hl,(unknown_for_use_later_6343)] load HL with contents of #6343 , this gives the address of the sprite location
	move.b	(a0),d0                         	| [$1e1b: ld      a,(hl)] load A with the X position of the sprite in question
	clr.b	(a0)                             	| [$1e1c: ld      (hl),$00] clear the sprite from the screen
	addq.w	#3,a0                           	| [$1e1e: inc     l] increase L 3 times * 3
	move.b	(a0),d2                         	| [$1e21: ld      c,(hl)] load C with the Y position of the item
	jra	set_bonus_score_sprite_1e36                             	| [$1e22: jp      $1e36] jump ahead


	move.w	#0x0001,d3                      	| [$1e25: ld      de,$0001] load task for scoring, 100 pts [ never arrive at this line ??? possibly orig code came from #1DD7 ] 1

* arrive when barrel has been jumped for points from #3E70 range
* DE is preloaded with task for scoring 100, 300, or 500 pts [bug, should be 800 pts]

l_1e28:
	jbsr	insert_task_309f                            	| [$1e28: call    $309f] insert task to add score
	move.b	mario_y_position_6205,d0	| [$1e2b: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	add.b	#0x14,d0                         	| [$1e2e: add     a,$14] add #14
	move.b	d0,d2                           	| [$1e30: ld      c,a] store into C
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1e31: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position

	                                    	| [$1e34: nop]
	                                    	| [$1e35: nop] [ what used to be here?  was it LD B,#7B to set sprite for 100 pts? ]

* draw the bonus score on the screen

set_bonus_score_sprite_1e36:
	lea	unknown_6a30,a0                	| [$1e36: ld      hl,unknown_6a30] load HL with scoring sprite start
	move.b	d0,(a0)+                         	| [$1e39: ld      (hl),a] store X position
	                           	| [$1e3a: inc     l] next location
	move.b	d1,(a0)+                         	| [$1e3b: ld      (hl),b] store sprite graphic
	                           	| [$1e3c: inc     l] next
	move.b	#0x07,(a0)+                      	| [$1e3d: ld      (hl),$07] store color code 7
	                           	| [$1e3f: inc     l] next
	move.b	d2,(a0)                         	| [$1e40: ld      (hl),c] store Y position
	move.b	#0x05,d0                        	| [$1e41: ld      a,$05] A := 5 = binary 0101
	jbsr	only_continues_if_given_level_0030                            	| [$1e43: rst     $30] only allow continue on girders and elevators, others do RET here [no bonus sound for killing firefox with hammer]
	move.w	#JUMPED_OVER_SND,d0
	jbsr	osd_sound_start
	lea	play_sound_for_bonus_6085,a0   	| [$1e44: ld      hl,play_sound_for_bonus_6085] load HL with bonus sound address
	move.b	#0x03,(a0)                      	| [$1e47: ld      (hl),$03] play bonus sound for 3 duration
l_1e49:
	rts                                    	| [$1e49: ret] return

* arrive here from #1DC0 when bonus appears

l_1e4a:
	lea	timer_6341,a0                  	| [$1e4a: ld      hl,timer_6341] load HL with timer
	subq.b	#1,(a0)                         	| [$1e4d: dec     (hl)] has it run out yet ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1e4e: ret     nz] no, return [...]
0:

	clr.b	d0                               	| [$1e4f: xor     a] else A := 0
	move.b	d0,unknown_6a30                 	| [$1e50: ld      (unknown_6a30),a] clear this
	move.b	d0,bonus_indicator_6340         	| [$1e53: ld      (bonus_indicator_6340),a] clear this
	rts                                    	| [$1e56: ret] return

* called from main routine at #19B9
* checks for end of level ?

l_1e57:
	move.b	screen_number_6227,d0           	| [$1e57: ld      a,(screen_number_6227)] load a with screen number
	btst.b	#2,d0                           	| [$1e5a: bit     2,a] are we on the rivets?
	jne	l_1e80                             	| [$1e5c: jp      nz,$1e80] yes, skip ahead to handle

	ror.b	#1,d0                           	| [$1e5f: rra] else rotate right with carry
	jcs	l_1e7a                             	| [$1e63: jp      c,$1e7a] skip ahead on girders and elevators
	move.b	mario_y_position_6205,d0	| [$1e60: ld      a,(mario_y_position_6205)] load A with y position of mario

	cmp.b	#0x51,d0                         	| [$1e66: cp      $51] else on the conveyors.  is mario high enough to end level?
	bcs.b	0f                               	| [...]
	rts                                    	| [$1e68: ret     nc] no, return [...]
0:

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$1e69: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] else load A with mario's X position
	roxl.b	#1,d0                           	| [$1e6c: rla] on left or right side of screen?
	SET_X_FROM_C
l_1e6d:
	clr.b	d0                               	| [$1e6d: ld      a,$00] load A with #00.  sprite for facing left
	SET_C_FROM_X
	jcs	l_1e74                             	| [$1e6f: jp      c,$1e74] if on left side, skip next step

	move.b	#0x80,d0                        	| [$1e72: ld      a,$80] else load A with sprite facing right
l_1e74:
	move.b	d0,mario_sprite_value_694d      	| [$1e74: ld      (mario_sprite_value_694d),a] set mario sprite
	jra	l_1e85                             	| [$1e77: jp      $1e85] jump ahead

* check for end of level on girders and elevators

l_1e7a:
	move.b	mario_y_position_6205,d0	| [$1e60: ld      a,(mario_y_position_6205)] load A with y position of mario
	cmp.b	#0x31,d0                         	| [$1e7a: cp      $31] are we on top level (rescued girl?)
	bcs.b	0f                               	| [...]
	rts                                    	| [$1e7c: ret     nc] no, return [...]
0:
	SET_X_FROM_C
	jra	l_1e6d                             	| [$1e7d: jp      $1e6d] level has been fished.  jump to end of level routine.

* arrive here when on rivets

l_1e80:
	move.b	number_of_rivets_left_6290,d0   	| [$1e80: ld      a,(number_of_rivets_left_6290)] load A with number of rivets left
	                               	| [$1e83: and     a] all done with rivets ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1e84: ret     nz] no, return [...]
0:

l_1e85:
	move.b	#0x16,d0                        	| [$1e85: ld      a,$16] else A := #16
	move.b	d0,gamemode2_600a               	| [$1e87: ld      (gamemode2_600a),a] store into game mode2
	move.l	(sp)+,a0                        	| [$1e8a: pop     hl] pop stack to get higher address
	rts                                    	| [$1e8b: ret] return to a higher level [returns to #00D2]

* called from main routine at #197D
* handles items hit with hammer

handle_item_hit_with_hammer_1e8c:
	tst.b	item_hit_indicator_unknown_6350	| [$1e8c: ld      a,(item_hit_indicator_unknown_6350)] load A with hammer hit item indicator
	                               	| [$1e8f: and     a] is an item being smashed ?
	bne.b	0f                               	| [...]
	rts                                    	| [$1e90: ret     z] no, return [...]
0:

	jbsr	l_1e96                            	| [$1e91: call    $1e96] else call sub below
	move.l	(sp)+,a0                        	| [$1e94: pop     hl] then return to a higher sub
	rts                                    	| [$1e95: ret] returns to #00D2

l_1e96:
	move.b	item_hit_phase_counter_address_6345,d0	| [$1e96: ld      a,(item_hit_phase_counter_address_6345)] load A with this

* #6345 - usually 0.  changes to 1, then 2 when items are hit with the hammer

	jbsr	rst_28                            	| [$1e99: rst     $28] jump based on A

	.long	item_just_hit_1ea0	| 0       | #1EA0
	.long	l_1f09	| 1       | #1F09
	.long	l_1f23	| 2       | #1F23

* arrive right when an item is hit
item_just_hit_1ea0:	
	lea	start_of_pie_sprites_69b8,a0   	| [$1ea5: ld      hl,start_of_pie_sprites_69b8] load HL with sprites for pies
	move.b	unknown_6352,d0                 	| [$1ea0: ld      a,(unknown_6352)] load A with ???
	cmp.b	#0x65,d0                         	| [$1ea3: cp      $65] == #65 ?
	jeq	l_1eb4                             	| [$1ea8: jp      z,$1eb4] yes, skip next 3 steps

	lea	start_of_firefox_sprites_69d0,a0	| [$1eab: ld      hl,start_of_firefox_sprites_69d0] load HL with start of fire sprites ???
	jcs	l_1eb4                             	| [$1eae: jp      c,$1eb4] if carry, then skip next step

	lea	start_of_bouncers_or_barrels_sprites_6980,a0	| [$1eb1: ld      hl,start_of_bouncers_or_barrels_sprites_6980] HL is X position of a barrel

l_1eb4:
	LOAD_RAM_ADDRESS_LE	item_array_for_item_hit_6351,a2             	| [$1eb4: ld      ix,(item_array_for_item_hit_6351)] load IX with start of item array for the item hit
	clr.w	d3                               	| [$1eb8: ld      d,$00] D := 0
	* offset to add for each item, can be 0x20, 0x10 (depends on the object barrel, firefox...)
	move.b	offset_for_item_in_array_6353,d3                 	| [$1eba: ld      a,(offset_for_item_in_array_6353)] load A with the offset for each item in the array
												| [$1ebd: ld      e,a] copy to E.  DE now has the offset
	move.b	index_of_item_hit_6354,d0                 	| [$1ec1: ld      a,(index_of_item_hit_6354)] load A with the index of the item hit
												| [$1ec4: and     a] == 0 ?
	jeq	l_1ecf                             	| [$1ec5: jp      z,$1ecf] yes, skip ahead, we use the default HL and IX

	move.w	#0x04,d1                        	| [$1ebe: ld      bc,$0004] BC := size of sprite shadow structure
	* non-zero: apply index_of_item_hit_6354 offset on both sprites structure & shadow
l_1ec8:
	add.w	d1,a0                            	| [$1ec8: add     hl,bc] add offset: sprite shadow structure
	add.w	d3,a2                            	| [$1ec9: add     ix,de] add offset: object structure
	subq.b	#1,d0                           	| [$1ecb: dec     a] decrease counter.  done ?
	jne	l_1ec8                             	| [$1ecc: jp      nz,$1ec8] no, loop again

l_1ecf:
	clr.b	(a2)                        	| [$1ecf: ld      (ix+$00),$00] set this sprite as no longer active
	move.b	(0x15,a2),d0                    	| [$1ed3: ld      a,(ix+$15)] load A with +15 (0 = normal barrel,  1 = blue barrel, see next comments)

*
*
* It turns out that IX+15 is used by firefoxes and fireballs as a counter for their animation
* This value can be 0, 1, or 2 and is updated every frame
*
* For pies, this value is 0, #7C or #CC, because it grabs the +5 slot of the next pie when one is hit
*
*

											| [$1ed6: and     a] ==0 ? is this a regular barrel?  (sometimes fires and pies fall here too)
	jeq	l_1ede                             	| [$1ed9: jp      z,$1ede] yes, skip next step

	move.b	#0x04,d0                        	| [$1edc: ld      a,$04] else A := 4, used for random points (blue barrel, sometimes fire, sometimes pie)
	bra.b	l_1ede_2
l_1ede:
	move.b	#0x02,d0                        	| [$1ed7: ld      a,$02] A := 2, used for 300 pts
l_1ede_2:
	move.b	d0,scoring_indicator_6342       	| [$1ede: ld      (scoring_indicator_6342),a] store A into scoring indicator
	lea		scoring_sprite_shadow_6a2c,a4	| [$1ee1: ld      bc,scoring_sprite_shadow_6a2c] load BC with scoring sprite address
	move.b	(a0),d0                         	| [$1ee4: ld      a,(hl)] load A with sprite Y value (X on rotated display like amiga)
	clr.b	(a0)+                             	| [$1ee5: ld      (hl),$00] clear the sprite Y that was hit: no longer visible
	move.b	d0,(a4)+                         	| [$1ee7: ld      (bc),a] store sprite Y value into the scoring sprite
												| [$1ee8: inc     c] next
	                           	| [$1ee9: inc     l] next
	move.b	#0x60,(a4)+                        	| [$1eea: ld      a,$60] A := #60 = sprite for large bluewhite circle
											| [$1eec: ld      (bc),a] store into sprite graphic
											| [$1eed: inc     c] next
												| [$1eee: inc     l] we don't need this value
	move.b	#0x0c,(a4)+                        	| [$1eef: ld      a,$0c] A := #0C = color code
												| [$1ef1: ld      (bc),a] store into sprite color
												| [$1ef2: inc     c] next
												| [$1ef3: inc     l] next
	move.b	(2,a0),(a4)                         	| [$1ef4: ld      a,(hl)] load A with X value for sprite hit
												| [$1ef5: ld      (bc),a] store into X value for scoring sprite
	lea	item_hit_phase_counter_address_6345,a0	| [$1ef6: ld      hl,item_hit_phase_counter_address_6345] load HL with item hit phase counter address

* #6345 - usually 0.  changes to 1, then 2 when items are hit with the hammer
* item has been hit by hammer

	addq.b	#1,(a0)+                         	| [$1ef9: inc     (hl)] increase the item hit phase counter
	                           	| [$1efa: inc     l] HL := #6346 = a timer used for hammering items?
	move.b	#0x06,(a0)+                      	| [$1efb: ld      (hl),$06] set timer to 6
	                           	| [$1efd: inc     l] HL := #6347 = counter for number of times to change between circle and small circle
	move.b	#0x05,(a0)                      	| [$1efe: ld      (hl),$05] set to 5
	lea	sound_buffer_address_608a,a0   	| [$1f00: ld      hl,sound_buffer_address_608a] load HL with sound buffer address
	move.w	#KILL_ENEMY_SND,d0
	jbsr	osd_sound_start

	move.b	#0x06,(a0)+                      	| [$1f03: ld      (hl),$06] play sound for hammering object
	                           	| [$1f05: inc     l] HL := 608B = sound duration
	move.b	#0x03,(a0)                      	| [$1f06: ld      (hl),$03] set duration to 3
	rts                                    	| [$1f08: ret] return

* item has been hit by hammer , phase 2 of 3

l_1f09:
	lea	timer_6346,a0                  	| [$1f09: ld      hl,timer_6346] load HL with timer
	subq.b	#1,(a0)                         	| [$1f0c: dec     (hl)] count down.  zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1f0d: ret     nz] no, return [...]
0:

	move.b	#0x06,(a0)+                      	| [$1f0e: ld      (hl),$06] else reset counter to 6
	                           	| [$1f10: inc     l] HL := #6347 = counter for this function
	subq.b	#1,(a0)                         	| [$1f11: dec     (hl)] decrease counter.  zero?
	jeq	l_1f1d                             	| [$1f12: jp      z,$1f1d] yes, skip ahead

	lea	sprite_graphic_6a2d,a0         	| [$1f15: ld      hl,sprite_graphic_6a2d] else load HL with scoring sprite graphic
	move.b	(a0),d0                         	| [$1f18: ld      a,(hl)] get value
	eor.b	#0x01,d0                         	| [$1f19: xor     $01] toggle bit 0 = change sprite to small circle or back again
	move.b	d0,(a0)                         	| [$1f1b: ld      (hl),a] store
	rts                                    	| [$1f1c: ret] return

l_1f1d:
	move.b	#0x04,(a0)                      	| [$1f1d: ld      (hl),$04] store 4 into #6347 = timer?
	subq.w	#2,a0                           	| [$1f1f: dec     l] * 2
	addq.b	#1,(a0)                         	| [$1f21: inc     (hl)] increase item hit phase counter
	rts                                    	| [$1f22: ret] return

* arrive from jump at #1E99 when an item is hit with hammer (last step of 3)

l_1f23:
	lea	timer_6346,a0                  	| [$1f23: ld      hl,timer_6346] load HL with timer?
	subq.b	#1,(a0)                         	| [$1f26: dec     (hl)] count down.  zero ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1f27: ret     nz] no, return [...]
0:

	move.b	#0x0c,(a0)+                      	| [$1f28: ld      (hl),$0c] reset counter to #C
	                           	| [$1f2a: inc     l] HL := #6347 = counter
	subq.b	#1,(a0)                         	| [$1f2b: dec     (hl)] decrease counter.  zero?
	jeq	l_1f34                             	| [$1f2c: jp      z,$1f34] yes, skip ahead

	lea	sprite_graphic_6a2d,a0         	| [$1f2f: ld      hl,sprite_graphic_6a2d] no, load HL with sprite graphic
	addq.b	#1,(a0)                         	| [$1f32: inc     (hl)] increase
	rts                                    	| [$1f33: ret] return

l_1f34:
	subq.w	#2,a0                           	| [$1f34: dec     l]
	                           	| [$1f35: dec     l] HL := 6345
	clr.b	d0                               	| [$1f36: xor     a] A := 0
	move.b	d0,(a0)                         	| [$1f37: ld      (hl),a] store into HL.  reset the item being hit with hammer
	move.b	d0,item_hit_indicator_unknown_6350	| [$1f38: ld      (item_hit_indicator_unknown_6350),a] store into item hit indicator
	addq.b	#1,d0                           	| [$1f3b: inc     a] A := 1
	move.b	d0,bonus_indicator_6340         	| [$1f3c: ld      (bonus_indicator_6340),a] store into bonus indicator
	lea	scoring_sprite_shadow_6a2c,a0   	| [$1f3f: ld      hl,scoring_sprite_shadow_6a2c] load HL with location of item hit
	STORE_RAM_ADDRESS_LE	a0,unknown_for_use_later_6343   	| [$1f42: ld      (unknown_for_use_later_6343),hl] store into #6343 for use later
	rts                                    	| [$1f45: ret] return

* called from main routine at #19A4

handle_mario_falling_1f46:
	tst.b	mario_falling_indicator_6221 	| [$1f46: ld      a,(mario_falling_indicator_6221)] load A with falling indicator.  also set when mario lands from jumping off elevator
	                               	| [$1f49: and     a] is mario falling?
	bne.b	0f                               	| [...]
	rts                                    	| [$1f4a: ret     z] no, return [...]
0:

* mario is falling

											| [$1f4b: xor     a] A := 0
	clr.b	unknown_6204                 	| [$1f4c: ld      (unknown_6204),a]
	clr.b	unknown_6206                 	| [$1f4f: ld      (unknown_6206),a]
	clr.b	mario_falling_indicator_6221 	| [$1f52: ld      (mario_falling_indicator_6221),a] clear mario falling indicator
	clr.b	mario_jump_direction_6210    	| [$1f55: ld      (mario_jump_direction_6210),a] clear jump direction
	clr.b	unknown_6211                 	| [$1f58: ld      (unknown_6211),a]
	clr.b	this_indicator_6212          	| [$1f5b: ld      (this_indicator_6212),a] clear this indicator (???)
	clr.b	unknown_6213                 	| [$1f5e: ld      (unknown_6213),a]
	clr.b	jump_counter_6214            	| [$1f61: ld      (jump_counter_6214),a] clear jump counter
	moveq	#1,d0                           	| [$1f64: inc     a] A := 1
	move.b	d0,jumping_status_6216          	| [$1f65: ld      (jumping_status_6216),a] set jump indicator
	move.b	d0,mario_jump_apex_621f         	| [$1f68: ld      (mario_jump_apex_621f),a] set #621F = 1 when mario is at apex or on way down after jump, 0 otherwise.
	move.b	mario_y_position_6205,d0	| [$1f6b: ld      a,(mario_y_position_6205)] load A with ???
	move.b	d0,unknown_620e                 	| [$1f6e: ld      (unknown_620e),a] store into ???
	rts                                    	| [$1f71: ret] return

* called from main routine at #1983
* used to roll barrels

handle_barrel_rolls_1f72:
	move.b	screen_number_6227,d0           	| [$1f72: ld      a,(screen_number_6227)] load a with screen number
	subq.b	#1,d0                           	| [$1f75: dec     a] is this the girders ?
	beq.b	0f                               	| [...]
	rts                                    	| [$1f76: ret     nz] no, return [...]
0:

* yes, we are on girders
* this subroutine checks the barrels, if any are rolling it does something, otherwise returns
	lea	start_of_barrel_info_table_6700,a2	| [$1f77: ld      ix,start_of_barrel_info_table_6700] load IX with start of barrel array
	lea	start_of_bouncers_or_barrels_sprites_6980,a0	| [$1f7b: ld      hl,start_of_bouncers_or_barrels_sprites_6980] load HL with start of sprites used for barrels
	move.w	#0x0020,d3                      	| [$1f7e: ld      de,$0020] load DE with offset of #20.  used for checking next barrel 32
	move.b	#NB_BARRELS,d1                        	| [$1f81: ld      b,$0a] for B = 1 to #0A ( do for each barrel)

l_1f83:
	move.b	(a2),d0                    	| [$1f83: ld      a,(ix+$00)] Load A with Barrel indicator (0 = no barrel, 2 = being deployed, 1=rolling)
	subq.b	#1,d0                           	| [$1f86: dec     a] Is this barrel rolling ?
	jeq	l_1f93                             	| [$1f87: jp      z,$1f93] Yes, jump ahead

	addq.w	#3,a0                           	| [$1f8a: inc     l]*3 otherwise increase (pointer) L by 3
l_1f8d:
	addq.w	#1,a0                           	| [$1f8d: inc     l]*4 actually
	add.w	d3,a2                            	| [$1f8e: add     ix,de] Add offset to check for next barrel
	subq.b	#1,d1                           	| [...]
	jne	l_1f83                             	| [$1f90: djnz    $1f83] Next B

	rts                                    	| [$1f92: ret] return

* barrel is rolling
l_1f93:
	move.b	(0x01,a2),d0                    	| [$1f93: ld      a,(ix+$01)] Load Crazy Barrel indicator
	subq.b	#1,d0                           	| [$1f96: dec     a] is this a crazy barrel?
	jeq	l_20ec                             	| [$1f97: jp      z,$20ec] Yes, jump ahead
	CLEAR_XC_FLAGS
	move.b	(0x02,a2),d0                    	| [$1f9a: ld      a,(ix+$02)] no load A with next indicator - determines the direction of the barrel
	roxr.b	#1,d0                           	| [$1f9d: rra] Is this barrel going down a ladder?
	jcs	l_1fac                             	| [$1f9e: jp      c,$1fac] Yes, jump away to ladder sub.

	roxr.b	#1,d0                           	| [$1fa1: rra] Is this barrel moving right?
	jcs	barrel_moves_to_right_1fe5                             	| [$1fa2: jp      c,$1fe5] yes, jump away to move right sub.

	roxr.b	#1,d0                           	| [$1fa5: rra] is this barrel moving left?
	jcs	barrel_moves_to_left_1fef                             	| [$1fa6: jp      c,$1fef] yes, jump to moving left sub

	jra	l_2053                             	| [$1fa9: jp      $2053] else jump ahead

* arrived here because the barrel is going down a ladder from #1F9E

l_1fac:
	jbsr	exx                               	| [$1fac: exx] exchange HL, DE, and BC with their clones
	addq.b	#1,(0x05,a2)                    	| [$1fad: inc     (ix+$05)] increase the barrels Y position ( move it down)
	move.b	(0x17,a2),d0                    	| [$1fb0: ld      a,(ix+$17)] load A with the bottom Y location of the ladder we are on

* #6717 = bottom position of next ladder it is going down or the ladder it just passed.
* ladders bottoms are at :  70, 6A, 93, 8D, 8B, B3, B0, AC, D1, CD, F3, EE

	cmp.b	(0x05,a2),d0                     	| [$1fb3: cp      (ix+$05)] check against item's Y position.  are we at the bottom of this ladder?
	jne	l_1fce                             	| [$1fb6: jp      nz,$1fce] no, jump ahead

* barrel reached bottom of ladder

	move.b	(0x15,a2),d0                    	| [$1fb9: ld      a,(ix+$15)] load A with Barrel #15 indicator, zero = normal barrel,  1 = blue barrel
	rol.b	#2,d0                            	| [$1fbc: rlca] roll left twice (multiply by 4) * 2
	add.b	#0x15,d0                         	| [$1fbe: add     a,$15] add #15
	move.b	d0,(0x07,a2)                    	| [$1fc0: ld      (ix+$07),a] store into +7 indicator = sprite used

* #6707 - right 2 bits are 01 when rolling, 10 when being deployed.  bit 7 toggles as it rolls

	move.b	(0x02,a2),d0                    	| [$1fc3: ld      a,(ix+$02)] load A with direction of barrel
	eor.b	#0x07,d0                         	| [$1fc6: xor     $07] XOR right 3 bits - reverses direction ?
	move.b	d0,(0x02,a2)                    	| [$1fc8: ld      (ix+$02),a] store back in direction
	jra	l_21ba                             	| [$1fcb: jp      $21ba] jump ahead

* we arrived here because we are not at the bottom of the ladder
* animates barrel as it rolls down ladder?

l_1fce:
	move.b	(0x0f,a2),d0                    	| [$1fce: ld      a,(ix+$0f)] load A with barrel #0F counter (from 4 to 1)
	subq.b	#1,d0                           	| [$1fd1: dec     a] decrement, has it reached 0?
	jne	l_1fdf                             	| [$1fd2: jp      nz,$1fdf] No, jump ahead, store into counter and continue on

* else animate the barrel

	move.b	(0x07,a2),d0                    	| [$1fd5: ld      a,(ix+$07)] yes, Load A with #07 indicator = sprite used
	eor.b	#0x01,d0                         	| [$1fd8: xor     $01] toggle bit 1
	move.b	d0,(0x07,a2)                    	| [$1fda: ld      (ix+$07),a] store back in #07 indicator = toggle sprite
	move.b	#0x04,d0                        	| [$1fdd: ld      a,$04] A := 4

l_1fdf:
	move.b	d0,(0x0f,a2)                    	| [$1fdf: ld      (ix+$0f),a] store A into barrel #0F counter (from 4 to 1)
	jra	l_21ba                             	| [$1fe2: jp      $21ba] jump ahead

* we arrived here because the barrel is moving to the right

barrel_moves_to_right_1fe5:
	jbsr	exx                               	| [$1fe5: exx] exchange HL, DE, and BC with their clones
	move.b	#0x01,d1                        	| [$1fe6: ld      bc,$0100] BC := #0100 deltax = 1
	move.b	#0x00,d2                        	| [$1fe6: ld      bc,$0100] BC := #0100 256
	addq.b	#1,(0x03,a2)                    	| [$1fe9: inc     (ix+$03)] Increase Barrel's X posiition
	jra	barrel_moves_laterally_1ff6                             	| [$1fec: jp      $1ff6] jump ahead

* we arrived here because the barrel is moving to the left

barrel_moves_to_left_1fef:
	jbsr	exx                               	| [$1fef: exx] exchange HL, DE, and BC with their clones
	move.b	#0xff,d1                        	| [$1ff0: ld      bc,$ff04] load BC with #FF04 deltax = -1
	move.b	#0x04,d2                        	| [$1ff0: ld      bc,$ff04] load BC with #FF04
	subq.b	#1,(0x03,a2)                    	| [$1ff3: dec     (ix+$03)] decrease barrel's X position

* we are here because the barrel is moving either left or right

barrel_moves_laterally_1ff6:
	move.b	(0x03,a2),d5                    	| [$1ff6: ld      h,(ix+$03)] load H with barrel's X position
	move.b	(0x05,a2),d6                    	| [$1ff9: ld      l,(ix+$05)] load L with barrel's Y position
	move.b	d5,d0                           	| [$1ffc: ld      a,h] load A with barrel's X position
	and.b	#0x07,d0                         	| [$1ffd: and     $07] mask left 5 bits to zero.  result is between 0 and 7
	cmp.b	#0x03,d0                         	| [$1fff: cp      $03] compare with #03
	jeq	l_215f                             	| [$2001: jp      z,$215f] equal to #03, jump ahead to check for ladders ?

	subq.b	#3,d6                           	| [$2004: dec     l] otherwise decrease L 3 times * 3
	jbsr	l_2333                            	| [$2007: call    $2333] check for barrel going down a slanted girder ?
	addq.b	#3,d6                           	| [$200a: inc     l] increase L back to what it was * 3
	move.b	d6,d0                           	| [$200d: ld      a,l] Load A with Barrel's Y position
	move.b	d0,(0x05,a2)                    	| [$200e: ld      (ix+$05),a] store back into barrel's y position
	jbsr	l_23de                            	| [$2011: call    $23de]
	jbsr	barrel_running_into_oil_can_24b4                            	| [$2014: call    $24b4]
	move.b	(0x03,a2),d0                    	| [$2017: ld      a,(ix+$03)] Load A with Barrels' X position
	cmp.b	#0x1c,d0                         	| [$201a: cp      $1c] have we arrived at left edge of girder?
	jcs	l_202f                             	| [$201c: jp      c,$202f] yes, jump ahead to handle

	cmp.b	#0xe4,d0                         	| [$201f: cp      $e4] else , have we arrived at right edge of girder?
	jcs	l_21ba                             	| [$2021: jp      c,$21ba] no, jump way ahead - we're done, store values and try next barrel

* right edge of girder

	clr.b	d0                               	| [$2024: xor     a] A := 0
	move.b	d0,(0x10,a2)                    	| [$2025: ld      (ix+$10),a] clear #10 barrel index to 0
	move.b	#0x60,(0x11,a2)                 	| [$2028: ld      (ix+$11),$60] store #60 into barrel +#11  , indicates a roll over the right edge
	jra	l_2038                             	| [$202c: jp      $2038] skip next 3 steps

* arrive here when barrel at left edge of girder

l_202f:
	clr.b	d0                               	| [$202f: xor     a] A := 0
	move.b	#0xff,(0x10,a2)                 	| [$2030: ld      (ix+$10),$ff] Set Barrel #10 index with #FF
	move.b	#0xa0,(0x11,a2)                 	| [$2034: ld      (ix+$11),$a0] set barrel #11 index with #A0 - indicates a roll over left edge

l_2038:
	move.b	#0xff,(0x12,a2)                 	| [$2038: ld      (ix+$12),$ff]
	move.b	#0xf0,(0x13,a2)                 	| [$203c: ld      (ix+$13),$f0]
	move.b	d0,(0x14,a2)                    	| [$2040: ld      (ix+$14),a]
	move.b	d0,(0x0e,a2)                    	| [$2043: ld      (ix+$0e),a] clear the barrel's edge indicator
	move.b	d0,(0x04,a2)                    	| [$2046: ld      (ix+$04),a] clear ???
	move.b	d0,(0x06,a2)                    	| [$2049: ld      (ix+$06),a]
	move.b	#0x08,(0x02,a2)                 	| [$204c: ld      (ix+$02),$08] load barrel properties with various numbers to indicate edge roll?
	jra	l_21ba                             	| [$2050: jp      $21ba] jump way ahead - we're done, store values and try next barrel

* jump from #1FA9
* we arrive here because the barrel isn't going left, right, or down a ladder
* could be crazy barrel or barrel going over edge

l_2053:
	jbsr	exx                               	| [$2053: exx] Exchange DE, HL, BC with counterparts
	jbsr	update_barrel_variables_239c                            	| [$2054: call    $239c] update barrel position ?
	jbsr	l_2a2f                            	| [$2057: call    $2a2f] ???  set A to zero or 1 depending on ???
	tst.b	d0                               	| [$205a: and     a] iS A == 0 ?
	jne	l_2083                             	| [$205b: jp      nz,$2083] no, jump ahead

	move.b	(0x03,a2),d0                    	| [$205e: ld      a,(ix+$03)] load A with barrel X position
	add.b	#0x08,d0                         	| [$2061: add     a,$08] Add #08
	cmp.b	#0x10,d0                         	| [$2063: cp      $10] compare with #10
	jcs	l_2079                             	| [$2065: jp      c,$2079] If carry, jump ahead, clear barrel, (rolled off screen?)

	jbsr	barrel_running_into_oil_can_24b4  	| [$2068: call    $24b4] check for barrel running into oil can?
	move.b	(0x10,a2),d0                    	| [$206b: ld      a,(ix+$10)] load A with +10 = rolling over edge / direction indicator
	and.b	#0x01,d0                         	| [$206e: and     $01] mask all bits but 1.  result is 0 or 1
	rol.b	#2,d0                            	| [$2070: rlca] rotate left * 2
	move.b	d0,d2                           	| [$2072: ld      c,a] copy into C
	jbsr	l_23de                            	| [$2073: call    $23de] ???
	jra	l_21ba                             	| [$2076: jp      $21ba] skip ahead

l_2079:
	clr.b	d0                               	| [$2079: xor     a] A := 0
	move.b	d0,(a2)                    	| [$207a: ld      (ix+$00),a] clear barrel active indicator
	move.b	d0,(0x03,a2)                    	| [$207d: ld      (ix+$03),a] clear barrel X position
	jra	l_21ba                             	| [$2080: jp      $21ba] done, store values and try next barrel

* barrel has landed on a new girder after going over edge, or has just done so and is bouncing

l_2083:
	addq.b	#1,(0x0e,a2)                    	| [$2083: inc     (ix+$0e)] increase +E (???)
	move.b	(0x0e,a2),d0                    	| [$2086: ld      a,(ix+$0e)] load A with this value
	subq.b	#1,d0                           	| [$2089: dec     a] decrease.  zero? (did this barrel just land???)
	jeq	l_20a2                             	| [$208a: jp      z,$20a2] yes, skip ahead

	subq.b	#1,d0                           	| [$208d: dec     a] else decrease again.  zero?
	jeq	l_20c3                             	| [$208e: jp      z,$20c3] yes, skip ahead

* barrel has finsished its edge maneuever

	move.b	#0x04,d0                        	| [$2095: ld      a,$04] A := 4 = rolling left code
	move.b	(0x10,a2),d7                    	| [$2091: ld      a,(ix+$10)] else load A with +10 = rolling over edge/direction indicator
	subq.b	#1,d7                           	| [$2094: dec     a] decrease.  was this value a 1 ?  (barrel moving right)
	jne	l_209c                             	| [$2097: jp      nz,$209c] no, skip next step
	move.b	#0x02,d0                        	| [$209a: ld      a,$02] else A := 2
l_209c:
	move.b	d0,(0x02,a2)                    	| [$209c: ld      (ix+$02),a] store into motion indicator.  02 = rolling right, 08 = rolling down, 04 = rolling left, bit 1 set when rolling down ladder
	jra	l_21ba                             	| [$209f: jp      $21ba] jump ahead

* barrel has landed on a new girder after going over edge

l_20a2:
	move.b	(0x15,a2),d0                    	| [$20a2: ld      a,(ix+$15)] load A with Barrel #15 indicator, zero = normal barrel,  1 = blue barrel
	                               	| [$20a5: and     a] is this a blue barrel?
	jne	l_20b5                             	| [$20a6: jp      nz,$20b5] yes, skip ahead, blue barrels always continue all the way down

* normal barrel traversed edge

	lea	mario_y_position_6205,a0	| [$20a9: ld      hl,mario_y_position_6205] load HL with mario's Y position address
	move.b	(0x05,a2),d0                    	| [$20ac: ld      a,(ix+$05)] load A with +5 = barrel's Y position
	sub.b	#0x16,d0                         	| [$20af: sub     $16] subtract #16
	cmp.b	(a0),d0                          	| [$20b1: cp      (hl)] compare to mario Y position.  is the barrel below mario?
	jcc	l_20c3                             	| [$20b2: jp      nc,$20c3] yes, skip next 5 steps

l_20b5:
	move.b	(0x10,a2),d0                    	| [$20b5: ld      a,(ix+$10)] load A with +10 = rolling over edge/direction indicator
	                               	| [$20b8: and     a] A == 0 ? is this barrel is rolling right?
	jne	l_20e1                             	| [$20b9: jp      nz,$20e1] no, skip ahead and set alternate values, continue at #20C3

	move.b	d0,(0x11,a2)                    	| [$20bc: ld      (ix+$11),a] else set +11 (???) to zero
	move.b	#0xff,(0x10,a2)                 	| [$20bf: ld      (ix+$10),$ff] set +10 = rolling over edge indicator to #FF for rolling left

* barrel has just finished bouncing after going around ledge

l_20c3:
	jbsr	l_2407                            	| [$20c3: call    $2407] ???
	lsr.b	#1,d5                            	| [$20c6: srl     h]
	roxr.b	#1,d6                           	| [$20c8: rr      l]
	lsr.b	#1,d5                            	| [$20ca: srl     h]
	roxr.b	#1,d6                           	| [$20cc: rr      l]
	move.b	d5,(0x12,a2)                    	| [$20ce: ld      (ix+$12),h] store H into +#12 (???)
	move.b	d6,(0x13,a2)                    	| [$20d1: ld      (ix+$13),l] store L into +#13 (???)
												| [$20d4: xor     a] A := 0
	clr.b	(0x14,a2)                    	| [$20d5: ld      (ix+$14),a] clear +#14 (???)
	clr.b	(0x04,a2)                    	| [$20d8: ld      (ix+$04),a] clear +#4 (???)
	clr.b	(0x06,a2)                    	| [$20db: ld      (ix+$06),a] clear +#6 (???)
	jra	l_21ba                             	| [$20de: jp      $21ba] skip ahead

l_20e1:
	move.b	#0x01,(0x10,a2)                 	| [$20e1: ld      (ix+$10),$01] set +10 = rolling over edge indicator to 1 for rolling right
	clr.b	(0x11,a2)                        	| [$20e5: ld      (ix+$11),$00] set +11 = ??? to 0
	jra	l_20c3                             	| [$20e9: jp      $20c3] jump back

* we arrived here because its a crazy barrel from #1F97
* this is called for every pixel the barrel moves

l_20ec:
	jbsr	exx                               	| [$20ec: exx] exchange BC, DE, and HL with their alternates
	jbsr	update_barrel_variables_239c                            	| [$20ed: call    $239c] update Barrel's variables ?. H now has +5 and L has +6
	move.b	d5,d0                           	| [$20f0: ld      a,h] Load A with H = +5 = Y position
	sub.b	#0x1a,d0                         	| [$20f1: sub     $1a] Subtract #1A (26 decimal)
	move.b	(0x19,a2),d1                    	| [$20f3: ld      b,(ix+$19)] load B with Barrel status #19 (?)
	cmp.b	d1,d0                            	| [$20f6: cp      b] compare A with B
	jcs	l_2104                             	| [$20f7: jp      c,$2104] jump on carry ahead

	jbsr	l_2a2f                            	| [$20fa: call    $2a2f] else call this sub (???)
	tst.b	d0                               	| [$20fd: and     a] is A == 0 ?
	jne	l_2118                             	| [$20fe: jp      nz,$2118] No, jump ahead

	jbsr	barrel_running_into_oil_can_24b4                            	| [$2101: call    $24b4] else call this sub (???)

l_2104:
	move.b	(0x03,a2),d0                    	| [$2104: ld      a,(ix+$03)] load A with barrel X position
	add.b	#0x08,d0                         	| [$2107: add     a,$08] add 8
	cmp.b	#0x10,d0                         	| [$2109: cp      $10] result < #10 ?
	jcc	l_1fce                             	| [$210b: jp      nc,$1fce] No, jump back and ???

	clr.b	d0                               	| [$210e: xor     a] yes, A := 0
	move.b	d0,(a2)                    	| [$210f: ld      (ix+$00),a] set barrel status indicator #0 to 0 (barrel is gone)
	move.b	d0,(0x03,a2)                    	| [$2112: ld      (ix+$03),a] set barrel x position to 0
	jra	l_21ba                             	| [$2115: jp      $21ba] write to sprites and check next barrel

l_2118:
	move.b	(0x05,a2),d0                    	| [$2118: ld      a,(ix+$05)] load A with barrel's Y position
	cmp.b	#0xe0,d0                         	| [$211b: cp      $e0] < #E0 ? - are we at bottom of screen?
	jcs	l_2146                             	| [$211d: jp      c,$2146] no, jump ahead

* else this crazy barrel is no longer crazy

	move.b	(0x07,a2),d0                    	| [$2120: ld      a,(ix+$07)] else Load A with +7 = sprite used
	and.b	#0xfc,d0                         	| [$2123: and     $fc] clear right 2 bits
	or.b	#0x01,d0                          	| [$2125: or      $01] turn on bit 0
	move.b	d0,(0x07,a2)                    	| [$2127: ld      (ix+$07),a] store result
	clr.b	d0                               	| [$212a: xor     a] A := 0
	move.b	d0,(0x01,a2)                    	| [$212b: ld      (ix+$01),a] barrel is no longer crazy
	move.b	d0,(0x02,a2)                    	| [$212e: ld      (ix+$02),a]
	st.b	(0x10,a2)                 	| [$2131: ld      (ix+$10),$ff] set velocity to -1 (move left)
	move.b	d0,(0x11,a2)                    	| [$2135: ld      (ix+$11),a]
	move.b	d0,(0x12,a2)                    	| [$2138: ld      (ix+$12),a]
	move.b	#0xb0,(0x13,a2)                 	| [$213b: ld      (ix+$13),$b0]
	move.b	#0x01,(0x0e,a2)                 	| [$213f: ld      (ix+$0e),$01]
	jra	l_2153                             	| [$2143: jp      $2153] jump ahead

* arrive here when crazy barrel hits a girder from #211D

l_2146:
	jbsr	l_2407                            	| [$2146: call    $2407] load HL based on +14 status. also uses +11 and +12
	jbsr	l_22cb                            	| [$2149: call    $22cb] do stuff for crazy barrels ?
	move.b	(0x05,a2),d0                    	| [$214c: ld      a,(ix+$05)] load A with barrel Y position
	move.b	d0,(0x19,a2)                    	| [$214f: ld      (ix+$19),a] store in barrel #19 status.  used for crazy barrels?
	clr.b	d0                               	| [$2152: xor     a] A := 0

l_2153:
	move.b	d0,(0x14,a2)                    	| [$2153: ld      (ix+$14),a] clear +#14 (???)
	move.b	d0,(0x04,a2)                    	| [$2156: ld      (ix+$04),a] clear +#4 (???)
	move.b	d0,(0x06,a2)                    	| [$2159: ld      (ix+$06),a] store 0 in these barrel indicators
	jra	l_21ba                             	| [$215c: jp      $21ba] jump ahead - we're done, store values and try next barrel

* arrive here every 8 pixels moved by barrel from #2001
* L has barrels Y pos
* H has barrels X pos

l_215f:
	move.b	d6,d0                           	| [$215f: ld      a,l] load A with barrels Y position

	addq.b	#0x05,d0                        	| [$2160: add     a,$05] add 5
	move.b	d0,d3                           	| [$2162: ld      d,a] store into D
	move.b	d5,d0                           	| [$2163: ld      a,h] load A with barrels X position
	move.w	#0x15,d1                        	| [$2164: ld      bc,$0015] load BC with #15 to check for all ladders 21
	jbsr	l_216d                            	| [$2167: call    $216d] check for going down ladder
	jra	l_21ba                             	| [$216a: jp      $21ba] skip ahead

* called from #2167

l_216d:
	jbsr	check_for_ladders_nearby_236e                            	| [$216d: call    $236e] check for ladder.  if no ladders, RET to higher sub.  if at top of ladder, A := 1
	subq.b	#1,d0                           	| [$2170: dec     a] is there a ladder to go down?
	beq.b	0f                               	| [...]
	rts                                    	| [$2171: ret     nz] no, return [...]
0:

	move.b	d1,d0                           	| [$2172: ld      a,b] yes, load A with B which has the value of the ladder from the check ??
	subq.b	#0x05,d0                        	| [$2173: sub     $05] subtract 5
	move.b	d0,(0x17,a2)                    	| [$2175: ld      (ix+$17),a] store into +17 to indicate which ladder we might be going down ???
	move.b	the_oil_can_is_on_fire_6348,d0  	| [$2178: ld      a,(the_oil_can_is_on_fire_6348)] get status of the oil can fire
	                               	| [$217b: and     a] is the fire lit ?
	jeq	l_21b2                             	| [$217c: jp      z,$21b2] no, always take ladders before oil is lit

	move.b	mario_y_position_6205,d0	| [$217f: ld      a,(mario_y_position_6205)] else load A with mario's Y position + 5
	subq.b	#0x04,d0                        	| [$2182: sub     $04] subtract 4
	cmp.b	d3,d0                            	| [$2184: cp      d] is the barrel already below mario  ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$2185: ret     c] yes, return without taking ladder [...]
0:

	move.b	difficulty_level_6380,d0                 	| [$2186: ld      a,(difficulty_level_6380)] else load A with difficulty from 1 to 5.  usually the level but increases during play
	ror.b	#1,d0                           	| [$2189: rra] roll right (div 2) .  now can be 0, 1, or 2
	addq.b	#1,d0                           	| [$218a: inc     a] increment.  result is now 1, 2, or 3 based on skill level
	move.b	d0,d1                           	| [$218b: ld      b,a] store into B
	move.b	rngtimer1_6018,d0               	| [$218c: ld      a,(rngtimer1_6018)] load A with random timer ?
	move.b	d0,d2                           	| [$218f: ld      c,a] store into C for later use ?
	and.b	#0x03,d0                         	| [$2190: and     $03] mask bits.   result now random number between 0 and 3
	cmp.b	d1,d0                            	| [$2192: cp      b] compare with value computed above based on skill
	bcs.b	0f                               	| [...]
	rts                                    	| [$2193: ret     nc] return if greater.  on highest skill this works 75% of time, only returns on 3 [...]
0:

	lea	inputstate_6010,a0             	| [$2194: ld      hl,inputstate_6010] load HL with player input.

* InputState - copy of RawInput, except when jump is pressed, bit 7 is set momentarily
* RawInput - right sets bit 0, left sets bit 1, up sets bit 2, down sets bit 3, jump sets bit 4

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2197: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's x position
	cmp.b	d4,d0                            	| [$219a: cp      e] compare with barrel's x position
	jeq	l_21b2                             	| [$219b: jp      z,$21b2] if equal, then go down ladder

	jcc	l_21a9                             	| [$219e: jp      nc,$21a9] if barrel is to right of mario, then check for moving to left

	btst.b	#0,(a0)                         	| [$21a1: bit     0,(hl)] else is mario trying to move right ?
	jeq	l_21ae                             	| [$21a3: jp      z,$21ae] no, skip ahead and return without going down ladder

	jra	l_21b2                             	| [$21a6: jp      $21b2] yes, make barrel go down ladder

l_21a9:
	btst.b	#1,(a0)                         	| [$21a9: bit     1,(hl)] is mario trying to move left ?
	jne	l_21b2                             	| [$21ab: jp      nz,$21b2] yes, make barrel go down ladder

l_21ae:
	move.b	d2,d0                           	| [$21ae: ld      a,c] else load A with random timer computed above
	and.b	#0x18,d0                         	| [$21af: and     $18] mask with #18.    25% chance of being zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$21b1: ret     nz] else return without going down ladder.  If zero then go down the ladder anyway [...]
0:

l_21b2:
	addq.b	#1,(0x07,a2)                    	| [$21b2: inc     (ix+$07)] increase Barrel's deployment/animation status
	bset.b	#0,(0x02,a2)                    	| [$21b5: set     0,(ix+$02)] set barrel to go down the ladder
	rts                                    	| [$21b9: ret] return

* we arrive here because the barrel is rolling left or right or turning a corner or a crazy barrel
* stores position values, sprite value and colors into sprite values
* arrive from several locations, eg #20DE

l_21ba:
	jbsr	exx                               	| [$21ba: exx] swap DE, HL, and BC with counterparts
	move.b	(0x03,a2),d0                    	| [$21bb: ld      a,(ix+$03)] load A with Barrels X position
	move.b	d0,(a0)+                         	| [$21be: ld      (hl),a] store into sprite X position
	                           	| [$21bf: inc     l] HL := HL + 1
	move.b	(0x07,a2),d0                    	| [$21c0: ld      a,(ix+$07)] load A with Barrels deployment/animation status
	move.b	d0,(a0)+                         	| [$21c3: ld      (hl),a] store into sprite value
	                           	| [$21c4: inc     l] HL := HL + 1
	move.b	(0x08,a2),d0                    	| [$21c5: ld      a,(ix+$08)] load A with Barrel's color
	move.b	d0,(a0)+                         	| [$21c8: ld      (hl),a] Store into sprite color
	                           	| [$21c9: inc     l] HL := HL + 1
	move.b	(0x05,a2),d0                    	| [$21ca: ld      a,(ix+$05)] Load A with Barrel's Y position
	move.b	d0,(a0)                         	| [$21cd: ld      (hl),a] store into sprite Y position
	jra	l_1f8d                             	| [$21ce: jp      $1f8d] jump back and check for next barrel

* data used in sub below for attract mode movement
* first byte is movement, second is duration

*fe                  | jump
*c0                  | run right
*21D5,0x04,0x50     | up = climb ladder
*21D7,0x02,0x10     | run left
*21D9,0x82,0x60     | jump left
*21DB,0x02,0x10     | run left
*ca                  | jump left
*21DF,0x01,0x10     | run right
*ff                  | jump right (gets hammer)
*21E3,0x02,0x38     | run left
*21E5,0x01,0x80     | run right - mario dies falling over right edge
*ff                  | run left
*21E9,0x04,0x80     | up
*21EB,0x04,0x60     | up
*21ED,0x80        | ?

* called during attract mode only from #1977

l_21ee:
	lea	game_rom+0x21d1,a1                      	| [$21ee: ld      de,$21d1] load DE with start of table data
	lea	state_of_attract_mode_63cc,a0  	| [$21f1: ld      hl,state_of_attract_mode_63cc] load HL with state of attract mode
	moveq	#0,d0
	move.b	(a0)+,d0                         	| [$21f4: ld      a,(hl)] load A with state
	rol.b	#1,d0                            	| [$21f5: rlca] rotate left (x2)
	add.w	d0,a1                            	| [$21f6: add     a,e] add to E to get the movement
												| [$21f7: ld      e,a] put back
	move.b	(a1),d0                         	| [$21f8: ld      a,(de)] load A with data from table
	move.b	d0,inputstate_6010              	| [$21f9: ld      (inputstate_6010),a] store into copy of input
												| [$21fc: inc     l] HL := #63CD (timer)
	move.b	(a0),d0                         	| [$21fd: ld      a,(hl)] load timer
	subq.b	#1,(a0)                         	| [$21fe: dec     (hl)] decrement
	tst.b	d0                               	| [$21ff: and     a] == #00 ?
	beq.b	0f                               	| [...]
	rts                                    	| [$2200: ret     nz] no, return [...]
0:

	addq.w	#1,a1                           	| [$2201: inc     e] else next movement
	move.b	(a1),d0                         	| [$2202: ld      a,(de)] load A with timer from table
	move.b	d0,(a0)                         	| [$2203: ld      (hl),a] store into timer
									| [$2204: dec     l] HL := #63CC (state)
	addq.b	#1,-(a0)                         	| [$2205: inc     (hl)] increase state
	rts                                    	| [$2206: ret] return

* arrive here from main routine at #199B

l_2207:
	move.b	#0x02,d0                        	| [$2207: ld      a,$02] load A with 2 = 0010 binary
	jbsr	only_continues_if_given_level_0030                            	| [$2209: rst     $30] only continues here on conveyors, else returns from subroutine

	move.b	framecounter_601a,d7            	| [$220a: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	                           	| [$220d: rra] time to do this ?
	lea	left_side_rectractable_ladder_6280,a0	| [$220e: ld      hl,left_side_rectractable_ladder_6280] load HL with left side rectractable ladder
	move.b	(a0),d0                         	| [$2211: ld      a,(hl)] load A with ladder status
	btst	#1,d7
	jne	l_2219                             	| [$2212: jp      c,$2219] if clock is odd, skip next 2 steps
 
	lea	right_side_retractable_ladder_6288,a0	| [$2215: ld      hl,right_side_retractable_ladder_6288] load HL with right side retractable ladder
	move.b	(a0),d0                         	| [$2218: ld      a,(hl)] load A with ladder status

l_2219:

	move.l	a0,-(sp)                        	| [$2219: push    hl] save HL
	jbsr	rst_28                            	| [$221a: rst     $28] jump based on A

	.long	ladder_up_2227  | #2227         A = 0   ladder is all the way up
	.long	ladder_moving_down_2259  | #2259         A = 1   ladder is moving down
	.long	ladder_down_2299  | #2299         A = 2   ladder is all the way down
	.long	ladder_moving_up_22a2  | #22A2         A = 3   ladder is moving up

* ladder is all the way up
ladder_up_2227:
	move.l	(sp)+,a0                        	| [$2227: pop     hl] restore HL - it has the ladder address
	addq.w	#1,a0                           	| [$2228: inc     l] HL := #6289 or #6281 - timer for movement ???
	subq.b	#1,(a0)                         	| [$2229: dec     (hl)] decrement.  at zero ?
	jne	l_223a                             	| [$222a: jp      nz,$223a] no, skip ahead and check to disable moving ladder indicator

												| [$222d: dec     l] put HL back where it was
	addq.b	#1,-(a0)                         	| [$222e: inc     (hl)] increase ladder status.  now it is moving down
	addq.w	#2,a0                           	| [$222f: inc     l] * 2
	jbsr	l_2243                            	| [$2231: call    $2243] only continue below if mario is on the ladder

	move.b	#0x01,d0                        	| [$2234: ld      a,$01] A := 1
	move.b	d0,moving_ladder_indicator_621a 	| [$2236: ld      (moving_ladder_indicator_621a),a] store into moving ladder indicator
	rts                                    	| [$2239: ret] return

l_223a:
	addq.w	#1,a0                           	| [$223a: inc     l] HL := #628A or #6282
	jbsr	l_2243                            	| [$223b: call    $2243] only continue below if mario is on the ladder, else RET

	clr.b	d0                               	| [$223e: xor     a] A := 0
	move.b	d0,moving_ladder_indicator_621a 	| [$223f: ld      (moving_ladder_indicator_621a),a] store into moving ladder indicator
	rts                                    	| [$2242: ret] return

* called from #2231 above with HL = #628A
* called from #223B above with HL = #628A
* called from #2276 below

l_2243:
	move.b	mario_y_position_6205,d0	| [$2243: ld      a,(mario_y_position_6205)] load mario's Y position
	cmp.b	#0x7a,d0                         	| [$2246: cp      $7a] is mario on the top pie tray level or above?
	jcc	l_2257                             	| [$2248: jp      nc,$2257] no, skip ahead and return to higher sub

	move.b	jumping_status_6216,d0          	| [$224b: ld      a,(jumping_status_6216)] yes, check for a jump in progress ?
	                               	| [$224e: and     a] is mario jumping ?
	jne	l_2257                             	| [$224f: jp      nz,$2257] yes, jump ahead and return to higher sub

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2252: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] else load A with mario's X position
	cmp.b	(a0),d0                          	| [$2255: cp      (hl)] is mario on the ladder? (or exactly lined up on it)
	bne.b	0f                               	| [...]
	rts                                    	| [$2256: ret     z] yes, return [...]
0:

l_2257:
	move.l	(sp)+,a0                        	| [$2257: pop     hl] adjust stack pointer
	rts                                    	| [$2258: ret] return to higher subroutine

* arrive from #221A when ladder is moving down

ladder_moving_down_2259:
	move.l	(sp)+,a0                        	| [$2259: pop     hl] restore HL = ladder status
	addq.w	#4,a0                           	| [$225a: inc     l] * 4
	subq.b	#1,(a0)                         	| [$225e: dec     (hl)] decrease.  at zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$225f: ret     nz] no, return [...]
0:

	move.b	#0x04,d0                        	| [$2260: ld      a,$04] A := 4
	move.b	d0,(a0)                         	| [$2262: ld      (hl),a] store into the ladder's ???
	                           	| [$2263: dec     l] HL now has the ladder's ???
	addq.b	#1,-(a0)                         	| [$2264: inc     (hl)] increase
	jbsr	update_ladder_sprite_22bd                            	| [$2265: call    $22bd] ???
	move.b	#0x78,d0                        	| [$2268: ld      a,$78] A := #78
	cmp.b	(a0),d0                          	| [$226a: cp      (hl)] == (HL) ?
	jne	l_2275                             	| [$226b: jp      nz,$2275] no, skip ahead

	                           	| [$226e: dec     l] * 3
	addq.b	#1,(-3,a0)                         	| [$2271: inc     (hl)]
	                           	| [$2272: inc     l] * 3

l_2275:
	subq.w	#1,a0                           	| [$2275: dec     l] HL now has ???
	jbsr	l_2243                            	| [$2276: call    $2243] only continue below if mario is on the ladder, else RET

* ladder is moving down and mario is on it

	move.b	mario_y_position_6205,d0	| [$2279: ld      a,(mario_y_position_6205)] load A with mario Y position
	cmp.b	#0x68,d0                         	| [$227c: cp      $68] is mario already at the low point of the ladder ?
	jcc	l_228a                             	| [$227e: jp      nc,$228a] yes, skip ahead

l_2281:
	lea	mario_y_position_6205,a0	| [$2281: ld      hl,mario_y_position_6205] else load HL with Mario's Y position
	addq.b	#1,(a0)                         	| [$2284: inc     (hl)] increase (move mario down one pixel)
	jbsr	l_3fc0                            	| [$2285: call    $3fc0] sets mario sprite to on ladder with left hand up and HL to #694F (mario's sprite Y position) [this line seems like a patch ??? orig could be  LD HL,#694F ]
	addq.b	#1,(a0)                         	| [$2288: inc     (hl)] increase sprite (move mario down one pixel in the hardware .  immediate update)
	rts                                    	| [$2289: ret] return

l_228a:
	roxr.b	#1,d0                           	| [$228a: rra] rotate right A.  is A odd ?
	jcs	l_2281                             	| [$228b: jp      c,$2281] yes, loop back

	roxr.b	#1,d0                           	| [$228e: rra] else rotate right A again.  is the 2-bit set ?
	jcs	l_2295                             	| [$2291: jp      c,$2295] yes, skip next step
 
	clr.b	d0                               	| [$2294: xor     a] A := 0
	jra		l_2295_2
l_2295:
	move.b	#0x01,d0                        	| [$228f: ld      a,$01] A := 1
l_2295_2:
	move.b	d0,ladder_toggle_6222           	| [$2295: ld      (ladder_toggle_6222),a] store into ladder toggle
	rts                                    	| [$2298: ret] return

* arrive from #221A when ladder is all the way down

ladder_down_2299:
	move.l	(sp)+,a0                        	| [$2299: pop     hl] restore HL
	move.b	rngtimer1_6018,d0               	| [$229a: ld      a,(rngtimer1_6018)] load A with random timer
	and.b	#0x3c,d0                         	| [$229d: and     $3c] mask bits.  result zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$229f: ret     nz] no, return [...]
0:

	addq.b	#1,(a0)                         	| [$22a0: inc     (hl)] else increase (HL) - the ladder is now moving up
	rts                                    	| [$22a1: ret] return

* arrive from jump at #221A
* a rectractable ladder is moving up
* HL popped from stack is either 6280 for left ladder or 6288 for right ladder

ladder_moving_up_22a2:
	move.l	(sp)+,a0                        	| [$22a2: pop     hl] restore HL
	addq.w	#4,a0                           	| [$22a3: inc     l] * 4
	subq.b	#1,(a0)                         	| [$22a7: dec     (hl)] decrease (HL).  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$22a8: ret     nz] no, return [...]
0:

	move.b	#0x02,(a0)                      	| [$22a9: ld      (hl),$02] else set (HL) to 2
											| [$22ab: dec     l]
	subq.b	#1,-(a0)                         	| [$22ac: dec     (hl)] decrease ladder Y value - makes ladder move up
	jbsr	update_ladder_sprite_22bd                            	| [$22ad: call    $22bd] update the sprite
	move.b	#0x68,d0                        	| [$22b0: ld      a,$68] A := #68
	cmp.b	(a0),d0                          	| [$22b2: cp      (hl)] reached top of ladder movement?
	beq.b	0f                               	| [...]
	rts                                    	| [$22b3: ret     nz] no, return [...]
0:

* ladder has moved all the way up

	clr.b	d0                               	| [$22b4: xor     a] A := 0
	move.b	#0x80,d1                        	| [$22b5: ld      b,$80] B := #80
	subq.w	#2,a0                           	| [$22b7: dec     l] * 2
	move.b	d1,(a0)                         	| [$22b9: ld      (hl),b]
											| [$22ba: dec     l] set HL to ladder status
	move.b	d0,-(a0)                         	| [$22bb: ld      (hl),a] set ladder status to 0 == all the way up
	rts                                    	| [$22bc: ret] return

* called from #22AD above and from #2265
* HL is preloaded with ladder Y position

update_ladder_sprite_22bd:
	move.b	(a0),d0                         	| [$22bd: ld      a,(hl)] load A with ladder Y value
	move.l	a0,d7
	sub.l	#ram_6000,d7
	lea	ladder_sprite_y_value_694b,a1  	| [$22c0: ld      de,ladder_sprite_y_value_694b] load DE with ladder sprite Y value
	btst.b	#3,d7                           	| [$22be: bit     3,l] test bit 3 of L
	jne	l_22c9                             	| [$22c3: jp      nz,$22c9] if other ladder, skip next step

	lea	other_ladder_sprite_y_value_6947,a1	| [$22c6: ld      de,other_ladder_sprite_y_value_6947] load DE with other ladder sprite Y value
l_22c9:
	move.b	d0,(a1)                         	| [$22c9: ld      (de),a] update the sprite Y value
	rts                                    	| [$22ca: ret] return

* arrive here when crazy barrel is onscreen
* called when barrel deployed or hits a girder on the way down
* called from #2149

l_22cb:
	move.b	the_oil_can_is_on_fire_6348,d0  	| [$22cb: ld      a,(the_oil_can_is_on_fire_6348)] load A with oil can status
	                               	| [$22ce: and     a] is the oil can lit ?
	jeq	l_22e1                             	| [$22cf: jp      z,$22e1] no , jump ahead

	move.b	difficulty_level_6380,d0                 	| [$22d2: ld      a,(difficulty_level_6380)] else load A with difficulty
	subq.b	#1,d0                           	| [$22d5: dec     a] decrement.  will be between 0 and 4
	jbsr	rst_28                            	| [$22d6: rst     $28] jump based on A

	.long	l_22f6  | #
	.long	l_22f6  | #
	.long	l_2303  | #
	.long	l_2303  | #
	.long	l_231a  | #

* arrive here when oil can is not yet lit
* used for initial crazy barrel

l_22e1:
	move.b	level_number_6229,d0       	| [$22e1: ld      a,(level_number_6229)] load A with level #
	move.b	d0,d1                           	| [$22e4: ld      b,a] store into B
	move.b	#0x01,d0                        	| [$22e6: ld      a,$01] load A with 1
	subq.b	#1,d1                           	| [$22e5: dec     b] decrement B
	jeq	l_22f9                             	| [$22e8: jp      z,$22f9] if level was 1, then jump ahead
 
	move.b	#0xb1,d0                        	| [$22ec: ld      a,$b1] load A with #B1 - for use with level 2 inital crazy barrel
	subq.b	#1,d1                           	| [$22eb: dec     b] decrement B again
	jeq	l_22f9                             	| [$22ee: jp      z,$22f9] if level 2, then jump ahead

	move.b	#0xe9,d0                        	| [$22f1: ld      a,$e9] else load A with #E9 - for level 3 and up inital crazy barrel
	jra	l_22f9                             	| [$22f3: jp      $22f9] jump ahead and store

* check for use with crazy barrels when difficulty is 1 or 2

l_22f6:
	move.b	rngtimer1_6018,d0               	| [$22f6: ld      a,(rngtimer1_6018)] load A with random timer value

l_22f9:
	move.b	d0,(0x11,a2)                    	| [$22f9: ld      (ix+$11),a] store into +11
	and.b	#0x01,d0                         	| [$22fc: and     $01] mask bits, makes into #00 or #01
	subq.b	#1,d0                           	| [$22fe: dec     a] decrement, now either #00 or #FF
	move.b	d0,(0x10,a2)                    	| [$22ff: ld      (ix+$10),a] store into +10
	rts                                    	| [$2302: ret] return

* check for use with crazy barrels when difficulty is 3 or 4

l_2303:
	move.b	rngtimer1_6018,d0               	| [$2303: ld      a,(rngtimer1_6018)] load A with random timer value
	move.b	d0,(0x11,a2)                    	| [$2306: ld      (ix+$11),a] store into +11
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2309: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	cmp.b	(0x03,a2),d0                     	| [$230c: cp      (ix+$03)] compare barrel's X position
	jcc	l_2316                             	| [$2311: jp      nc,$2316] if greater then skip ahead
 
	move.b	#0x01,d0                        	| [$230f: ld      a,$01] load A with 1
	subq.b	#2,d0                           	| [$2314: dec     a] else decrement twice * 2
	jra		l_2316_2	
l_2316:
	move.b	#0x01,d0                        	| [$230f: ld      a,$01] load A with 1
l_2316_2:
	move.b	d0,(0x10,a2)                    	| [$2316: ld      (ix+$10),a] store into +10
	rts                                    	| [$2319: ret] return

* check for use with crazy barrels when difficulty is 5

l_231a:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$231a: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	sub.b	(0x03,a2),d0                     	| [$231d: sub     (ix+$03)] subtract the barrel's X position
	st.b	d2                                	| [$2320: ld      c,$ff] load C with #FF
	jcs	l_2326                             	| [$2322: jp      c,$2326] if barrel is to left of mario, then jump ahead

	addq.b	#1,d2                           	| [$2325: inc     c] else increase C to 0

l_2326:
	CLEAR_XC_FLAGS
	roxl.b	#1,d0                            	| [$2326: rlca] rotate left A (doubles A)
	roxl.b	#1,d2                           	| [$2327: rl      c] rotate left C

	CLEAR_XC_FLAGS
	roxl.b	#1,d0                            	| [$2329: rlca] rotate left A (doubles A)
	roxl.b	#1,d2                           	| [$232a: rl      c] rotate left C
 	move.b	d2,(0x10,a2)                    	| [$232c: ld      (ix+$10),c] store C into +10
	move.b	d0,(0x11,a2)                    	| [$232f: ld      (ix+$11),a] store A into +11
	rts                                    	| [$2332: ret]

* called from #2007 when barrels are rolling
* called from #     when mario is moving left or right on girders
* D5,D6 (HL) is preloaded with character (barrel, fireball, mario) X,Y position
* d1 (B) is preloaded with direction

l_2333:
	move.b	#0x0f,d0                        	| [$2333: ld      a,$0f] load A with binary 00001111
	and.b	d5,d0                            	| [$2335: and     h] and with H.  A now has between 0 and F
	subq.b	#1,d1                           	| [$2336: dec     b] Count down B.  is the direction == 1 ?
	jeq	l_2342                             	| [$2337: jp      z,$2342] yes, then skip ahead 4 steps

	cmp.b	#0x0f,d0                         	| [$233a: cp      $0f] else check is A still = #0F ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$233c: ret     c] return if Carry ( A < 0F ) most of time it wont? [...]
0:

	st.b	d1                                	| [$233d: ld      b,$ff] else B := #FF direction -1
	jra	l_2347                             	| [$233f: jp      $2347] skip next 3 steps

l_2342:
	cmp.b	#0x01,d0                         	| [$2342: cp      $01] A > 1 ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$2344: ret     nc] yes, return [...]
0:

	move.b	#0x01,d1                        	| [$2345: ld      b,$01] B := 1

l_2347:
	move.b	#0xf0,d0                        	| [$2347: ld      a,$f0] A := #F0
	cmp.b	d6,d0                            	| [$2349: cp      l] is A == L ?
	jeq	l_2360                             	| [$234a: jp      z,$2360] Yes, skip ahead

	move.b	#0x4c,d0                        	| [$234d: ld      a,$4c] A := #4C
	cmp.b	d6,d0                            	| [$234f: cp      l] == L ?
	jeq	l_2366                             	| [$2350: jp      z,$2366] yes, skip ahead

	move.b	d6,d0                           	| [$2353: ld      a,l]
	btst.b	#5,d0                           	| [$2354: bit     5,a]
	jeq	l_235c                             	| [$2356: jp      z,$235c]

l_2359:
	* apply inverse lateral direction
	sub.b	d1,d0                            	| [$2359: sub     b]
l_235a:
	move.b	d0,d6                           	| [$235a: ld      l,a]
	rts                                    	| [$235b: ret] return

l_235c:
	* apply lateral direction
	add.b	d1,d0                            	| [$235c: add     a,b] A := A + B
	jra	l_235a                             	| [$235d: jp      $235a] loop back

l_2360:
	btst.b	#7,d5                           	| [$2360: bit     7,h]
	jne	l_2359                             	| [$2362: jp      nz,$2359]
	rts                                    	| [$2365: ret] return

l_2366:
	move.b	d5,d0                           	| [$2366: ld      a,h] A := H
	cmp.b	#0x98,d0                         	| [$2367: cp      $98] < #98 ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$2369: ret     c] no, return [...]
0:

	move.b	d6,d0                           	| [$236a: ld      a,l] A := L
	jra	l_235c                             	| [$236b: jp      $235c] loop back

* called from #1B13 when jumping ?
* called from #216D when checking for barrel to go down a ladder?
* A has X position of barrel ?
* BC starts with #15
* called when firefoxs are moving to check for ladders
* if no ladder is nearby , it RETs to a higher subroutine

check_for_ladders_nearby_236e:
	lea	ladder_positions_6300,a0       	| [$236e: ld      hl,ladder_positions_6300] load HL with start of table data that has positions of ladders
l_2371:
	jbsr	cpir                              	| [$2371: cpir] check for ladders ???
	sne		d7
	move.b	d1,d2							| game expects d2 as index if found
	tst.b	d7
	jne	l_239a                             	| [$2373: jp      nz,$239a] if no match, return to higher sub, no ladder nearby


	move.l	a0,-(sp)                        	| [$2376: push    hl] else a ladder may be near. save HL
	movem.w	d1/d2,-(sp)                    	| [$2377: push    bc] save BC
	move.w	#0x14,d1                        	| [$2378: ld      bc,$0014] load BC with #14 for offset 20
	add.w	d1,a0                            	| [$237b: add     hl,bc] add #14 to HL.  Now HL has the ladder's other value ?
	addq.b	#1,d1                           	| [$237c: inc     c] C := #15
	move.b	d0,d4                           	| [$237d: ld      e,a] save A into E
	move.b	d3,d0                           	| [$237e: ld      a,d] load A with D = barrels position ?
	cmp.b	(a0),d0                          	| [$237f: cp      (hl)] compare with ladder's position
	jeq	l_238f                             	| [$2380: jp      z,$238f] if equal then jump ahead

	add.w	d1,a0                            	| [$2383: add     hl,bc] else add #15 into HL
	cmp.b	(a0),d0                          	| [$2384: cp      (hl)] compare position
	jeq	l_2395                             	| [$2385: jp      z,$2395] if equal then skip ahead

	move.b	d0,d3                           	| [$2388: ld      d,a] else load D with A
	move.b	d4,d0                           	| [$2389: ld      a,e] load A with E

	movem.w	(sp)+,d1/d2                    	| [$238a: pop     bc] restore BC
	move.l	(sp)+,a0                        	| [$238b: pop     hl] restore HL
	jra	l_2371                             	| [$238c: jp      $2371] check for next ladder?

* arrive here when a barrel is above a ladder

l_238f:
	add.w	d1,a0                            	| [$238f: add     hl,bc] add #15 into HL
	move.b	#0x01,d0                        	| [$2390: ld      a,$01] load A with 1 = signal that we are at top of ladder
	jra	l_2398                             	| [$2392: jp      $2398] jump ahead

l_2395:
	clr.b	d0                               	| [$2395: xor     a] else A: = 0 = signal that we are at bottom of ladder
	sub.w	d1,a0                            	| [$2396: sbc     hl,bc] subtract BC from HL.  restore HL to original value

l_2398:
	movem.w	(sp)+,d1/d2                    	| [$2398: pop     bc] restore BC
	move.b	(a0),d1                         	| [$2399: ld      b,(hl)] load B with value in HL

l_239a:
	move.l	(sp)+,a0                        	| [$239a: pop     hl] pop caller address, return immediately
	rts                                    	| [$239b: ret] return

* called from #20ED for crazy barrel movement.  for this, BC, DE,and HL have their alternates
* subroutine called from #2054.  used when barrels are rolling.  only called when rolling around edges
* or mario jumping???
* IX has the start value of barrel sprite.  EG 6700
* IX can have 6200 for mario from #1BC2

update_barrel_variables_239c:
	move.b	(0x04,a2),d0                    	| [$239c: ld      a,(ix+$04)] load modified Y position, used for crazy barrels hitting girders ???
	add.b	(0x11,a2),d0                     	| [$239f: add     a,(ix+$11)] add +11 = vertical speed?
	move.b	d0,(0x04,a2)                    	| [$23a2: ld      (ix+$04),a] update position ?

	move.b	(0x03,a2),d0                    	| [$23a5: ld      a,(ix+$03)] load object's X position
	move.b	(0x10,a2),d7
	addx.b	d7,d0								| adc     a,(ix+$10)  | add +10 = rolling over edge/direction indicator.  note this is add with carry
	move.b	d0,(0x03,a2)                    	| [$23ab: ld      (ix+$03),a] store into X position

	move.b	(0x06,a2),d0                    	| [$23ae: ld      a,(ix+$06)] load A with +6 == ??
	sub.b	(0x13,a2),d0                     	| [$23b1: sub     (ix+$13)] subtract +13 == ??
	move.b	d0,d6                           	| [$23b4: ld      l,a] store into L
	move.b	(0x05,a2),d0                    	| [$23b5: ld      a,(ix+$05)] load A with barrel Y position
	move.b	(0x12,a2),d7
	subx.b	d7,d0                    	| [$23b8: sbc     a,(ix+$12)] subtract vertical speed????

	move.b	d0,d5                           	| [$23bb: ld      h,a] store into H
	move.b	(0x14,a2),d0                    	| [$23bc: ld      a,(ix+$14)] load +14 = mirror of modified Y position?.  used for jump counter when mario jumps
	CLEAR_XC_FLAGS                               	| [$23bf: and     a] clear flags
	roxl.b	#1,d0                           	| [$23c0: rla] rotate left (mult by 2)
	addq.b	#1,d0                           	| [$23c1: inc     a] add 1
	clr.b	d1                               	| [$23c2: ld      b,$00] B := 0
	roxl.b	#1,d1                           	| [$23c4: rl      b]
	asl.b	#1,d0                            	| [$23c6: sla     a]
	roxl.b	#1,d1                           	| [$23c8: rl      b]
	asl.b	#1,d0                            	| [$23ca: sla     a]
	roxl.b	#1,d1                           	| [$23cc: rl      b]
	asl.b	#1,d0                            	| [$23ce: sla     a]
	roxl.b	#1,d1                           	| [$23d0: rl      b]
	lsl.w	#8,d1
	move.b	d0,d1                           	| [$23d2: ld      c,a] copy answer (A) to C. BC now has ???
	LOAD_D5_16_FROM_D5D6
	add.w	d1,d5                            	| [$23d3: add     hl,bc] add to HL
	LOAD_D5D6_FROM_D5_16
	move.b	d5,(0x05,a2)                    	| [$23d4: ld      (ix+$05),h] update Y position
	move.b	d6,(0x06,a2)                    	| [$23d7: ld      (ix+$06),l] update +6
	addq.b	#1,(0x14,a2)                    	| [$23da: inc     (ix+$14)] increase +14.  used for 6214 for mario as a jump counter
	rts                                    	| [$23dd: ret] return

* called from subs that are moving a barrel left or right
* IX is memory base of the barrel in question (e.g. #6700)
* called from #2073 with C either 0 or 4
* C is preloaded with mask ?


l_23de:
	move.b	(0x0f,a2),d0                    	| [$23de: ld      a,(ix+$0f)] Load A with +#F property of barrel (counts from 4 to 1 over and over)
	subq.b	#1,d0                           	| [$23e1: dec     a] decrease by one.  did counter go to zero?
	jne	l_2403                             	| [$23e2: jp      nz,$2403] if not, jump ahead, store new timer value and return

	clr.b	d0                               	| [$23e5: xor     a] A := 0
	move.b	(0x07,a2),d7
	asl.b	#1,d7                     	| [$23e6: sla     (ix+$07)] shift left the barrel sprite status, push bit 7 into carry flag
	move.b	d7,(0x07,a2)
	roxl.b	#1,d0                           	| [$23ea: rla] rotate in carry flag into A
	move.b	(0x08,a2),d7
	asl.b	#1,d7                     	| [$23eb: sla     (ix+$08)] shift left the other barrel color, push bit 7 into carry flag
	move.b	d7,(0x08,a2)
	roxl.b	#1,d0                           	| [$23ef: rla] rotate in carry flag into A
	move.b	d0,d1                           	| [$23f0: ld      b,a] copy result into B
	move.b	#0x03,d0                        	| [$23f1: ld      a,$03] A := 3
	or.b	d2,d0                             	| [$23f3: or      c] bitwise OR with C
	jbsr	l_3009                            	| [$23f4: call    $3009] ???
	CLEAR_XC_FLAGS
	roxr.b	#1,d0                           	| [$23f7: rra]
	move.b	(0x08,a2),d7
	roxr.b	#1,d7                    	| [$23f8: rr      (ix+$08)] rotate right the barrel's color
	move.b	d7,(0x08,a2)
	roxr.b	#1,d0                           	| [$23fc: rra]
	move.b	(0x07,a2),d7
	roxr.b	#1,d7                    	| [$23fd: rr      (ix+$07)] Roll these values back
	move.b	d7,(0x07,a2)
	move.b	#0x04,d0                        	| [$2401: ld      a,$04] A := 4

l_2403:
	move.b	d0,(0x0f,a2)                    	| [$2403: ld      (ix+$0f),a] store A into timer
	rts                                    	| [$2406: ret] return

*
* called from #1BDF and #20C3 and #2146
*

l_2407:
	move.b	(0x14,a2),d0                    	| [$2407: ld      a,(ix+$14)] load A with Barrel +14 status
	rol.b	#4,d0                            	| [$240a: rlca] * 4
	move.b	d0,d2                           	| [$240e: ld      c,a] save to C for use next 2 steps
	and.b	#0x0f,d0                         	| [$240f: and     $0f] mask with #0F.  now between #00 and #0F
	move.b	d0,d5                           	| [$2411: ld      h,a] store into H
	move.b	d2,d0                           	| [$2412: ld      a,c] restore A to value saved above
	and.b	#0xf0,d0                         	| [$2413: and     $f0] mask with #F0
	move.b	d0,d6                           	| [$2415: ld      l,a] store into L
	move.b	(0x13,a2),d2                    	| [$2416: ld      c,(ix+$13)] load C with +13
	move.b	(0x12,a2),d1                    	| [$2419: ld      b,(ix+$12)] load B with +12
	LOAD_D1_16_FROM_D1D2
	LOAD_D5_16_FROM_D5D6
	sub.w	d1,d5                            	| [$241c: sbc     hl,bc] HL := HL - BC
	LOAD_D5D6_FROM_D5_16
	rts                                    	| [$241e: ret] return

* arrive here when jump not pressed ?
* sets DE based on mario's position
* called from #1AE6
* called from #1BC5
* called from #2B09

l_241f:
	move.b	#0x01,d3
	move.b	#0x00,d4                      	| [$241f: ld      de,$0100] D = 1, E:= 0
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2422: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with Mario's X position
	cmp.b	#0x16,d0                         	| [$2425: cp      $16] is this greater than #16 ?
	bcc.b	0f                               	| [...]
	rts                                    	| [$2427: ret     c] yes, return [...]
0:

	subq.b	#1,d3                           	| [$2428: dec     d] no,
	addq.b	#1,d4                           	| [$2429: inc     e] DE := #0001
	cmp.b	#0xea,d0                         	| [$242a: cp      $ea] is Mario's position > #EA ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$242c: ret     nc] yes, return [...]
0:

	subq.b	#1,d4                           	| [$242d: dec     e] no, DE:= #0000
	move.b	screen_number_6227,d0           	| [$242e: ld      a,(screen_number_6227)] load A with screen number (01, 10, 11 or 100)
	ror.b	#1,d0                            	| [$2431: rrca] rotate right with carry.  is this the girders or elevators?
	bcs.b	0f                               	| [...]
	rts                                    	| [$2432: ret     nc] no, return [...]
0:

	move.b	mario_y_position_6205,d0	| [$2433: ld      a,(mario_y_position_6205)] otherwise load A with mario's Y position
	cmp.b	#0x58,d0                         	| [$2436: cp      $58] is this > #58 ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$2438: ret     nc] Yes, return [...]
0:

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2439: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] else load A with mario's X position
	cmp.b	#0x6c,d0                         	| [$243c: cp      $6c] is this > #6C ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$243e: ret     nc] Yes, return [...]
0:

	addq.b	#1,d3                           	| [$243f: inc     d] else DE := #0100
	rts                                    	| [$2440: ret] and return

* called from #0D62

* checksum ???

        * 3F00:  5C 76 49 4A 01 09 08 01 3F 7D 77 1E 19 1E 24 15  .(C)1981...NINTE
        * 3F10:  1E 14 1F 10 1F 16 10 11 1D 15 22 19 13 11 10 19  NDO.OF.AMERICA.I

* called from #0D62
* 1.  runs checksum on the NINTENDO, breaks if not correct
* 2.

*
* part 1 can be skipped now!
*

l_2441:
*	lea	game_rom+0x3f0c,a0                      	| [$2441: ld      hl,$3f0c] load HL with ROM area that has NINTENDO written
*	move.b	#0x5e,d0                        	| [$2444: ld      a,$5e] A := #5E = constant so the checksum comes to zero
*	move.b	#0x06,d1                        	| [$2446: ld      b,$06] for B = 1 to 6
*
*l_2448:
*	add.b	(a0)+,d0                          	| [$2448: add     a,(hl)] add this letter
*												| [$2449: inc     hl] next letter
*	subq.b	#1,d1                           	| [...]
*	jne	l_2448                             	| [$244a: djnz    $2448] loop until done
*
	lea	unknown_6310,a3                	| [$244c: ld      iy,unknown_6310]
*	tst.b	d0                               	| [$2450: and     a] A == 0 ? checksum OK ?
*	jeq	l_2456                             	| [$2451: jp      z,$2456] yes, skip next step
*
*	addq.w	#1,a3                           	| [$2454: inc     iy] running this step will break the game ?  loops at #2371 forever
*
*l_2456:
	move.b	screen_number_6227,d0           	| [$2456: ld      a,(screen_number_6227)] load A with screen number
	subq.b	#1,d0                           	| [$2459: dec     a] is this the girders?
	lea	game_rom+0x3ae4,a0                      	| [$245a: ld      hl,$3ae4] load HL with start of table data for girders
	jeq	l_2471                             	| [$245d: jp      z,$2471] if girders, skip ahead

	subq.b	#1,d0                           	| [$2460: dec     a] else is this the conveyors?
	lea	game_rom+0x3b5d,a0                      	| [$2461: ld      hl,$3b5d] load HL with start of table data for conveyors
	jeq	l_2471                             	| [$2464: jp      z,$2471] if conveyors, skip ahead

	subq.b	#1,d0                           	| [$2467: dec     a] else is this the elevators?
	lea	game_rom+0x3be5,a0                      	| [$2468: ld      hl,$3be5] load HL with start of table data for elevators
	jeq	l_2471                             	| [$246b: jp      z,$2471] if elevators, skip ahead

	lea	game_rom+0x3c8b,a0                      	| [$246e: ld      hl,$3c8b] otherwise we're on rivets.  load HL with table data for rivets

l_2471:
	lea	ladder_positions_6300,a2       	| [$2471: ld      ix,ladder_positions_6300] #6300 is used for ladder positions?
	move.w	#0x0005,d3                      	| [$2475: ld      de,$0005] DE := 5 = offset 5

l_2478:
	move.b	(a0),d0                         	| [$2478: ld      a,(hl)] load A with the next item of data
	                               	| [$2479: and     a] is this item == 0 ?
	jeq	l_2488                             	| [$247a: jp      z,$2488] yes, jump ahead

	subq.b	#1,d0                           	| [$247d: dec     a] no, decrease, was this item == 1 ?
	jeq	l_249e                             	| [$247e: jp      z,$249e] yes, jump down instead

	cmp.b	#0xa9,d0                         	| [$2481: cp      $a9] was the item == #AA ?
	bne.b	0f                               	| [...]
	rts                                    	| [$2483: ret     z] yes, return, we are done with this.  AA is at the end of each table [...]
0:

	add.w	d3,a0                            	| [$2484: add     hl,de] if neither then add offset for next HL
	jra	l_2478                             	| [$2485: jp      $2478] loop again

* data element was #01

l_2488:
	addq.w	#1,a0                           	| [$2488: inc     hl] next HL
	move.b	(a0)+,d0                         	| [$2489: ld      a,(hl)] load A with table data (EG #3B12)
	move.b	d0,(a2)                    	| [$248a: ld      (ix+$00),a] store into index
	                           	| [$248d: inc     hl] next HL
	move.b	(a0),d0                         	| [$248e: ld      a,(hl)] load A with table data
	move.b	d0,(0x15,a2)                    	| [$248f: ld      (ix+$15),a] store into index +#15
	addq.w	#2,a0                           	| [$2492: inc     hl] * 2
	move.b	(a0)+,d0                         	| [$2494: ld      a,(hl)] load A with table data
	move.b	d0,(0x2a,a2)                    	| [$2495: ld      (ix+$2a),a] store into index +#2A
	addq.w	#1,a2                           	| [$2498: inc     ix] next location
												| [$249a: inc     hl] next table data
	jra	l_2478                             	| [$249b: jp      $2478] jump back

* data element was #02
* this sub is same as one above but uses IY instead of IX

l_249e:
	addq.w	#1,a0                           	| [$249e: inc     hl]
	move.b	(a0)+,d0                         	| [$249f: ld      a,(hl)]
	move.b	d0,(a3)                    	| [$24a0: ld      (iy+$00),a]
												| [$24a3: inc     hl]
	move.b	(a0),d0                         	| [$24a4: ld      a,(hl)]
	move.b	d0,(0x15,a3)                    	| [$24a5: ld      (iy+$15),a]
	addq.w	#2,a0                           	| [$24a8: inc     hl] * 2
	move.b	(a0)+,d0                         	| [$24aa: ld      a,(hl)]
	move.b	d0,(0x2a,a3)                    	| [$24ab: ld      (iy+$2a),a]
	addq.w	#1,a3                           	| [$24ae: inc     iy]
												| [$24b0: inc     hl]
	jra	l_2478                             	| [$24b1: jp      $2478] jump back

* called this sub from barrel roll from #2068
* check for barrel collision with the oil can ????

barrel_running_into_oil_can_24b4:
	move.b	(0x05,a2),d0                    	| [$24b4: ld      a,(ix+$05)] load A with Barrel Y position
	cmp.b	#0xe8,d0                         	| [$24b7: cp      $e8] Is it near the bottom or lower?
	bcc.b	0f                               	| [...]
	rts                                    	| [$24b9: ret     c] if so, return [...]
0:

	move.b	(0x03,a2),d0                    	| [$24ba: ld      a,(ix+$03)] else load A with Barrel X position
	cmp.b	#0x2a,d0                         	| [$24bd: cp      $2a] is X position < #2A ? (rolling oever edge on left side of screen)
	bcs.b	0f                               	| [...]
	rts                                    	| [$24bf: ret     nc] no, return [...]
0:

	cmp.b	#0x20,d0                         	| [$24c0: cp      $20] is it past the edge of girder?
	bcc.b	0f                               	| [...]
	rts                                    	| [$24c2: ret     c] no, return [...]
0:

	move.b	(0x15,a2),d0                    	| [$24c3: ld      a,(ix+$15)] load A with Barrel #15 indicator, zero = normal barrel,  1 = blue barrel
	                               	| [$24c6: and     a] is this a normal barrel?
	jeq	l_24d0                             	| [$24c7: jp      z,$24d0] yes, jump ahead

	move.b	#0x03,d0                        	| [$24ca: ld      a,$03] else blue barrel, A := 3
	move.b	d0,fire_release_62b9            	| [$24cc: ld      (fire_release_62b9),a] store into #62B9 - used for releasing fires ?
	clr.b	d0                               	| [$24cf: xor     a] A := #00

l_24d0:
	move.b	d0,(a2)                    	| [$24d0: ld      (ix+$00),a] clear out the barrel active indicator
	move.b	d0,(0x03,a2)                    	| [$24d3: ld      (ix+$03),a] clear out the barrel X position
	lea	boom_sound_address_6082,a0     	| [$24d6: ld      hl,boom_sound_address_6082] load HL with boom sound address
	move.w	#BOOM_SND,d0
	jbsr	osd_sound_start
	move.b	#0x03,(a0)                      	| [$24d9: ld      (hl),$03] play boom sound for 3 units
	move.l	(sp)+,a0                        	| [$24db: pop     hl] get HL from stack
	move.b	the_oil_can_is_on_fire_6348,d0  	| [$24dc: ld      a,(the_oil_can_is_on_fire_6348)] turns to 1 when the oil can is on fire
	                               	| [$24df: and     a] is oil can already on fire ?
	jne	l_21ba                             	| [$24e0: jp      nz,$21ba] yes, jump back, we are done

	addq.b	#1,d0                           	| [$24e3: inc     a] else A := 1
	move.b	d0,the_oil_can_is_on_fire_6348  	| [$24e4: ld      (the_oil_can_is_on_fire_6348),a] set the oil can is on fire
	jra	l_21ba                             	| [$24e7: jp      $21ba] jump back , we are done.

* called from main routine at #1992
* copies pie buffer to pie sprites

l_24ea:
	move.b	#0x02,d0                        	| [$24ea: ld      a,$02] check level for conveyors
	jbsr	only_continues_if_given_level_0030                            	| [$24ec: rst     $30] if not conveyors, RET, else continue
	jbsr	l_2523                            	| [$24ed: call    $2523] check for deployment of new pies
	jbsr	l_2591                            	| [$24f0: call    $2591] update all pies positions based on direction of trays, remove pies in fire or off edge
	lea	start_of_pies_65a0,a2          	| [$24f3: ld      ix,start_of_pies_65a0] load IX with start of pies
	move.b	#NB_PIES,d1                        	| [$24f7: ld      b,$06] for B = 1 to 6 pies
	lea	start_of_pie_sprites_69b8,a0   	| [$24f9: ld      hl,start_of_pie_sprites_69b8] load HL with hardware address for pies

l_24fc:
	move.b	(a2),d0                    	| [$24fc: ld      a,(ix+$00)] load A with sprite status
	                               	| [$24ff: and     a] is this sprite active ?
	jeq	l_251c                             	| [$2500: jp      z,$251c] no, add 4 to L and loop again

	move.b	(0x03,a2),d0                    	| [$2503: ld      a,(ix+$03)] load A with pie X position
	move.b	d0,(a0)+                         	| [$2506: ld      (hl),a] store into sprite
	                           	| [$2507: inc     l] next address
	move.b	(0x07,a2),d0                    	| [$2508: ld      a,(ix+$07)] load A with pie sprite value
	move.b	d0,(a0)+                         	| [$250b: ld      (hl),a] store into sprite
	                           	| [$250c: inc     l] next address
	move.b	(0x08,a2),d0                    	| [$250d: ld      a,(ix+$08)] load A with pie color
	move.b	d0,(a0)+                         	| [$2510: ld      (hl),a] store into sprite
	                           	| [$2511: inc     l] next address
	move.b	(0x05,a2),d0                    	| [$2512: ld      a,(ix+$05)] load A with pie Y position
	move.b	d0,(a0)+                         	| [$2515: ld      (hl),a] store into sprite
	                           	| [$2516: inc     l] next address

* called from "pie/cement" factory
* d3 has been checked and is OK (0x10)
l_2517:
	add.w	d3,a2                            	| [$2517: add     ix,de] add offset for next pie
	subq.b	#1,d1                           	| [...]
	jne	l_24fc                             	| [$2519: djnz    $24fc] next B

	rts                                    	| [$251b: ret] return

l_251c:
											| [$251c: ld      a,l] A := L
	addq.w	#0x04,a0                        	| [$251d: add     a,$04] add 4
											| [$251f: ld      l,a] store into L
	jra	l_2517                             	| [$2520: jp      $2517] loop back for next pie

* called from #24ED above

l_2523:
	lea	pie_timer_for_next_pie_deployment_639b,a0	| [$2523: ld      hl,pie_timer_for_next_pie_deployment_639b] load HL with pie timer
	move.b	(a0),d0                         	| [$2526: ld      a,(hl)] get timer value
	                               	| [$2527: and     a] time to release a pie ?
	jne	l_258f                             	| [$2528: jp      nz,$258f] no, decrease counter and return

	move.b	deployment_indicator_639a,d0    	| [$252b: ld      a,(deployment_indicator_639a)] load A with fire deployment indicator ???
	                               	| [$252e: and     a] == 0 ? (are there no fires???)
	bne.b	0f                               	| [...]
	rts                                    	| [$252f: ret     z] yes, return, no pies until fires are released [...]
0:

* look for a pie to deploy

	move.b	#NB_PIES,d1                        	| [$2530: ld      b,$06] for B = 1 to 6 pies
	move.w	#0x0010,d3                      	| [$2532: ld      de,$0010] load DE with offset of #10 (16 decimal) 16
	lea	start_of_pies_65a0,a2          	| [$2535: ld      ix,start_of_pies_65a0] load IX with start of pie sprites table

l_2539:
	btst.b	#0,(a2)                    	| [$2539: bit     0,(ix+$00)] is this pie already onscreen?
	jeq	l_2545                             	| [$253d: jp      z,$2545] no, jump ahead and deploy this pie

	add.w	d3,a2                            	| [$2540: add     ix,de] else load offset for next pie
	subq.b	#1,d1                           	| [...]
	jne	l_2539                             	| [$2542: djnz    $2539] next B

	rts                                    	| [$2544: ret] return [no room for more pies, 6 already onscreen]

* deploy a pie

l_2545:
	jbsr	random_0057                            	| [$2545: call    $0057] load A with a random number
	move.b	#0x7c,(0x05,a2)                 	| [$254a: ld      (ix+$05),$7c] store #7C into pie's Y position
	cmp.b	#0x60,d0                         	| [$2548: cp      $60] < #60 ?
	jcs	l_2558                             	| [$254e: jp      c,$2558] yes, skip next 3 steps

	move.b	master_direction_vector_for_upper_left_62a3,d0	| [$2551: ld      a,(master_direction_vector_for_upper_left_62a3)] load A with master direction for middle conveyor
	subq.b	#1,d0                           	| [$2554: dec     a] is this tray moving outwards ?
	jne	l_256e                             	| [$2555: jp      nz,$256e] no, skip ahead

l_2558:
	move.b	#0xcc,(0x05,a2)                 	| [$2558: ld      (ix+$05),$cc] store #CC into pie's Y position
	move.b	master_direction_vector_for_lower_level_62a6,d0	| [$255c: ld      a,(master_direction_vector_for_lower_level_62a6)] load A with master direction vector for lower conveyor
	rol.b	#1,d0                            	| [$255f: rlca] is this tray moving to the right ?
	scs		d7

l_2560:
	move.b	#0x07,(0x03,a2)                 	| [$2560: ld      (ix+$03),$07] set pie X position to 7
	tst.b	d7
	jeq	l_2576                             	| [$2564: jp      nc,$2576] if tray moving right, skip ahead
 
	move.b	#0xf8,(0x03,a2)                 	| [$2567: ld      (ix+$03),$f8] set pie X position to #F8
	jra	l_2576                             	| [$256b: jp      $2576] skip ahead

l_256e:
	jbsr	random_0057                            	| [$256e: call    $0057] load A with random number
	cmp.b	#0x68,d0                         	| [$2571: cp      $68] < #68 ?
	scs		d7
	jra	l_2560                             	| [$2573: jp      $2560] use to decide to put on left or right side

l_2576:
	move.b	#0x01,(a2)                 	| [$2576: ld      (ix+$00),$01] set pie active
	move.b	#0x4b,(0x07,a2)                 	| [$257a: ld      (ix+$07),$4b] set pie sprite value
	move.b	#0x08,(0x09,a2)                 	| [$257e: ld      (ix+$09),$08] set pie size??? (width?)
	move.b	#0x03,(0x0a,a2)                 	| [$2582: ld      (ix+$0a),$03] set pie size??? (height?)
	move.b	#0x7c,d0                        	| [$2586: ld      a,$7c] A := #7C
	move.b	d0,pie_timer_for_next_pie_deployment_639b	| [$2588: ld      (pie_timer_for_next_pie_deployment_639b),a] store into pie timer for next pie deployment
	clr.b	d0                               	| [$258b: xor     a] A := 0
	move.b	d0,deployment_indicator_639a    	| [$258c: ld      (deployment_indicator_639a),a] store into ???

l_258f:
	subq.b	#1,(a0)                         	| [$258f: dec     (hl)] decrease pie timer
	rts                                    	| [$2590: ret] return

* called from #24F0 above
* updates all pies

l_2591:
	lea	start_of_pies_65a0,a2          	| [$2591: ld      ix,start_of_pies_65a0] load IX with pie sprite buffer
	move.w	#0x0010,d3                      	| [$2595: ld      de,$0010] load DE with offset 16
	move.b	#NB_PIES,d1                        	| [$2598: ld      b,$06] for B = 1 to 6

l_259a:
	btst.b	#0,(a2)                    	| [$259a: bit     0,(ix+$00)] active ?
	jeq	l_25bb                             	| [$259e: jp      z,$25bb] no, skip ahead and loop for next

	move.b	(0x03,a2),d0                    	| [$25a1: ld      a,(ix+$03)] load A with pie's X position
	move.b	d0,d5                           	| [$25a4: ld      h,a] copy to H
	addq.b	#0x07,d0                        	| [$25a5: add     a,$07] Add 7
	cmp.b	#0x0e,d0                         	| [$25a7: cp      $0e] < #E ? (pie < 6 or pie > #F9)
	jcs	l_25d6                             	| [$25a9: jp      c,$25d6] yes, skip ahead to handle

	move.b	(0x05,a2),d0                    	| [$25ac: ld      a,(ix+$05)] load A with pie Y position
	cmp.b	#0x7c,d0                         	| [$25af: cp      $7c] is this the top level pie?
	jeq	l_25c0                             	| [$25b1: jp      z,$25c0] yes, skip ahead

	move.b	pie_direction_lower_level_63a6,d0	| [$25b4: ld      a,(pie_direction_lower_level_63a6)] load A with pie direction vector for lower pie level
	add.b	d5,d0                            	| [$25b7: add     a,h] add vector to original position
	move.b	d0,(0x03,a2)                    	| [$25b8: ld      (ix+$03),a] store into pie X position

l_25bb:
	add.w	d3,a2                            	| [$25bb: add     ix,de] add offset for next sprite
	subq.b	#1,d1                           	| [...]
	jne	l_259a                             	| [$25bd: djnz    $259a] next B

	rts                                    	| [$25bf: ret] return

l_25c0:
	move.b	d5,d0                           	| [$25c0: ld      a,h] load A with pie X position
	cmp.b	#0x80,d0                         	| [$25c1: cp      $80] is the pie in the center fire?
	scs		d7
	jeq	l_25d6                             	| [$25c3: jp      z,$25d6] yes, skip ahead

	move.b	upper_right_pie_tray_vector_63a5,d0	| [$25c6: ld      a,(upper_right_pie_tray_vector_63a5)] load A with direction for upper left pie tray
	tst.b	d7
	jeq	l_25cf                             	| [$25c9: jp      nc,$25cf] if pie < #80, use this address and skip next step

	move.b	upper_left_pie_tray_vector_63a4,d0	| [$25cc: ld      a,(upper_left_pie_tray_vector_63a4)] else load A with direction for upper right tray

l_25cf:
	add.b	d5,d0                            	| [$25cf: add     a,h] add vector to pie position
	move.b	d0,(0x03,a2)                    	| [$25d0: ld      (ix+$03),a] store into pie X position
	jra	l_25bb                             	| [$25d3: jp      $25bb] loop for next sprite

* pie in center fire or reached edge

l_25d6:
	lea	start_of_pie_sprites_69b8,a0   	| [$25d6: ld      hl,start_of_pie_sprites_69b8] load HL with start of pie sprites
	move.b	#NB_PIES,d0                        	| [$25d9: ld      a,$06] A := 6
	sub.b	d1,d0                            	| [$25db: sub     b] subtract the pie number that is removed.  zero ?
l_25dc:
	jeq	l_25e7                             	| [$25dc: jp      z,$25e7] yes, skip ahead

	addq.w	#4,a0                           	| [$25df: inc     l] * 4
	subq.b	#1,d0                           	| [$25e3: dec     a] decrease A
	jra	l_25dc                             	| [$25e4: jp      $25dc] loop again

l_25e7:
	clr.b	d0                               	| [$25e7: xor     a] A := 0
	move.b	d0,(a2)                    	| [$25e8: ld      (ix+$00),a] clear pie active indicator
	move.b	d0,(0x03,a2)                    	| [$25eb: ld      (ix+$03),a] clear pie X position
	move.b	d0,(a0)                         	| [$25ee: ld      (hl),a] clear sprite from screen
	jra	l_25bb                             	| [$25ef: jp      $25bb] jump back and continue

* called from main routine at #19AA

l_25f2:
	move.b	#0x02,d0                        	| [$25f2: ld      a,$02] load A with 2 = 0010 binary
	jbsr	only_continues_if_given_level_0030                            	| [$25f4: rst     $30] return if not conveyors

	jbsr	l_2602                            	| [$25f5: call    $2602] handle top conveyor and pulleys
	jbsr	l_262f                            	| [$25f8: call    $262f] handle middle conveyor and pulleys
	jbsr	l_2679                            	| [$25fb: call    $2679] handle lower conveyor and pulleys
	jbsr	l_2ad3                            	| [$25fe: call    $2ad3] handle mario's different speeds when on a conveyor
	rts                                    	| [$2601: ret] return

* called from #16D5, #25F5

l_2602:
	move.b	framecounter_601a,d0            	| [$2602: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	ror.b	#1,d0                            	| [$2605: rrca] is the counter odd?
	jcs	l_2616                             	| [$2606: jp      c,$2616] yes, skip ahead

	lea	top_conveyor_counter_62a0,a0   	| [$2609: ld      hl,top_conveyor_counter_62a0] load HL with top conveyor counter
	subq.b	#1,(a0)                         	| [$260c: dec     (hl)] decrease.  time to reverse?
	jne	l_2616                             	| [$260d: jp      nz,$2616] no, skip next 3 steps

	move.b	#0x80,(a0)+                      	| [$2610: ld      (hl),$80] reset counter
	                           	| [$2612: inc     l] HL := #62A1 = master direction vector for top tray
	jbsr	l_26de                            	| [$2613: call    $26de] reverse the direction of this tray

l_2616:
	lea	master_direction_vector_for_top_conveyor_62a1,a0	| [$2616: ld      hl,master_direction_vector_for_top_conveyor_62a1] load HL with master direction vector for top conveyor
	jbsr	l_26e9                            	| [$2619: call    $26e9] load A with direction vector for this frame
	move.b	d0,top_conveyor_direction_vector_63a3	| [$261c: ld      (top_conveyor_direction_vector_63a3),a] store A into direction vector for top conveyor
	move.b	framecounter_601a,d0            	| [$261f: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	and.b	#0x1f,d0                         	| [$2622: and     $1f] mask bits
	cmp.b	#0x01,d0                         	| [$2624: cp      $01] == 1 ?
	beq.b	0f                               	| [...]
	rts                                    	| [$2626: ret     nz] no, return [...]
0:

	lea	start_of_pulley_sprites_69e4,a1	| [$2627: ld      de,start_of_pulley_sprites_69e4] else load DE with start of pulley sprites
	exg	a1,a0                              	| [$262a: ex      de,hl] DE <> HL
	jbsr	l_26a6                            	| [$262b: call    $26a6] animate the pulleys
	rts                                    	| [$262e: ret] return

* called from #25F8 above

l_262f:
	lea	master_direction_vector_for_upper_left_62a3,a0	| [$262f: ld      hl,master_direction_vector_for_upper_left_62a3] load HL with address of master direction vector for middle conveyor
	move.b	mario_y_position_6205,d0	| [$2632: ld      a,(mario_y_position_6205)] load A with mario's Y position
	cmp.b	#0xc0,d0                         	| [$2635: cp      $c0] is mario slightly above the lower conveyor?
	jcs	l_266f                             	| [$2637: jp      c,$266f] yes, skip ahead.  in this case the upper trays don't vary

	move.b	framecounter_601a,d0            	| [$263a: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	ror.b	#1,d0                            	| [$263d: rrca] roll right, is there a carry bit?
	jcs	l_264c                             	| [$263e: jp      c,$264c] yes, skip ahead

	                           	| [$2641: dec     l] load HL with middle conveyor counter
	subq.b	#1,-(a0)                         	| [$2642: dec     (hl)] decrease it.  at zero?
	jne	l_264c                             	| [$2643: jp      nz,$264c] no, skip ahead

	move.b	#0xc0,(a0)+                      	| [$2646: ld      (hl),$c0] yes, reset the counter to #C0
	                           	| [$2648: inc     l] HL := #62A3 = master direction vector for middle conveyor
	jbsr	l_26de                            	| [$2649: call    $26de] reverse the direction of this tray

l_264c:
	lea	master_direction_vector_for_upper_left_62a3,a0	| [$264c: ld      hl,master_direction_vector_for_upper_left_62a3] load HL with master direction vector for upper left
	jbsr	l_26e9                            	| [$264f: call    $26e9] load A with direction vector for this frame
	move.b	d0,upper_right_pie_tray_vector_63a5	| [$2652: ld      (upper_right_pie_tray_vector_63a5),a] store into pie tray vector (upper right)
	neg.b	d0                               	| [$2655: neg] negate.  upper two pie trays move opposite directions
	move.b	d0,upper_left_pie_tray_vector_63a4	| [$2657: ld      (upper_left_pie_tray_vector_63a4),a] store into pie tray vector (upper left)
	move.b	framecounter_601a,d0            	| [$265a: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	and.b	#0x1f,d0                         	| [$265d: and     $1f] mask bits, now between 0 and #1F.  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$265f: ret     nz] no, return [...]
0:

	subq.w	#1,a0                           	| [$2660: dec     l] HL := #62A2 = middle conveyor counter
	lea	middle_pulley_sprites_69ec,a1  	| [$2661: ld      de,middle_pulley_sprites_69ec] load DE with middle pulley sprites
	exg	a1,a0                              	| [$2664: ex      de,hl] DE <> HL
	jbsr	l_26a6                            	| [$2665: call    $26a6] animate the pulleys
	and.b	#0x7f,d0                         	| [$2668: and     $7f] mask bits, A now betwen #7F and 0 (turns off bit 7)
	lea	unknown_69ed,a0                	| [$266a: ld      hl,unknown_69ed] load HL with ???
	move.b	d0,(a0)                         	| [$266d: ld      (hl),a] store A
	rts                                    	| [$266e: ret] return

l_266f:
	btst.b	#7,(a0)                         	| [$266f: bit     7,(hl)] is this tray moving left ?
	jne	l_264c                             	| [$2671: jp      nz,$264c] yes, don't change anything

	move.b	#0xff,(a0)                      	| [$2674: ld      (hl),$ff] else change tray so it is moving left
	jra	l_264c                             	| [$2676: jp      $264c] loop back to continue

* called from #25FB

l_2679:
	move.b	framecounter_601a,d0            	| [$2679: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	ror.b	#1,d0                            	| [$267c: rrca] rotate right.  is there a carry?
	jcs	l_268d                             	| [$267d: jp      c,$268d] yes, skip ahead

	lea	this_counter_62a5,a0           	| [$2680: ld      hl,this_counter_62a5] no, load HL with this counter
	subq.b	#1,(a0)                         	| [$2683: dec     (hl)] count it down.  zero?
	jne	l_268d                             	| [$2684: jp      nz,$268d] no, skip ahead

	move.b	#0xff,(a0)+                      	| [$2687: ld      (hl),$ff] yes, reset counter to #FF
	                           	| [$2689: inc     l] HL := #62A6 = master direction vector for lower level
	jbsr	l_26de                            	| [$268a: call    $26de] reverse direction of this tray

l_268d:
	lea	master_direction_vector_for_lower_level_62a6,a0	| [$268d: ld      hl,master_direction_vector_for_lower_level_62a6] load HL with master direction vector for lower level
	jbsr	l_26e9                            	| [$2690: call    $26e9] load A with direction vector for this frame
	move.b	d0,pie_direction_lower_level_63a6	| [$2693: ld      (pie_direction_lower_level_63a6),a] store A into pie direction for lower level
	move.b	framecounter_601a,d0            	| [$2696: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	and.b	#0x1f,d0                         	| [$2699: and     $1f] mask bits.  now between 0 and #1F
	cmp.b	#0x02,d0                         	| [$269b: cp      $02] == 2 ? (1/32 chance?)
	beq.b	0f                               	| [...]
	rts                                    	| [$269d: ret     nz] no, return [...]
0:

	lea	pulley_sprite_start_69f4,a1    	| [$269e: ld      de,pulley_sprite_start_69f4] load DE with pulley sprite start
	exg	a1,a0                              	| [$26a1: ex      de,hl] DE <> HL
	jbsr	l_26a6                            	| [$26a2: call    $26a6] call sub below to animate the pulleys [why?  it should just continue here]
	rts                                    	| [$26a5: ret] return

* called from #26A2, above with HL preloaded with pulley sprite address and DE preloaded with conveyor direction
* animates the pulleys

l_26a6:
	addq.w	#1,a0                           	| [$26a6: inc     l] load HL with pulley sprite value
	move.b	(a1),d0                         	| [$26a7: ld      a,(de)] load A with master conveyor direction
	CLEAR_XC_FLAGS
	roxl.b	#1,d0                           	| [$26a8: rla] rotate left.  carry set?
	jcs	l_26c5                             	| [$26a9: jp      c,$26c5] yes, skip ahead to handle that direction

	move.b	(a0),d0                         	| [$26ac: ld      a,(hl)] load A with current sprite
	addq.b	#1,d0                           	| [$26ad: inc     a] increase it to animate
	cmp.b	#0x53,d0                         	| [$26ae: cp      $53] == #53 ? at end of sprite range?
	jne	l_26b5                             	| [$26b0: jp      nz,$26b5] no, skip next step

	move.b	#0x50,d0                        	| [$26b3: ld      a,$50] A := #50 = reset sprite to first

l_26b5:
	move.b	d0,(a0)                         	| [$26b5: ld      (hl),a] store result sprite
	                           	| [$26b6: ld      a,l] A := L = #E5
	addq.w	#0x04,a0                        	| [$26b7: add     a,$04] add 4 = #E9 for next sprite
	                           	| [$26b9: ld      l,a] HL now has next sprite
	move.b	(a0),d0                         	| [$26ba: ld      a,(hl)] load A with sprite value
	subq.b	#1,d0                           	| [$26bb: dec     a] decrease to animate
	cmp.b	#0xcf,d0                         	| [$26bc: cp      $cf] == #CF ? end of sprites?
	jne	l_26c3                             	| [$26be: jp      nz,$26c3] no, skip next step

	move.b	#0xd2,d0                        	| [$26c1: ld      a,$d2] A := #D2 = reset sprite to first

l_26c3:
	move.b	d0,(a0)                         	| [$26c3: ld      (hl),a] store into sprite
	rts                                    	| [$26c4: ret] return

* from #26A9 when conveyor direction is other way

l_26c5:
	move.b	(a0),d0                         	| [$26c5: ld      a,(hl)] load A with sprite value
	subq.b	#1,d0                           	| [$26c6: dec     a] decrease to animate
	cmp.b	#0x4f,d0                         	| [$26c7: cp      $4f] == #4F ? end of sprites?
	jne	l_26ce                             	| [$26c9: jp      nz,$26ce] no, skip next step

	move.b	#0x52,d0                        	| [$26cc: ld      a,$52] A := #52 = first sprite

l_26ce:
	move.b	d0,(a0)                         	| [$26ce: ld      (hl),a] store into sprite
	                           	| [$26cf: ld      a,l] A := L
	addq.w	#0x04,a0                        	| [$26d0: add     a,$04] add 4
	                           	| [$26d2: ld      l,a] L := A.  HL now has next sprite in set
	move.b	(a0),d0                         	| [$26d3: ld      a,(hl)] load A with sprite value
	addq.b	#1,d0                           	| [$26d4: inc     a] increase to animate
	cmp.b	#0xd3,d0                         	| [$26d5: cp      $d3] == #D3? end of sprites?
	jne	l_26dc                             	| [$26d7: jp      nz,$26dc] no, skip next step

	move.b	#0xd0,d0                        	| [$26da: ld      a,$d0] yes, A := #D0 = reset sprite to first

l_26dc:
	move.b	d0,(a0)                         	| [$26dc: ld      (hl),a] store sprite
	rts                                    	| [$26dd: ret] return

* called from #268A with HL == #62A6 = master direction vector for lower level

l_26de:
	btst.b	#7,(a0)                         	| [$26de: bit     7,(hl)] is this direction moving right ?
	jeq	l_26e6                             	| [$26e0: jp      z,$26e6] yes, skip next 2 steps

	move.b	#0x02,(a0)                      	| [$26e3: ld      (hl),$02] store 2 into (HL) - reverses the pie tray direction (now moving right)
	rts                                    	| [$26e5: ret] return

l_26e6:
	move.b	#0xfe,(a0)                      	| [$26e6: ld      (hl),$fe] store #FE into (HL) - reverses the pie tray direction (now moving left)
	rts                                    	| [$26e8: ret] return

* called when deciding which way to switch the pie tray direction vectors
* HL is preloaded with the master direction vector for the tray

l_26e9:
	move.b	framecounter_601a,d0            	| [$26e9: ld      a,(framecounter_601a)] load with clock counts down from #FF to 00 over and over...
	and.b	#0x01,d0                         	| [$26ec: and     $01] mask bits.  now either 0 or 1.  zero?
	bne.b	0f                               	| [...]
	rts                                    	| [$26ee: ret     z] yes, return.  every other frame the pie tray is stationary [...]
0:

	btst.b	#7,(a0)                         	| [$26ef: bit     7,(hl)] check bit 7 of (HL) - this is the master direction for this tray
	st.b	d0                                	| [$26f1: ld      a,$ff] load A with vector for tray moving to left
	jne	l_26f8                             	| [$26f3: jp      nz,$26f8] not zero, skip next step

	move.b	#0x01,d0                        	| [$26f6: ld      a,$01] load A with vector for tray moving to right
l_26f8:
	move.b	d0,(a0)                         	| [$26f8: ld      (hl),a] store result
	rts                                    	| [$26f9: ret] return

* arrive here from main routine at #19A7

handle_elevators_26fa:
	move.b	#0x04,d0                        	| [$26fa: ld      a,$04] A := 4 = 0100 binary
	jbsr	only_continues_if_given_level_0030                            	| [$26fc: rst     $30] only continue here if elevators, else RET

* elevators only

	move.b	mario_y_position_6205,d0	| [$26fd: ld      a,(mario_y_position_6205)] load A with mario's Y position
	cmp.b	#0xf0,d0                         	| [$2700: cp      $f0] is mario too low ?
	jcc	l_277f                             	| [$2702: jp      nc,$277f] yes, then mario dead

	move.b	framecounter_601a,d0            	| [$2709: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	move.b	level_number_6229,d7       	| [$2705: ld      a,(level_number_6229)] else load A with level number
	subq.b	#1,d7                           	| [$2708: dec     a] decrement and check for zero
	jne	l_271a                             	| [$270c: jp      nz,$271a] if level <> 1 then jump ahead

* slow elevators for level 1, japanese rom only?

	and.b	#0x03,d0                         	| [$270f: and     $03] mask bits of timer, now between 0 and 3
	cmp.b	#0x01,d0                         	| [$2711: cp      $01] == 1 ?
	jeq	l_271e                             	| [$2713: jp      z,$271e] yes, skip ahead and return

	jcs	l_2722                             	| [$2716: jp      c,$2722] if greater, then jump ahead and move elevators ?

	rts                                    	| [$2719: ret] else return

l_271a:
	ror.b	#1,d0                            	| [$271a: rrca] rotate right the timer
	jcs	l_2722                             	| [$271b: jp      c,$2722] if carry jump ahead and move the elevators (50% of time)

l_271e:
	jbra	handle_mario_on_elevator_2745                            	| [$271e: call    $2745] handle if mario is riding elevators
	                                    	| [$2721: ret] return

l_2722:
	jbsr	l_2797                            	| [$2722: call    $2797] move elevators
	jbsr	check_elevators_27da                            	| [$2725: call    $27da] check for and set elevators that have reset
	move.b	#0x06,d1                        	| [$2728: ld      b,$06] For B = 1 to 6
	move.w	#0x0010,d3                      	| [$272a: ld      de,$0010] load offset 16
	lea	elevator_sprites_6958,a0       	| [$272d: ld      hl,elevator_sprites_6958] load starting value for elevator sprites
	lea	elevator_array_start_6600,a2   	| [$2730: ld      ix,elevator_array_start_6600] memory where elevator values are stored

* update elevator sprites

l_2734:
	move.b	(0x03,a2),d0                    	| [$2734: ld      a,(ix+$03)] load X position value for elevator
	move.b	d0,(a0)                         	| [$2737: ld      (hl),a] store into sprite value X position
	addq.w	#3,a0                           	| [$2738: inc     l] * 3
	move.b	(0x05,a2),d0                    	| [$273b: ld      a,(ix+$05)] load A with elevator Y position
	move.b	d0,(a0)+                         	| [$273e: ld      (hl),a] store into sprite Y position
	                           	| [$273f: inc     l] next position
	add.w	d3,a2                            	| [$2740: add     ix,de] next elevator
	subq.b	#1,d1                           	| [...]
	jne	l_2734                             	| [$2742: djnz    $2734] Next B

	rts                                    	| [$2744: ret] return

* called from #271E

handle_mario_on_elevator_2745:
	move.b	elevator_status_6398,d0         	| [$2745: ld      a,(elevator_status_6398)] load A with elevator riding indicator
	                               	| [$2748: and     a] is mario riding an elevator?
	bne.b	0f                               	| [...]
	rts                                    	| [$2749: ret     z] no, return [...]
0:

	move.b	jumping_status_6216,d0          	| [$274a: ld      a,(jumping_status_6216)] load A with jumping status
	                               	| [$274d: and     a] is mario jumping ?
	beq.b	0f                               	| [...]
	rts                                    	| [$274e: ret     nz] yes, return [...]
0:

* arrive here when mario riding on either elevator

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$274f: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position. eg 37 for first, 75 for second
	cmp.b	#0x2c,d0                         	| [$2752: cp      $2c] position < left edge of first elevator ?
	jcs	l_2766                             	| [$2754: jp      c,$2766] yes, jump ahead

	cmp.b	#0x43,d0                         	| [$2757: cp      $43] else is position < right edge of first elevator ?
	jcs	l_276f                             	| [$2759: jp      c,$276f] yes, jump ahead for first elevator checks

	cmp.b	#0x6c,d0                         	| [$275c: cp      $6c] else is position < left edge of second elevator?
	jcs	l_2766                             	| [$275e: jp      c,$2766] yes, jump ahead

	cmp.b	#0x83,d0                         	| [$2761: cp      $83] else is position < right edge of second elevator ?
	jcs	l_2787                             	| [$2763: jp      c,$2787] yes, jump ahead for second elevator checks

* arrive here when mario jumps off of an elevator ?

l_2766:
	clr.b	d0                               	| [$2766: xor     a] A := 0
	move.b	d0,elevator_status_6398         	| [$2767: ld      (elevator_status_6398),a] clear elevator riding indicator
	addq.b	#1,d0                           	| [$276a: inc     a] A := 1
	move.b	d0,mario_falling_indicator_6221 	| [$276b: ld      (mario_falling_indicator_6221),a] store into mario falling indicator ?
	rts                                    	| [$276e: ret] return

* arrive here when mario riding on first elevator

l_276f:
	move.b	mario_y_position_6205,d0	| [$276f: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	cmp.b	#0x71,d0                         	| [$2772: cp      $71] top of elevator ? (death)
	jcs	l_277f                             	| [$2774: jp      c,$277f] yes, die

	subq.b	#1,d0                           	| [$2777: dec     a] else decrement (move mario up)
	move.b	d0,mario_y_position_6205	| [$2778: ld      (mario_y_position_6205),a] store into Mario's Y position
	move.b	d0,mario_sprite_y_value_694f    	| [$277b: ld      (mario_sprite_y_value_694f),a] store into mario sprite Y value
	rts                                    	| [$277e: ret] return

l_277f:
	tst.b	invincible_flag
	bne.b	1f
	                               	| [$277f: xor     a] A := 0
	clr.b	mario_array_6200             	| [$2780: ld      (mario_array_6200),a] Make mario dead
	clr.b	elevator_status_6398         	| [$2783: ld      (elevator_status_6398),a] clear elevator riding indicator
1:
	rts                                    	| [$2786: ret] return

* riding on second elevator

l_2787:
	move.b	mario_y_position_6205,d0	| [$2787: ld      a,(mario_y_position_6205)] load A with mario's Y position
	cmp.b	#0xe8,d0                         	| [$278a: cp      $e8] at bottom of elevator ? (death)
	jcc	l_277f                             	| [$278c: jp      nc,$277f] yes, set death and return

	addq.b	#1,d0                           	| [$278f: inc     a] else increment (move mario down)
	move.b	d0,mario_y_position_6205	| [$2790: ld      (mario_y_position_6205),a] store back into mario's Y position
	move.b	d0,mario_sprite_y_value_694f    	| [$2793: ld      (mario_sprite_y_value_694f),a] store into mario sprite Y value
	rts                                    	| [$2796: ret] return

* called from #2722
* moves elevators ???

l_2797:
	move.b	#0x06,d1                        	| [$2797: ld      b,$06] for B = 1 to 6 (for each elevator)
	move.w	#0x0010,d3                      	| [$2799: ld      de,$0010] load DE with offset 16
	lea	elevator_array_start_6600,a2   	| [$279c: ld      ix,elevator_array_start_6600] load IX with start of sprite addr. for elevators

l_27a0:
	btst.b	#0,(a2)                    	| [$27a0: bit     0,(ix+$00)] is this elevator active?
	jeq	l_27c2                             	| [$27a4: jp      z,$27c2] no, skip ahead and loop for next

	btst.b	#3,(0x0d,a2)                    	| [$27a7: bit     3,(ix+$0d)] is this elevator moving down ?
	jeq	l_27c7                             	| [$27ab: jp      z,$27c7] yes, skip ahead

* elevator is moving up

	move.b	(0x05,a2),d0                    	| [$27ae: ld      a,(ix+$05)] load A with elevator Y position
	subq.b	#1,d0                           	| [$27b1: dec     a] decrement (move up)
	move.b	d0,(0x05,a2)                    	| [$27b2: ld      (ix+$05),a] store result
	cmp.b	#0x60,d0                         	| [$27b5: cp      $60] at top of elevator ?
	jne	l_27c2                             	| [$27b7: jp      nz,$27c2] no, skip next 2 steps

	move.b	#0x77,(0x03,a2)                 	| [$27ba: ld      (ix+$03),$77] set X position to right side of elevators
	move.b	#0x04,(0x0d,a2)                 	| [$27be: ld      (ix+$0d),$04] set direction to down

l_27c2:
	add.w	d3,a2                            	| [$27c2: add     ix,de] add offset for next elevator
	subq.b	#1,d1                           	| [...]
	jne	l_27a0                             	| [$27c4: djnz    $27a0] next B
	rts                                    	| [$27c6: ret] return

* elevator is moving down

l_27c7:
	move.b	(0x05,a2),d0                    	| [$27c7: ld      a,(ix+$05)] load A with elevator Y position
	addq.b	#1,d0                           	| [$27ca: inc     a] increase (move down)
	move.b	d0,(0x05,a2)                    	| [$27cb: ld      (ix+$05),a] store result
	cmp.b	#0xf8,d0                         	| [$27ce: cp      $f8] at bottom of shaft ?
	jne	l_27c2                             	| [$27d0: jp      nz,$27c2] no, loop for next

	clr.b	(a2)                        	| [$27d3: ld      (ix+$00),$00] yes, make this elevator inactive
	jra	l_27c2                             	| [$27d7: jp      $27c2] jump back and loop for next elevator

* called from #2725

* [IF elevator_counter <> 0 THEN ( elevator_counter--  | RETURN ) ELSE (

check_elevators_27da:
	lea	elevator_counter_address_62a7,a0	| [$27da: ld      hl,elevator_counter_address_62a7] load HL with elevator counter address
	move.b	(a0),d0                         	| [$27dd: ld      a,(hl)] load A with elevator counter
	                               	| [$27de: and     a] == 0 ?
	jne	l_2806                             	| [$27df: jp      nz,$2806] no, skip ahead, decrease counter and return

	move.b	#0x06,d1                        	| [$27e2: ld      b,$06] for B = 1 to 6 elevators
	lea	elevator_array_start_6600,a2   	| [$27e4: ld      ix,elevator_array_start_6600] load IX with sprite addr. for elevators

l_27e8:
	btst.b	#0,(a2)                    	| [$27e8: bit     0,(ix+$00)] is this elevator active ?
	jeq	l_27f4                             	| [$27ec: jp      z,$27f4] no, skip ahead and reset

	add.w	d3,a2                            	| [$27ef: add     ix,de] add offset for next elevator
 
	subq.b	#1,d1                           	| [...]
	jne	l_27e8                             	| [$27f1: djnz    $27e8] next B
	rts                                    	| [$27f3: ret] return

l_27f4:
	move.b	#0x01,(a2)                 	| [$27f4: ld      (ix+$00),$01] make elevator active
	move.b	#0x37,(0x03,a2)                 	| [$27f8: ld      (ix+$03),$37] set X position to left side shaft
	move.b	#0xf8,(0x05,a2)                 	| [$27fc: ld      (ix+$05),$f8] set Y position to bottom of shaft
	move.b	#0x08,(0x0d,a2)                 	| [$2800: ld      (ix+$0d),$08] set direction to up
	move.b	#0x34,(a0)                      	| [$2804: ld      (hl),$34] reset elevator counter to #34

l_2806:
	subq.b	#1,(a0)                         	| [$2806: dec     (hl)] decrease elevator counter
	rts                                    	| [$2807: ret] return

* called from main routine at #19B3
* checks for collisions with hostiles sprites

l_2808:
	lea	mario_array_6200,a3            	| [$2808: ld      iy,mario_array_6200] load IY with start of mario sprite
	move.b	mario_y_position_6205,d0	| [$280c: ld      a,(mario_y_position_6205)] load A with mario's Y position
	move.b	d0,d2                           	| [$280f: ld      c,a] copy to C
	move.b	#0x04,d5
	move.b	#0x07,d6                      	| [$2810: ld      hl,$0407] H := 4, L := 7
	jbsr	check_collisions_for_enemies_286f                            	| [$2813: call    $286f] checks for collisions based on the screen.  A := 1 if collision, otherwise zero
	tst.b	invincible_flag
	bne.b	1f
	tst.b	d0                               	| [$2816: and     a] was there a collision ?
	bne.b	0f                               	| [...]
1:
	rts                                    	| [$2817: ret     z] no, return [...]
0:

* mario collided with hostile sprite

	subq.b	#1,d0                           	| [$2818: dec     a] else A := 0
	move.b	d0,mario_array_6200             	| [$2819: ld      (mario_array_6200),a] store into mario life indicator, mario is dead
	rts                                    	| [$281c: ret] return

* called from main routine at #19B6

handle_hammer_281d:
	move.b	#0x02,d1                        	| [$281d: ld      b,$02] for B = 1 to 2 hammers
	move.w	#0x0010,d3                      	| [$281f: ld      de,$0010] load DE with counter offset 16
	lea	software_address_of_hammer_sprite_6680,a3	| [$2822: ld      iy,software_address_of_hammer_sprite_6680] load IY with sprite address start ?

l_2826:
	btst.b	#0,(0x01,a3)                    	| [$2826: bit     0,(iy+$01)] is the hammer being used ?
	jne	l_2832                             	| [$282a: jp      nz,$2832] yes, then do stuff ahead

	add.w	d3,a3                            	| [$282d: add     iy,de] else look at next one
	subq.b	#1,d1                           	| [...]
	jne	l_2826                             	| [$282f: djnz    $2826] next B

	rts                                    	| [$2831: ret] return

* hammer is active, do stuff for it
* D1: 1 or 2 depending on the hammer being used
l_2832:
	move.b	(0x05,a3),d2                    	| [$2832: ld      c,(iy+$05)] C := +5 (X position???)
	move.b	(0x09,a3),d5                    	| [$2835: ld      h,(iy+$09)] H := +9 (size?  width?)
	move.b	(0x0a,a3),d6                    	| [$2838: ld      l,(iy+$0a)] L := +A (size?  height?)
	jbsr	check_collisions_for_enemies_286f                            	| [$283b: call    $286f] checks for collisions based on the screen.  A := 1 if collision, otherwise zero
	tst.b	d0                               	| [$283e: and     a] was there a collision?
	bne.b	0f                               	| [...]
	rts                                    	| [$283f: ret     z] no, return [...]
0:

* hammer hit something
* A2 is loaded with the array of the item which was hit

	move.b	d0,item_hit_indicator_unknown_6350	| [$2840: ld      (item_hit_indicator_unknown_6350),a] store A into item hit indicator ???
	move.b	nb_items_checked_for_collision_63b9,d0   	| [$2843: ld      a,(nb_items_checked_for_collision_63b9)] load A with the number of total items checked for collision?
	sub.b	d1,d0                            	| [$2846: sub     b] subtract the index where element was found (in reverse)
	move.b	d0,index_of_item_hit_6354                 	| [$2847: ld      (index_of_item_hit_6354),a]
	* d3 has the offset see 281f						| [$284a: ld      a,e] load A with offset for each item
	move.b	d3,offset_for_item_in_array_6353                 	| [$284b: ld      (offset_for_item_in_array_6353),a] store into ???
	* here IX is 64xx (fireballs) or 67xx (barrels)
	STORE_RAM_ADDRESS_LE	a2,item_array_for_item_hit_6351                 	| [$284e: ld      (item_array_for_item_hit_6351),ix] store IX into ???
	rts                                    	| [$2852: ret] return

* called when mario jumping, checks for items being jumped over
* arrive at apex of jump
* called from #1C20

l_2853:
	lea	mario_array_6200,a3            	| [$2853: ld      iy,mario_array_6200] load IY with start of mario array
	move.b	mario_y_position_6205,d0	| [$2857: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	add.b	#0x0c,d0                         	| [$285a: add     a,$0c] add #0C (12 decimal)
	move.b	d0,d2                           	| [$285c: ld      c,a] copy to C
	move.b	inputstate_6010,d0              	| [$285d: ld      a,(inputstate_6010)] load A with copy of input (see RawInput). except when jump pressed, bit 7 is set momentarily.
	and.b	#0x03,d0                         	| [$2860: and     $03] mask bits, now between 0 and 3
	move.b	#0x05,d5
	move.b	#0x08,d6                      	| [$2862: ld      hl,$0508] H := #05, L := #08.  [H is the left-right window for jumping items, L is the up-down window?]
	jeq	l_286b                             	| [$2865: jp      z,$286b] if masked input was zero, skip next step

* player moving joystick left or right while jumping

	move.b	#0x13,d5
	move.b	#0x08,d6                      	| [$2868: ld      hl,$1308] H := #13 (19 decimal) , L := #08. [ why is L set again ???]  [H is the left-right window, increased if joystick moved left or right]

l_286b:
	jra	l_3e88                            	| [$286b: call    $3e88] check for items being jumped based on which screen this is [seems like a patch ?  what was original code? CALL #286F ?]
	                                    	| [$286e: ret] return


        * 3E88  3A2762    LD      A,(#6227)     | load A with screen number
        * 3E8B  E5        PUSH    HL            | save HL
        * 3E8C  EF        RST     #28           | jump to new location based on screen number

        * data for above:

        * 3E8D  00 00
        * 3E8F  99 3E                           | #3E99 - girders
        * 3E91  B0 28                           | #28B0 - pie
        * 3E93  E0 28                           | #28E0 - elevator
        * 3E95  01 29                           | #2901 - rivets



* called when hammer active from #283B - check for hammer collision with enemy sprites
* > D1: nb_objects - object index?

check_collisions_for_enemies_286f:
	move.b	screen_number_6227,d0           	| [$286f: ld      a,(screen_number_6227)] load A with screen number

	movem.w	d5/d6,-(sp)                        	| [$2872: push    hl] save HL

	jbsr	rst_28                            	| [$2873: rst     $28] jump to address below depending on screen:

	.long	0| unused
	.long	check_collisions_in_girders_2880    | #2880 - girders
	.long	check_collisions_in_conveyors_28b0  | #28B0 - conveyors
	.long	check_collisions_in_elevators_28e0  | #28E0 - elevators
	.long	check_collisions_in_rivets_2901     | #2901 - rivets


* girders - check for collisions with barrels and fires and oil can

check_collisions_in_girders_2880:
	movem.w	(sp)+,d5/d6                        	| [$2880: pop     hl] restore HL: get X,Y coords
	move.b	#NB_BARRELS,d1                        	| [$2881: ld      b,$0a] B := #0A (10 decimal).  one for each barrel
	move.b	d1,d0                           	| [$2883: ld      a,b] A := #0A
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$2884: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.w	#0x0020,d3                      	| [$2887: ld      de,$0020] load DE with offset of #20 32
	lea	start_of_barrel_info_table_6700,a2	| [$288a: ld      ix,start_of_barrel_info_table_6700] load IX with start of barrels
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$288e: call    $2913] check for collisions with barrels

	move.b	#NB_FIRES,d1                        	| [$2891: ld      b,$05] B := 5
	move.b	d1,d0                           	| [$2893: ld      a,b] A := 5
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$2894: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.b	#0x20,d3                        	| [$2897: ld      e,$20] E := #20
	lea	start_of_fires_table_6400,a2   	| [$2899: ld      ix,start_of_fires_table_6400] load IX with start of fires
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$289d: call    $2913] check for collisions with fires
	move.b	#0x01,d1                        	| [$28a0: ld      b,$01] B := 1
	move.b	d1,d0                           	| [$28a2: ld      a,b] A := 1
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28a3: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	clr.b	d3                              	| [$28a6: ld      e,$00] E := #00
	lea	oil_can_address_66a0,a2        	| [$28a8: ld      ix,oil_can_address_66a0] load IX with oil can fire location
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28ac: call    $2913] check for collision with oil can fire
	rts                                    	| [$28af: ret] return

* jump here from #3E8C when jumping/hammering ? on the pie factory

check_collisions_in_conveyors_28b0:
	movem.w	(sp)+,d5/d6                        	| [$28b0: pop     hl] restore HL
	move.b	#NB_FIRES,d1                        	| [$28b1: ld      b,$05] B := 5 fires
	move.b	d1,d0                           	| [$28b3: ld      a,b] A := 5 fires
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28b4: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.w	#0x0020,d3                      	| [$28b7: ld      de,$0020] load DE with offset 32
	lea	start_of_fires_table_6400,a2   	| [$28ba: ld      ix,start_of_fires_table_6400] load IX with start of fires
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28be: call    $2913] check for collisions with fires
	move.b	#NB_PIES,d1                        	| [$28c1: ld      b,$06] B := 6
	move.b	d1,d0                           	| [$28c3: ld      a,b] A := 6
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28c4: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.b	#0x10,d3                        	| [$28c7: ld      e,$10] E := #10
	lea	start_of_pies_65a0,a2          	| [$28c9: ld      ix,start_of_pies_65a0] load IX with start of pies
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28cd: call    $2913] check for collisions with pies
	move.b	#0x01,d1                        	| [$28d0: ld      b,$01] B := 1
	move.b	d1,d0                           	| [$28d2: ld      a,b] A := 1
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28d3: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	clr.b	d3                               	| [$28d6: ld      e,$00] E := 0
	lea	oil_can_address_66a0,a2        	| [$28d8: ld      ix,oil_can_address_66a0] load IX with oil can address
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28dc: call    $2913] check for collision with oil can fire
	rts                                    	| [$28df: ret] return

* jump here from #2873 or #3E8C when on the elevators

check_collisions_in_elevators_28e0:
	movem.w	(sp)+,d5/d6                        	| [$28e0: pop     hl] restore HL
	move.b	#NB_FIRES,d1                        	| [$28e1: ld      b,$05] B := 5
	move.b	d1,d0                           	| [$28e3: ld      a,b] A := 5
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28e4: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.w	#0x0020,d3                      	| [$28e7: ld      de,$0020] load offset 32
	lea	start_of_fires_table_6400,a2   	| [$28ea: ld      ix,start_of_fires_table_6400] load start of addresses for fires
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28ee: call    $2913] check for collisions with fires
	move.b	#0x0a,d1                        	| [$28f1: ld      b,$0a] B := #0A 10 bouncers (same slots as barrels)
	move.b	d1,d0                           	| [$28f3: ld      a,b] A := #0A
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$28f4: ld      (nb_items_checked_for_collision_63b9),a] store counter for use later
	move.b	#0x10,d3                        	| [$28f7: ld      e,$10] E := #10
	lea	start_of_bouncer_memory_area_6500,a2	| [$28f9: ld      ix,start_of_bouncer_memory_area_6500] load IX with start of addresses for springs
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$28fd: call    $2913] check for collisions with springs
	rts                                    	| [$2900: ret] return

* jump here from #3E8C when on the rivets
* check for collisions with firefoxes and squares next to kong

check_collisions_in_rivets_2901:
	movem.w	(sp)+,d5/d6                        	| [$2901: pop     hl] restore HL
	move.b	#0x07,d1                        	| [$2902: ld      b,$07] B := 7
	move.b	d1,d0                           	| [$2904: ld      a,b] A := 7
	move.b	d0,nb_items_checked_for_collision_63b9   	| [$2905: ld      (nb_items_checked_for_collision_63b9),a] store 7 into counter for use later
	move.w	#0x0020,d3                      	| [$2908: ld      de,$0020] load DE with offset 32
	lea	start_of_fires_table_6400,a2   	| [$290b: ld      ix,start_of_fires_table_6400] load IX with start of firefox arrays
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$290f: call    $2913] check for collisions with firefoxes/squares
	rts                                    	| [$2912: ret] return

* core routine gets called a lot
* uses a2 and a3 and d3.w
* uses B for loop counter
* uses d2 for a memory location start
* d5/d6 are used
* seems to return a value in A as either 0 or 1
* check for sprite collision ???
* a2: array of enemies to check (sprite shadow table, ex 6400 or 6700, depends on levels)
* > D0: 1 collision, 0 no collision
* > D1: remaining items to check (to compute index of object that collides)

check_for_collision_with_enemy_type_2913:

	move.l	a2,-(sp)                        	| [$2913: push    ix] push IX to stack

* start of loop

l_2915:
	btst.b	#0,(a2)                    	| [$2915: bit     0,(ix+$00)] is this sprite active?
	jeq	l_294c                             	| [$2919: jp      z,$294c] no, add offset in DE and loop again

	move.b	d2,d0                           	| [$291c: ld      a,c] no, load A with C
	sub.b	(0x05,a2),d0                     	| [$291d: sub     (ix+$05)] subtract the Y value of item 2
	jcc	l_2925                             	| [$2920: jp      nc,$2925] if no carry, skip next step

	neg.b	d0                               	| [$2923: neg] A = 0 - A (negate with 2's complement)

l_2925:
	* intersection of object bounds
	addq.b	#1,d0                           	| [$2925: inc     a] A := A + 1
	sub.b	d6,d0                            	| [$2926: sub     l] subtract L [???]
	jcs	l_2930                             	| [$2927: jp      c,$2930] on carry, skip next 2 steps

	sub.b	(0x0a,a2),d0                     	| [$292a: sub     (ix+$0a)] subtract +#0A value height???
	jcc	l_294c                             	| [$292d: jp      nc,$294c] if no carry, add offset in DE and loop again

l_2930:
	move.b	(0x03,a3),d0                    	| [$2930: ld      a,(iy+$03)] load A with X position of item 1
	sub.b	(0x03,a2),d0                     	| [$2933: sub     (ix+$03)] subtract X position of item 2.  carry?
	jcc	l_293b                             	| [$2936: jp      nc,$293b] no, skip next step

	neg.b	d0                               	| [$2939: neg] A = 0 - A (negate with 2's complement)

l_293b:
	sub.b	d5,d0                            	| [$293b: sub     h] subtract H
	jcs	l_2945                             	| [$293c: jp      c,$2945] on carry, skip next 2 steps

	sub.b	(0x09,a2),d0                     	| [$293f: sub     (ix+$09)] subtract +#09 value width???
	jcc	l_294c                             	| [$2942: jp      nc,$294c] if no carry, add offset in DE and loop again

* else a collision

l_2945:
	move.b	#0x01,d0                        	| [$2945: ld      a,$01] A := 1 - code for collision
	move.l	(sp)+,a2                        	| [$2947: pop     ix] restore IX
	addq.w	#4,sp                           	| [$2949: inc     sp] * 2
	rts                                    	| [$294b: ret] skip other collision tests, return to higher subroutine

l_294c:
	add.w	d3,a2                            	| [$294c: add     ix,de] add offset for next sprite
	subq.b	#1,d1                           	| [...]
	jne	l_2915                             	| [$294e: djnz    $2915] Next B

	clr.b	d0                               	| [$2950: xor     a] A := 0 - code for no collision
	move.l	(sp)+,a2                        	| [$2951: pop     ix] restore IX
	rts                                    	| [$2953: ret] return

* arrive here when jumping at top of jump, check for hammer grab

l_2954:
	move.b	#0x0b,d0                        	| [$2954: ld      a,$0b] A := #0B = 1011 binary
	jbsr	only_continues_if_given_level_0030  | [$2956: rst     $30] if level is elevators RET from this sub now.  no hammers on elevators.
	jbsr	is_hammer_grabbed_2974              | [$2957: call    $2974] load A with 1 if hammer is grabbed, 0 if no grab
	move.b	d0,mario_is_grabbing_the_hammer_until_he_lands_6218	| [$295a: ld      (mario_is_grabbing_the_hammer_until_he_lands_6218),a] store into hammer grabbing indicator
	ror.b	#2,d0                            	| [$295d: rrca] * 2
	move.b	d0,play_sound_for_bonus_6085    	| [$295f: ld      (play_sound_for_bonus_6085),a] play sound for bonus
	tst.b	d0
	beq.b	0f
	* only play sound if hammer grabbed
	move.w	#JUMPED_OVER_SND,d0
	jbsr	osd_sound_start	
0:
	move.b	d1,d0                           	| [$2962: ld      a,b] A := B .  this indicates which hammer was grabbed if any
	                               	| [$2963: and     a] was a hammer grabbed?
	bne.b	0f                               	| [...]
	rts                                    	| [$2964: ret     z] no, return [...]
0:

	cmp.b	#0x01,d0                         	| [$2965: cp      $01] was lower hammer on girders & conveyors, or upper hammer on rivets, grabbed?
	jeq	l_296f                             	| [$2967: jp      z,$296f] yes, skip next 2 steps

	move.b	#0x01,(0x01,a2)                 	| [$296a: ld      (ix+$01),$01] set 1st hammer active
	rts                                    	| [$296e: ret] return

l_296f:
	move.b	#0x01,(0x11,a2)                 	| [$296f: ld      (ix+$11),$01] set 2nd hammer active
	rts                                    	| [$2973: ret] return

* called from #2957 above
* check for hammer grab ?

is_hammer_grabbed_2974:
	lea	mario_array_6200,a3            	| [$2974: ld      iy,mario_array_6200] load IY with start of mario sprite values
	move.b	mario_y_position_6205,d0	| [$2978: ld      a,(mario_y_position_6205)] load A with mario's Y position
	move.b	d0,d2                           	| [$297b: ld      c,a] copy to C
	move.b	#0x04,d5
	move.b	#0x08,d6                      	| [$297c: ld      hl,$0408] H := 4, L := 8
	move.b	#0x02,d1                        	| [$297f: ld      b,$02] B := 2 for the 2 hammers (?)
	move.w	#0x0010,d3                      	| [$2981: ld      de,$0010] offset for each hammer 16
	lea	software_address_of_hammer_sprite_6680,a2	| [$2984: ld      ix,software_address_of_hammer_sprite_6680] load IX with start of hammer sprites ?
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$2988: call    $2913] check for collision with hammer
	rts                                    	| [$298b: ret] return

* called from #323E
* fire moving.  check for girder edge near fire
* sets A := 0 if fire is free to move
* sets A := 1 if fire is next to edge of girder

l_298c:
	LOAD_RAM_ADDRESS_LE	address_of_fireball_slot_for_this_fireball_63c8,a0	| [$298c: ld      hl,(address_of_fireball_slot_for_this_fireball_63c8)] load HL with address of this fire
	                           	| [$298f: ld      a,l] A := L
	add.w	#0x0e,a0                         	| [$2990: add     a,$0e] add #E
	                           	| [$2992: ld      l,a] store result.  HL now has the fire's X position
	move.b	(a0)+,d3                         	| [$2993: ld      d,(hl)] load D with the fire's X position
	                           	| [$2994: inc     l] next HL = fire's Y position
	move.b	(a0),d0                         	| [$2995: ld      a,(hl)] load A with the fire's Y position
	add.b	#0x0c,d0                         	| [$2996: add     a,$0c] add #C to offset
	move.b	d0,d4                           	| [$2998: ld      e,a] store into E
	exg	d3,d5                              	| [$2999: ex      de,hl] DE <> HL
	exg	d4,d6                              	| [$2999: ex      de,hl] DE <> HL
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$299a: call    $2ff0] convert HL into VRAM memory location
	jbsr	osd_r_videoram                         	| [$299d: ld      a,(hl)] load A with the screen element at this location
	cmp.b	#0xb0,d0                         	| [$299e: cp      $b0] > #B0 ?
	jcs	l_29ac                             	| [$29a0: jp      c,$29ac] yes, skip next 5 steps, set A := 1 and return

	and.b	#0x0f,d0                         	| [$29a3: and     $0f] else mask bits, now between 0 and #F
	cmp.b	#0x08,d0                         	| [$29a5: cp      $08] <= 8 ?
	jcc	l_29ac                             	| [$29a7: jp      nc,$29ac] yes, skip next 2 steps, set A := 1 and return

	clr.b	d0                               	| [$29aa: xor     a] A := 0 = clear signal
	rts                                    	| [$29ab: ret] return

l_29ac:
	move.b	#0x01,d0                        	| [$29ac: ld      a,$01] A := 1 = fire near girder edge
	rts                                    	| [$29ae: ret] return

* called from #2B23 during a jump

handle_jump_stuff_for_elevators_29af:
	move.b	#0x04,d0                        	| [$29af: ld      a,$04] A := 4 = 0100
	jbsr	only_continues_if_given_level_0030                            	| [$29b1: rst     $30] only continue here if we are on the elevators, else RET

	lea	mario_array_6200,a3            	| [$29b2: ld      iy,mario_array_6200] load IY with mario's array
	move.b	mario_y_position_6205,d0	| [$29b6: ld      a,(mario_y_position_6205)] load A with mario's Y position
	move.b	d0,d2                           	| [$29b9: ld      c,a] copy to C
	move.b	#0x04,d5
	move.b	#0x08,d6                      	| [$29ba: ld      hl,$0408] H := 4, L := 8
	jbsr	l_2a22                            	| [$29bd: call    $2a22] check for collision with elevators
	tst.b	d0                               	| [$29c0: and     a] was there a collision?
	jeq	l_2a20                             	| [$29c1: jp      z,$2a20] no, load B with #00 and return

* arrive here when landing near an elevator
* B has the index of the elevator that we hit
	
	move.b	#0x06,d0                        	| [$29c4: ld      a,$06] A := 6
	sub.b	d1,d0                            	| [$29c6: sub     b] subtract B.  zero ?
l_29c7:
	jeq	l_29d0                             	| [$29c7: jp      z,$29d0] yes, skip ahead

	add.w	d3,a2                            	| [$29ca: add     ix,de] else add offset for next elevator (d3 loaded in l_2a22)
	subq.b	#1,d0                           	| [$29cc: dec     a] decrease counter
	jra	l_29c7                             	| [$29cd: jp      $29c7] loop again

* IX now has the array start for the elevator mario trying to land on

l_29d0:
	move.b	(0x05,a2),d0                    	| [$29d0: ld      a,(ix+$05)] load A with elevator's height Y position
	subq.b	#0x04,d0                        	| [$29d3: sub     $04] subtract 4
	move.b	d0,d3                           	| [$29d5: ld      d,a] copy to D
	move.b	mario_jump_height_620c,d0       	| [$29d6: ld      a,(mario_jump_height_620c)] load A with mario's jump height ?
	addq.b	#0x05,d0                        	| [$29d9: add     a,$05] add 5
	cmp.b	d3,d0                            	| [$29db: cp      d] compare.  is mario high enough to land ?
	jcc	l_29ee                             	| [$29dc: jp      nc,$29ee] no, skip ahead

	move.b	d3,d0                           	| [$29df: ld      a,d] load A with elevator's height - 4
	sub.b	#0x08,d0                         	| [$29e0: sub     $08] subtract 8
	move.b	d0,mario_y_position_6205	| [$29e2: ld      (mario_y_position_6205),a] store A into Mario's Y position
	move.b	#0x01,d0                        	| [$29e5: ld      a,$01] A := 1
	move.b	d0,d1                           	| [$29e7: ld      b,a] B := 1
	move.b	d0,elevator_status_6398         	| [$29e8: ld      (elevator_status_6398),a] set elevator riding indicator ?
	addq.w	#4,sp                           	| [$29eb: inc     sp] * 2
	rts                                    	| [$29ed: ret] returns to higher subroutine (#1C08)

l_29ee:
	move.b	mario_jump_height_620c,d0       	| [$29ee: ld      a,(mario_jump_height_620c)] load A with mario's jump height
	sub.b	#0x0e,d0                         	| [$29f1: sub     $0e] subtract #0E (14 decimal)
	cmp.b	d3,d0                            	| [$29f3: cp      d] compare to elevator height - 4. is mario hitting his head on the bottom of the elevator ?
	jcc	l_2a1b                             	| [$29f4: jp      nc,$2a1b] if so, mario is dead.  set dead and return.

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$29fb: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	tst.b	mario_jump_direction_6210    	| [$29f7: ld      a,(mario_jump_direction_6210)] load A with mario's jump direction.
	                               	| [$29fa: and     a] == 0 ?  Is mario jumping to the right ?
	jeq	l_2a08                             	| [$29fe: jp      z,$2a08] if jumping to the right then skip ahead

	or.b	#0x07,d0                          	| [$2a01: or      $07] else mask bits, turn on all 3 lower bits
	subq.b	#0x04,d0                        	| [$2a03: sub     $04] subtract 4
	jra	l_2a0e                             	| [$2a05: jp      $2a0e] skip next 3 steps

l_2a08:
	sub.b	#0x08,d0                         	| [$2a08: sub     $08] subtract 8
	or.b	#0x07,d0                          	| [$2a0a: or      $07] turn on all 3 lower bits
	addq.b	#0x04,d0                        	| [$2a0c: add     a,$04] add 4

* used when riding an elevator

l_2a0e:
	move.b	d0,jump_if_bit_7_of_mario_x_position_is_set_6203	| [$2a0e: ld      (jump_if_bit_7_of_mario_x_position_is_set_6203),a] set mario's X position
	move.b	d0,mario_sprite_x_position_694c 	| [$2a11: ld      (mario_sprite_x_position_694c),a] set mario's sprite X position
	move.b	#0x01,d0                        	| [$2a14: ld      a,$01] A := 1
	clr.b	d1                               	| [$2a16: ld      b,$00] B := 0
	addq.w	#4,sp                           	| [$2a18: inc     sp] * 2
	rts                                    	| [$2a1a: ret] return to higher level (#1C08)

* arrive from #29F4 when mario dies trying to jump onto elevator

l_2a1b:
	tst.b	invincible_flag
	bne.b	1f
	                              	| [$2a1b: xor     a] A := 0
	clr.b	mario_array_6200             	| [$2a1c: ld      (mario_array_6200),a] set mario dead
1:
	rts                                    	| [$2a1f: ret] return

* arrive from #29C1

l_2a20:
	move.b	d0,d1                           	| [$2a20: ld      b,a] B := 0
	rts                                    	| [$2a21: ret] return

* called from #29BD

l_2a22:
	move.b	#0x06,d1                        	| [$2a22: ld      b,$06] B := 6
	move.w	#0x0010,d3                      	| [$2a24: ld      de,$0010] load DE with offset 16
	lea	elevator_array_start_6600,a2   	| [$2a27: ld      ix,elevator_array_start_6600] load IX with elevator array start
	jbsr	check_for_collision_with_enemy_type_2913                            	| [$2a2b: call    $2913] check for collision with elevators
	rts                                    	| [$2a2e: ret] return

* sub called during a barrel roll from #2057
* only called when barrel going over edge to next girder or for crazy barrel ?
* returns with A loaded with 0 or 1 depending on ???

l_2a2f:
	move.b	(0x03,a2),d0                    	| [$2a2f: ld      a,(ix+$03)] load A with Barrel's X position
	move.b	d0,d5                           	| [$2a32: ld      h,a] Store into H
	move.b	(0x05,a2),d0                    	| [$2a33: ld      a,(ix+$05)] load A with Barrel's Y position
	addq.b	#0x04,d0                        	| [$2a36: add     a,$04] Add 4
	move.b	d0,d6                           	| [$2a38: ld      l,a] Store in L

	movem.w	d5/d6,-(sp)                        	| [$2a39: push    hl] Save HL to stack
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$2a3a: call    $2ff0] convert HL into VRAM memory address
	movem.w	(sp)+,d3/d4                    	| [$2a3d: pop     de] load DE with HL = barrel position X,Y
	jbsr	osd_r_videoram                     	| [$2a3e: ld      a,(hl)] load A with the graphic at this location


*B0 = Girder with hole in center used in rivets screen
*B6 = white line on top
*B7 = wierd icon?
*B8 = red line on bottom
*C0 -,0xC7 = girder with ladder on bottom going up
*D0 -,0xD7 = ladder graphic with girder under going up and out
*DD = HE  (help graphic)
*DE = EL
*DF = P!
*E1 -,0xE7 = grider graphic going up and out
*EC -,0xE8 = blank ?
*EF = P!
*EE = EL (part of help graphic)
*ED = HE (help graphic)
*F6 -,0xF0 = girder graphic in several vertical phases coming up from bottom
*F7 = bottom yellow line
*FA -,0xF8 = blank ?
*FB = ? (actually a question mark)
*FC = right red edge
*FD = left red edge
*FE = X graphic
*FF = Extra Mario Icon


	cmp.b	#0xb0,d0                         	| [$2a3f: cp      $b0] < #B0 ?
	jcs	l_2a7b                             	| [$2a41: jp      c,$2a7b] yes, skip ahead,  clear A to 0 and return - nothing to do.

	and.b	#0x0f,d0                         	| [$2a44: and     $0f] mask bits.  now between 0 and #F
	cmp.b	#0x08,d0                         	| [$2a46: cp      $08] < 8 ?
	jcc	l_2a7b                             	| [$2a48: jp      nc,$2a7b] no, skip ahead, clear A to 0 and return - nothing to do.

	jbsr	osd_r_videoram                         	| [$2a4b: ld      a,(hl)] load A with graphic at this location
	cmp.b	#0xc0,d0                         	| [$2a4c: cp      $c0] == girder with ladder on bottom going up ?
	jeq	l_2a7b                             	| [$2a4e: jp      z,$2a7b] yes, clear A to 0 and return - nothing to do.

	jcs	l_2a69                             	| [$2a51: jp      c,$2a69] < this value ?  if so, skip ahead

	cmp.b	#0xd0,d0                         	| [$2a54: cp      $d0] > ladder graphic with girder under going up and out ?
	jcs	l_2a6e                             	| [$2a56: jp      c,$2a6e] yes, skip ahead to handle

	cmp.b	#0xe0,d0                         	| [$2a59: cp      $e0] > grider graphic going up and out ?
	jcs	l_2a63                             	| [$2a5b: jp      c,$2a63] yes, skip next 2 steps

	cmp.b	#0xf0,d0                         	| [$2a5e: cp      $f0] > girder graphic in several vertical phases coming up from bottom ?
	jcs	l_2a6e                             	| [$2a60: jp      c,$2a6e] yes, skip ahaed to handle

* arrive when crazy barrel hitting top of girder ?

l_2a63:
	and.b	#0x0f,d0                         	| [$2a63: and     $0f] mask bits, now between 0 and #F
	subq.b	#1,d0                           	| [$2a65: dec     a] decrease
	jra	l_2a72                             	| [$2a66: jp      $2a72] skip ahead

* arrive when ???

l_2a69:
	st.b	d0                                	| [$2a69: ld      a,$ff] A := #FF
	jra	l_2a72                             	| [$2a6b: jp      $2a72] skip next 2 steps

* arrive when ???

l_2a6e:
	and.b	#0x0f,d0                         	| [$2a6e: and     $0f] mask bits, now between 0 and #F
	sub.b	#0x09,d0                         	| [$2a70: sub     $09] subtract 9

* other conditions all arrive here
* A is loaded with a number between #F6 and #E

l_2a72:
	move.b	d0,d2                           	| [$2a72: ld      c,a] C := A
	move.b	d4,d0                           	| [$2a73: ld      a,e] A := E = barrel X position
	and.b	#0xf8,d0                         	| [$2a74: and     $f8] mask bits.  lower 3 bits are cleared
	add.b	d2,d0                            	| [$2a76: add     a,c] add C
	cmp.b	d4,d0                            	| [$2a77: cp      e] compare to barrel's X position.  less?
	jcs	l_2a7d                             	| [$2a78: jp      c,$2a7d] yes, skip next 2 steps

l_2a7b:
	clr.b	d0                               	| [$2a7b: xor     a] A := 0
	rts                                    	| [$2a7c: ret] return

l_2a7d:
	subq.b	#0x04,d0                        	| [$2a7d: sub     $04] subtract 4
	move.b	d0,(0x05,a2)                    	| [$2a7f: ld      (ix+$05),a] store A into Y position
	move.b	#0x01,d0                        	| [$2a82: ld      a,$01] A := 1
	rts                                    	| [$2a84: ret] return

* called from main routine at #19A1

check_for_mario_falling_2a85:
	move.b	ladder_status_6215,d0           	| [$2a85: ld      a,(ladder_status_6215)] load ladder status
	                               	| [$2a88: and     a] is mario on a ladder ?
	beq.b	0f                               	| [...]
	rts                                    	| [$2a89: ret     nz] yes, return [...]
0:

	move.b	jumping_status_6216,d0          	| [$2a8a: ld      a,(jumping_status_6216)] load jumping status
	                               	| [$2a8d: and     a] is mario jumping ?
	beq.b	0f                               	| [...]
	rts                                    	| [$2a8e: ret     nz] yes, return [...]
0:

	move.b	elevator_status_6398,d0         	| [$2a8f: ld      a,(elevator_status_6398)] load A with elevator status
	cmp.b	#0x01,d0                         	| [$2a92: cp      $01] is mario riding an elevator?
	bne.b	0f                               	| [...]
	rts                                    	| [$2a94: ret     z] yes, return [...]
0:

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2a95: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	subq.b	#0x03,d0                        	| [$2a98: sub     $03] subtract 3
	move.b	d0,d5                           	| [$2a9a: ld      h,a] store into H
	move.b	mario_y_position_6205,d0	| [$2a9b: ld      a,(mario_y_position_6205)] load A with Mario's Y position
	add.b	#0x0c,d0                         	| [$2a9e: add     a,$0c] add #0C = 13 decimal
	move.b	d0,d6                           	| [$2aa0: ld      l,a] store into L

	movem.w	d5/d6,-(sp)                        	| [$2aa1: push    hl] save to stack
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$2aa2: call    $2ff0] load HL with screen position of mario's feet
	movem.w	(sp)+,d3/d4                    	| [$2aa5: pop     de] restore , DE now has the sprite X,Y addresses
	jbsr	osd_r_videoram                         	| [$2aa6: ld      a,(hl)] load A with the screen item at mario's feet
	cmp.b	#0xb0,d0                         	| [$2aa7: cp      $b0] > #B0 ?
	jcs	l_2ab4                             	| [$2aa9: jp      c,$2ab4] yes, skip next 4 steps

	and.b	#0x0f,d0                         	| [$2aac: and     $0f] else mask bits, now between 0 and #F
	cmp.b	#0x08,d0                         	| [$2aae: cp      $08] > 8 ?
	jcc	l_2ab4                             	| [$2ab0: jp      nc,$2ab4] no, skip next step

	rts                                    	| [$2ab3: ret] else return

* arrive when mario near an [left?] edge

l_2ab4:
	move.b	d3,d0                           	| [$2ab4: ld      a,d] load A with mario's X position
	and.b	#0x07,d0                         	| [$2ab5: and     $07] mask bits, now between 0 and 7.  zero?
	jeq	l_2acd                             	| [$2ab7: jp      z,$2acd] yes, skip ahead, mario is falling

	move.w	#0x20,d1                        	| [$2aba: ld      bc,$0020] BC := 20 32
	sub.w	d1,d7                            	| [$2abd: sbc     hl,bc] subtract from HL.  now HL is the next column?
	jbsr	osd_r_videoram                         	| [$2abf: ld      a,(hl)] load A with the screen element of this location
	cmp.b	#0xb0,d0                         	| [$2ac0: cp      $b0] > #B0 ?
	jcs	l_2acd                             	| [$2ac2: jp      c,$2acd] yes, skip ahead, mario is falling

	and.b	#0x0f,d0                         	| [$2ac5: and     $0f] else mask bits, now betwen 0 and F
	cmp.b	#0x08,d0                         	| [$2ac7: cp      $08] > 8 ?
	jcc	l_2acd                             	| [$2ac9: jp      nc,$2acd] no, mario is falling, skip ahead
	rts                                    	| [$2acc: ret] return

* mario is falling

l_2acd:
	move.b	#0x01,d0                        	| [$2acd: ld      a,$01] A := 1
	move.b	d0,mario_falling_indicator_6221 	| [$2acf: ld      (mario_falling_indicator_6221),a] store into mario falling indicator
	rts                                    	| [$2ad2: ret] return

* called from #25FE

l_2ad3:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2ad3: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	move.b	d0,d1                           	| [$2ad6: ld      b,a] copy to B
	move.b	mario_y_position_6205,d0	| [$2ad7: ld      a,(mario_y_position_6205)] load A with mario's Y position
	cmp.b	#0x50,d0                         	| [$2ada: cp      $50] is mario on upper level ?
	jeq	l_2aea                             	| [$2adc: jp      z,$2aea] yes, skip ahead

	cmp.b	#0x78,d0                         	| [$2adf: cp      $78] mario on upper pie tray?
	jeq	l_2af6                             	| [$2ae1: jp      z,$2af6] yes, skip ahead

	cmp.b	#0xc8,d0                         	| [$2ae4: cp      $c8] mario on lower pie tray ?
	jeq	l_2af0                             	| [$2ae6: jp      z,$2af0] yes, skip ahead

	rts                                    	| [$2ae9: ret] else return

l_2aea:
	move.b	top_conveyor_direction_vector_63a3,d0	| [$2aea: ld      a,(top_conveyor_direction_vector_63a3)] load A with top conveyor direction vector [why?  level complete here?]
	jra	l_2b02                             	| [$2aed: jp      $2b02] skip ahead

l_2af0:
	move.b	pie_direction_lower_level_63a6,d0	| [$2af0: ld      a,(pie_direction_lower_level_63a6)] load A with pie direction lower level
	jra	l_2b02                             	| [$2af3: jp      $2b02] skip ahead

l_2af6:
	move.b	d1,d7                           	| [$2af6: ld      a,b] load A with mario X position
	move.b	upper_right_pie_tray_vector_63a5,d0	| [$2af9: ld      a,(upper_right_pie_tray_vector_63a5)] load A with upper right pie tray vector
	cmp.b	#0x80,d7                         	| [$2af7: cp      $80] is mario on the left side of the fire?
	jcc	l_2b02                             	| [$2afc: jp      nc,$2b02] no, skip next step
	move.b	upper_left_pie_tray_vector_63a4,d0	| [$2aff: ld      a,(upper_left_pie_tray_vector_63a4)] else load A with upper left pie tray vector
l_2b02:
	add.b	d1,d0                            	| [$2b02: add     a,b] add vector to mario's X position
	move.b	d0,jump_if_bit_7_of_mario_x_position_is_set_6203	| [$2b03: ld      (jump_if_bit_7_of_mario_x_position_is_set_6203),a] set mario's X position
	move.b	d0,mario_sprite_x_position_694c 	| [$2b06: ld      (mario_sprite_x_position_694c),a] set mario's sprite X position
	jbsr	l_241f                            	| [$2b09: call    $241f] loads DE with something depending on mario's position
	lea	jump_if_bit_7_of_mario_x_position_is_set_6203,a0	| [$2b0c: ld      hl,jump_if_bit_7_of_mario_x_position_is_set_6203] load HL with mario's X position
	subq.b	#1,d4                           	| [$2b0f: dec     e] E == 1 ?
	jeq	l_2b18                             	| [$2b10: jp      z,$2b18] yes, skip ahead

	subq.b	#1,d3                           	| [$2b13: dec     d] else D == 1 ?
	jeq	l_2b1a                             	| [$2b14: jp      z,$2b1a] yes, skip ahead
	rts                                    	| [$2b17: ret] return

l_2b18:
	subq.b	#1,(a0)                         	| [$2b18: dec     (hl)] decrease mario's X position
	rts                                    	| [$2b19: ret] return

l_2b1a:
	addq.b	#1,(a0)                         	| [$2b1a: inc     (hl)] increase
	rts                                    	| [$2b1b: ret] return

* called from #1C05

l_2b1c:
	lea	mario_array_6200,a2            	| [$2b1c: ld      ix,mario_array_6200] set IX for mario's array
	jbsr	l_2b29                            	| [$2b20: call    $2b29] do stuff for jumping.  certain crieria will set A and B and return without the rest of this sub.
	jbsr	handle_jump_stuff_for_elevators_29af 	| [$2b23: call    $29af] handle jump stuff for elevators
	clr.b	d0                               	| [$2b26: xor     a] A := 0
	move.b	d0,d1                           	| [$2b27: ld      b,a] B := 0
	rts                                    	| [$2b28: ret] return

* arrive here when a jump is in progress
* called from #2B20 above

l_2b29:
	move.b	screen_number_6227,d0           	| [$2b29: ld      a,(screen_number_6227)] load A with screen number
	subq.b	#1,d0                           	| [$2b2c: dec     a] are we on the girders?
	jne	l_2b53                             	| [$2b2d: jp      nz,$2b53] No, skip ahead

* jump on girders

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2b30: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's x position
	move.b	d0,d5                           	| [$2b33: ld      h,a] copy to H
	move.b	mario_y_position_6205,d0	| [$2b34: ld      a,(mario_y_position_6205)] load A with mario's y position
	addq.b	#0x07,d0                        	| [$2b37: add     a,$07] add 7 to y position
	move.b	d0,d6                           	| [$2b39: ld      l,a] copy to L
	jbsr	l_2b9b                            	| [$2b3a: call    $2b9b] check for ???
	tst.b	d0                               	| [$2b3d: and     a] == 0 ?
	jeq	l_2b51                             	| [$2b3e: jp      z,$2b51] yes, skip ahead and return

	move.b	d4,d0                           	| [$2b41: ld      a,e] A := E
	sub.b	d2,d0                            	| [$2b42: sub     c] subtract C (???)
	cmp.b	#0x04,d0                         	| [$2b43: cp      $04] < 4 ?
	jcc	l_2b74                             	| [$2b45: jp      nc,$2b74] no, skip ahead, clear A and B, and return

	move.b	d2,d0                           	| [$2b48: ld      a,c] A := C
	subq.b	#0x07,d0                        	| [$2b49: sub     $07] subtract 7
	move.b	d0,mario_y_position_6205	| [$2b4b: ld      (mario_y_position_6205),a] store A into mario's Y position
	move.b	#0x01,d0                        	| [$2b4e: ld      a,$01] A : = 1
	move.b	d0,d1                           	| [$2b50: ld      b,a] B := 1

l_2b51:
	move.l	(sp)+,a0                        	| [$2b51: pop     hl] move stack pointer back 1 level
	rts                                    	| [$2b52: ret] return to higher sub (EG #1C08)

* arrive from #2B2D when jumping, not on girders, via call from #2B20

l_2b53:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2b53: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario X position
	subq.b	#0x03,d0                        	| [$2b56: sub     $03] subtract 3
	move.b	d0,d5                           	| [$2b58: ld      h,a] store into H
	move.b	mario_y_position_6205,d0	| [$2b59: ld      a,(mario_y_position_6205)] load A with mario's Y position
	addq.b	#0x07,d0                        	| [$2b5c: add     a,$07] add 7
	move.b	d0,d6                           	| [$2b5e: ld      l,a] store into L
	jbsr	l_2b9b                            	| [$2b5f: call    $2b9b] check for ???
	cmp.b	#0x02,d0                         	| [$2b62: cp      $02] A == 2 ?
	jeq	l_2b7a                             	| [$2b64: jp      z,$2b7a] yes, skip ahead

	move.b	d3,d0                           	| [$2b67: ld      a,d] A := D
	addq.b	#0x07,d0                        	| [$2b68: add     a,$07] add 7
	move.b	d0,d5                           	| [$2b6a: ld      h,a] H := A
	move.b	d4,d6                           	| [$2b6b: ld      l,e] L := E
	jbsr	l_2b9b                            	| [$2b6c: call    $2b9b] check for ???
	tst.b	d0                               	| [$2b6f: and     a] A == 0 ?
	bne.b	0f                               	| [...]
	rts                                    	| [$2b70: ret     z] yes, return [...]
0:

	jra	l_2b7a                             	| [$2b71: jp      $2b7a] else skip ahead

l_2b74:
	clr.b	d0                               	| [$2b74: ld      a,$00] A := 0
	clr.b	d1                               	| [$2b76: ld      b,$00] B := 0
	move.l	(sp)+,a0                        	| [$2b78: pop     hl] move stack pointer to return to higher sub
	rts                                    	| [$2b79: ret] return

l_2b7a:
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2b7e: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	tst.b	mario_jump_direction_6210    	| [$2b7a: ld      a,(mario_jump_direction_6210)] load A with mario's jump direction
	                               	| [$2b7d: and     a] jumping to the right ?
	jeq	l_2b8b                             	| [$2b81: jp      z,$2b8b] if jumping right then skip next 3 steps

	or.b	#0x07,d0                          	| [$2b84: or      $07] mask bits, turn on lower 3 bits
	subq.b	#0x04,d0                        	| [$2b86: sub     $04] subtract 4
	jra	l_2b91                             	| [$2b88: jp      $2b91] skip ahead

l_2b8b:
	sub.b	#0x08,d0                         	| [$2b8b: sub     $08] subtract 8
	or.b	#0x07,d0                          	| [$2b8d: or      $07] mask bits, turn on lower 3 bits
	addq.b	#0x04,d0                        	| [$2b8f: add     a,$04] add 4

l_2b91:
	move.b	d0,jump_if_bit_7_of_mario_x_position_is_set_6203	| [$2b91: ld      (jump_if_bit_7_of_mario_x_position_is_set_6203),a] set mario's X position
	move.b	d0,mario_sprite_x_position_694c 	| [$2b94: ld      (mario_sprite_x_position_694c),a] set mario's sprite X position
	move.b	#0x01,d0                        	| [$2b97: ld      a,$01] A := 1
	move.l	(sp)+,a0                        	| [$2b99: pop     hl] move stack pointer to return to higher sub
	rts                                    	| [$2b9a: ret] return

* called from #2B3A and #2B6C and #2B5F above

l_2b9b:

	movem.w	d5/d6,-(sp)                        	| [$2b9b: push    hl] save HL
	jbsr	convert_hl_into_vram_address_2ff0                            	| [$2b9c: call    $2ff0] convert HL into VRAM address
	movem.w	(sp)+,d3/d4                    	| [$2b9f: pop     de] restore into DE
	jbsr	osd_r_videoram                         	| [$2ba0: ld      a,(hl)] load A with the screen item in VRAM
	cmp.b	#0xb0,d0                         	| [$2ba1: cp      $b0] > #B0 ? (???)
	jcs	l_2bd9                             	| [$2ba3: jp      c,$2bd9] yes, skip ahead, set results to zero and return

	and.b	#0x0f,d0                         	| [$2ba6: and     $0f]
	cmp.b	#0x08,d0                         	| [$2ba8: cp      $08]
	jcc	l_2bd9                             	| [$2baa: jp      nc,$2bd9] yes, skip ahead, set results to zero and return

	jbsr	osd_r_videoram                         	| [$2bad: ld      a,(hl)] load A with the screen item in VRAM
	cmp.b	#0xc0,d0                         	| [$2bae: cp      $c0] == #C0 ?
	jeq	l_2bd9                             	| [$2bb0: jp      z,$2bd9] yes, skip ahead, set results to zero and return

	jcs	l_2bdc                             	| [$2bb3: jp      c,$2bdc] < #C0 ?  Yes, skip ahead to handle

	cmp.b	#0xd0,d0                         	| [$2bb6: cp      $d0] < #D0 ?
	jcs	l_2bcb                             	| [$2bb8: jp      c,$2bcb] yes, skip ahead to handle

	cmp.b	#0xe0,d0                         	| [$2bbb: cp      $e0] < #E0 ?
	jcs	l_2bc5                             	| [$2bbd: jp      c,$2bc5] yes, skip ahead to handle

	cmp.b	#0xf0,d0                         	| [$2bc0: cp      $f0] < #F0 ?
	jcs	l_2bcb                             	| [$2bc2: jp      c,$2bcb] yes, skip ahead to handle (same as < #D0 )

* when landing or jumping from a girder ???

l_2bc5:
	and.b	#0x0f,d0                         	| [$2bc5: and     $0f] mask bits, now between 0 and #F
	subq.b	#1,d0                           	| [$2bc7: dec     a] decrease.  now #FF or between 0 and #E
	jra	l_2bcf                             	| [$2bc8: jp      $2bcf] skip ahead

* when jumping his head (harmlessly) into a girder above him?

l_2bcb:
	and.b	#0x0f,d0                         	| [$2bcb: and     $0f] mask bits, now between 0 and #F
	sub.b	#0x09,d0                         	| [$2bcd: sub     $09] subtract 9.  now between #F7 and 6

l_2bcf:
	move.b	d0,d2                           	| [$2bcf: ld      c,a] C := A
	move.b	d4,d0                           	| [$2bd0: ld      a,e] A := E = original Y location
	and.b	#0xf8,d0                         	| [$2bd1: and     $f8] mask bits.  we dont care about 3 least sig. bits
	add.b	d2,d0                            	| [$2bd3: add     a,c] add C
	move.b	d0,d2                           	| [$2bd4: ld      c,a] C := A
	cmp.b	d4,d0                            	| [$2bd5: cp      e] < E (original Y location) ?
	jcs	l_2be1                             	| [$2bd6: jp      c,$2be1] no, skip ahead

* mario is jumping clear, nothing in his way

l_2bd9:
	clr.b	d0                               	| [$2bd9: xor     a] A := 0
	move.b	d0,d1                           	| [$2bda: ld      b,a] B := 0
	rts                                    	| [$2bdb: ret] return

* mario is jumping and about to land on a conveyor or a girder on the rivets

l_2bdc:
	move.b	d4,d0                           	| [$2bdc: ld      a,e] A := E = original Y location
	and.b	#0xf8,d0                         	| [$2bdd: and     $f8] mask bits.  we dont care about 3 least sig. bits
	subq.b	#1,d0                           	| [$2bdf: dec     a] decrease
	move.b	d0,d2                           	| [$2be0: ld      c,a] copy to C

* mario landing or his head passing through girder above

l_2be1:
	move.b	mario_jump_height_620c,d0       	| [$2be1: ld      a,(mario_jump_height_620c)] load A with mario's jump height
	sub.b	(0x05,a2),d0                     	| [$2be4: sub     (ix+$05)] subtract the item's Y position (???) [EG IX = #6200 , so this is mario's Y position)
	add.b	d4,d0                            	| [$2be7: add     a,e] add E (original Y position)
	cmp.b	d2,d0                            	| [$2be8: cp      c] == C ?
	jeq	l_2bef                             	| [$2be9: jp      z,$2bef] yes, skip next step

* mario head passing or landing on a noneven girder

	jcc	l_2bf8                             	| [$2bec: jp      nc,$2bf8] < C ?  no, skip next 4 steps

*  arrive when landing

l_2bef:
	move.b	d2,d0                           	| [$2bef: ld      a,c] A := C = original location masked
	subq.b	#0x07,d0                        	| [$2bf0: sub     $07] subtract 7 to adjust for mario' height
	move.b	d0,mario_y_position_6205	| [$2bf2: ld      (mario_y_position_6205),a] store A into mario's Y position
	jra	l_2bfd                             	| [$2bf5: jp      $2bfd] skip next 3 steps

* arrive when mario has his head passing through girder above

l_2bf8:
	move.b	#0x02,d0                        	| [$2bf8: ld      a,$02] A := 2
	clr.b	d1                               	| [$2bfa: ld      b,$00] B := 0
	rts                                    	| [$2bfc: ret] return

* arrive when ?

l_2bfd:
	move.b	#0x01,d0                        	| [$2bfd: ld      a,$01] A := 1
	move.b	d0,d1                           	| [$2bff: ld      b,a] B := 1
	move.l	(sp)+,a0                        	| [$2c00: pop     hl]
	move.l	(sp)+,a0                        	| [$2c01: pop     hl] set stack pointer to return to higher subs
	rts                                    	| [$2c02: ret] return

* called from main routine at #1989

l_2c03:
	move.b	#0x01,d0                        	| [$2c03: ld      a,$01] \ Return if screen is not barrels
	jbsr	only_continues_if_given_level_0030                            	| [$2c05: rst     $30] /
	jbsr	continue_only_if_mario_alive_0010                            	| [$2c06: rst     $10] Return if Mario is not alive

	move.b	barrel_deployment_indicator_6393,d0	| [$2c07: ld      a,(barrel_deployment_indicator_6393)] \  Return if we are already in the process of deploying a barrel, no need to deploy another one
	ror.b	#1,d0                            	| [$2c0a: rrca]|
	bcc.b	0f                               	| [...]
	rts                                    	| [$2c0b: ret     c] / [...]
0:

	move.b	bonus_timer_62b1,d0             	| [$2c0c: ld      a,(bonus_timer_62b1)] \  Return if bonus timer is 0, no more barrels are deployed at this time
	                               	| [$2c0f: and     a]|
	bne.b	0f                               	| [...]
	rts                                    	| [$2c10: ret     z] / [...]
0:

	move.b	d0,d2                           	| [$2c11: ld      c,a] otherwise load C with current timer value
	move.b	initial_clock_value_62b0,d0     	| [$2c12: ld      a,(initial_clock_value_62b0)] load a with initial clock value
	subq.b	#0x02,d0                        	| [$2c15: sub     $02] subtract 2
	cmp.b	d2,d0                            	| [$2c17: cp      c] compare with C = current timer
	jcs	l_2c7b                             	| [$2c18: jp      c,$2c7b] if carry, jump ahead - we are within first 2 clicks of the round - special barrels for this.

	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2c1b: ld      a,(crazy_blue_barrel_indicator_6382)] else load A with crazy / blue barrel indicator
	btst.b	#1,d0                           	| [$2c1e: bit     1,a] test bit 1 - is this the second barrel after the first crazy ?
	jne	l_2c86                             	| [$2c20: jp      nz,$2c86] if it is, then deploy normal barrel| this barrel is never crazy.

	move.b	difficulty_level_6380,d0                 	| [$2c23: ld      a,(difficulty_level_6380)] if not, then load A with difficulty from 1 to 5
	move.b	d0,d1                           	| [$2c26: ld      b,a] For B = 1 to difficulty
	move.b	framecounter_601a,d0            	| [$2c27: ld      a,(framecounter_601a)] load A with timer value.  this clock counts down from #FF to 00 over and over...
	and.b	#0x1f,d0                         	| [$2c2a: and     $1f] zero out left 3 bits.  the result is between 0 and #1F

l_2c2c:
	cmp.b	d1,d0                            	| [$2c2c: cp      b] compare with Loop counter B (between 1 and 5) ... is higher as time decreases
	jeq	l_2c33                             	| [$2c2d: jp      z,$2c33] if it equal then jump ahead to check for a crazy barrel

	subq.b	#1,d1                           	| [...]
	jne	l_2c2c                             	| [$2c30: djnz    $2c2c] else Next B

	rts                                    	| [$2c32: ret] Return without crazy barrel (?)

* chances of arriving here depend on difficulty D/32 chance .  high levels this is 5/32 = 16%

l_2c33:
	move.b	initial_clock_value_62b0,d0     	| [$2c33: ld      a,(initial_clock_value_62b0)] load A with initial clock value
	lsr.b	#1,d0                            	| [$2c36: srl     a] Shift Right (div 2)
	cmp.b	d2,d0                            	| [$2c38: cp      c] is the current timer value < 1/2 initial clock value ?
	jcs	l_2c41                             	| [$2c39: jp      c,$2c41] NO, skip next 3 steps

	move.b	rngtimer2_6019,d0               	| [$2c3c: ld      a,(rngtimer2_6019)] Yes, Load A with this timer value (random)
	ror.b	#1,d0                            	| [$2c3f: rrca] Test Bit 1 of this
	bcs.b	0f                               	| [...]
	rts                                    	| [$2c40: ret     nc] If bit 1 is not set, return . this gives 50% extra chance of no crazy barrel when clock is getting low [...]
0:

l_2c41:
	jbsr	random_0057                            	| [$2c41: call    $0057] else load A with a random number

* hack to increase crazy barrels
* 2C41  3E 00          LD A, #00
* 2C43  00             NOP

* hack to increase crazy barrels:
* 2C44 E600    AND     #00             | mask all 4 bits to zero
*

	and.b	#0x0f,d0                         	| [$2c44: and     $0f] mask out left 4 bits to zero.  A becomes a number between 0 and #F
	jne	l_2c86                             	| [$2c46: jp      nz,$2c86] If result is not zero, deploy a normal barrel.  this routine sets #6382 to 0,
                                        * loads A with 3 and returns to #2C4F

* else get a crazy barrel
* can arrive here from #2C7E = first click of round is always crazy barrel

l_2c49:
	move.b	#0x01,d0                        	| [$2c49: ld      a,$01] else A := 1 = crazy barrel code

* arrive here from second barrel that is not crazy.  A is preloaded with 2.  From #2C83

l_2c4b:
	move.b	d0,crazy_blue_barrel_indicator_6382	| [$2c4b: ld      (crazy_blue_barrel_indicator_6382),a] set a barrel in motion for next barrel, bit 1=crazy, 2 = second barrel which is always normal, 0 for normal barrel
	addq.b	#1,d0                           	| [$2c4e: inc     a] Increment A for the deployment

l_2c4f:
	move.b	d0,deployment_indicator_638f    	| [$2c4f: ld      (deployment_indicator_638f),a] store A into the state of the barrel deployment between 3 and 0
	move.b	#0x01,d0                        	| [$2c52: ld      a,$01] A := 1
	move.b	d0,barrel_deployment_indicator_6392	| [$2c54: ld      (barrel_deployment_indicator_6392),a] set barrel deployment indicator
	move.b	blue_barrel_counter_62b2,d0     	| [$2c57: ld      a,(blue_barrel_counter_62b2)] load A with blue barrel counter
	cmp.b	d2,d0                            	| [$2c5a: cp      c] compare with current timer
	beq.b	0f                               	| [...]
	rts                                    	| [$2c5b: ret     nz] return if not equal [...]
0:

	sub.b	#0x08,d0                         	| [$2c5c: sub     $08] if equal then this will be a blue barrel.  decrement A by 8
	move.b	d0,blue_barrel_counter_62b2     	| [$2c5e: ld      (blue_barrel_counter_62b2),a] put back into blue barrel counter
	move.w	#0x0020,d3                      	| [$2c61: ld      de,$0020] now check if all 5 fires are out 32
	lea	start_of_fires_table_6400,a0   	| [$2c64: ld      hl,start_of_fires_table_6400] #6400 by 20's contian 1 if these fires exist

	move.b	#NB_FIRES,d1                        	| [$2c67: ld      b,$05] FOR B = 1 to 5

l_2c69:
	move.b	(a0),d0                         	| [$2c69: ld      a,(hl)] get fire status
	                               	| [$2c6a: and     a] is this fire onscreen?
	jeq	l_2c72                             	| [$2c6b: jp      z,$2c72] no, skip next 3 steps| we don't have 5 fires onscreen and therefore have room for a blue barrel

	add.w	d3,a0                            	| [$2c6e: add     hl,de] yes, add #20 offset to test next fire and loop again
	subq.b	#1,d1                           	| [...]
	jne	l_2c69                             	| [$2c6f: djnz    $2c69] next B

	rts                                    	| [$2c71: ret] not a blue barrel, return

l_2c72:
	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2c72: ld      a,(crazy_blue_barrel_indicator_6382)] load A with crazy/blue barrel indicator
	or.b	#0x80,d0                          	| [$2c75: or      $80] or with #80  - set leftmost bit on to indicate blue barrel is next
	move.b	d0,crazy_blue_barrel_indicator_6382	| [$2c77: ld      (crazy_blue_barrel_indicator_6382),a] store into crazy/blue barrel indicator
	rts                                    	| [$2c7a: ret] return with blue barrel

* we arrive here if timer is within first 2 clicks when deploying a barrel from #2C18

l_2c7b:
	addq.b	#0x02,d0                        	| [$2c7b: add     a,$02] A := A + 2 (A had the initial clock value -2, now it has the initial clock value)
	cmp.b	d2,d0                            	| [$2c7d: cp      c] compare to current timer value - are we starting this round now?
	jeq	l_2c49                             	| [$2c7e: jp      z,$2c49] yes, do a crazy barrel

	move.b	#0x02,d0                        	| [$2c81: ld      a,$02] else A := 2 for the second barrel| it is always normal
	jra	l_2c4b                             	| [$2c83: jp      $2c4b] jump back and continue deployment

* arrive here when the second barrel is being deployed?
* from #2C20

l_2c86:
	clr.b	d0                               	| [$2c86: xor     a] A := 0
	move.b	d0,crazy_blue_barrel_indicator_6382	| [$2c87: ld      (crazy_blue_barrel_indicator_6382),a] barrel indicator to 0 == normal barrel
	move.b	#0x03,d0                        	| [$2c8a: ld      a,$03] A := 3 -- use for upcoming deployement indicator == position #3
	jra	l_2c4f                             	| [$2c8c: jp      $2c4f] Jump back

* called from main routine #1986

handle_barrel_rolls_2c8f:
	move.b	#0x01,d0                        	| [$2c8f: ld      a,$01] A := 1 = code for girders
	jbsr	only_continues_if_given_level_0030                            	| [$2c91: rst     $30] if screen is girders, continue.  else RET
	jbsr	continue_only_if_mario_alive_0010                            	| [$2c92: rst     $10] if mario is alive, continue.  else RET
	move.b	barrel_deployment_indicator_6393,d0	| [$2c93: ld      a,(barrel_deployment_indicator_6393)] load A with barrel deployment indicator
	ror.b	#1,d0                            	| [$2c96: rrca] is a barrel being deployed ?
	jcs	l_2d15                             	| [$2c97: jp      c,$2d15] yes, skip ahead

	move.b	barrel_deployment_indicator_6392,d0	| [$2c9a: ld      a,(barrel_deployment_indicator_6392)] else load A with other barrel deployment indicator
	ror.b	#1,d0                            	| [$2c9d: rrca] deployed ?
	bcs.b	0f                               	| [...]
	rts                                    	| [$2c9e: ret     nc] no, return [...]
0:

* else a barrel is being deployed

	lea	start_of_barrel_info_table_6700,a2	| [$2c9f: ld      ix,start_of_barrel_info_table_6700] load IX with start of barrel memory
	move.w	#0x0020,d3                      	| [$2ca3: ld      de,$0020] incrementer gets #20 32
	move.b	#NB_BARRELS,d1                        	| [$2ca6: ld      b,$0a] For B = 1 to #0A (all 10 barrels)

l_2ca8:
	move.b	(a2),d0                    	| [$2ca8: ld      a,(ix+$00)] load A with +0 indicator
	ror.b	#1,d0                            	| [$2cab: rrca] is this barrel already rolling ?
	jcs	l_2cb3                             	| [$2cac: jp      c,$2cb3] yes, then jump ahead and test next barrel

	ror.b	#1,d0                            	| [$2caf: rrca] else is this barrel already being deployed ?
	jcc	barrel_being_deployed_2cb8                             	| [$2cb0: jp      nc,$2cb8] no, then jump ahead

l_2cb3:
	add.w	d3,a2                            	| [$2cb3: add     ix,de] Increase to next barrel
	subq.b	#1,d1                           	| [...]
	jne	l_2ca8                             	| [$2cb5: djnz    $2ca8] Next B

	rts                                    	| [$2cb7: ret] return

* arrive here when a barrel is being deployed

barrel_being_deployed_2cb8:
	STORE_RAM_ADDRESS_LE	a2,barrel_start_address_62aa    	| [$2cb8: ld      (barrel_start_address_62aa),ix] save this barrel indicator into #62AA.  it is recalled at #2D55
	move.b	#0x02,(a2)                 	| [$2cbc: ld      (ix+$00),$02] set deployement indicator
	clr.w	d3                               	| [$2cc0: ld      d,$00] D := 0
	move.b	#NB_BARRELS,d0                        	| [$2cc2: ld      a,$0a] A := #0A
	sub.b	d1,d0                            	| [$2cc4: sub     b] A = A - B |  B has the number of the barrel A now will be 0 if this is the first barrel, #0A if the last
	add.b	d0,d0                            	| [$2cc5: add     a,a] A = A * 2
	add.b	d0,d0                            	| [$2cc6: add     a,a] A = A * 2 (A is now 4 times what it was)
	move.b	d0,d3                           	| [$2cc7: ld      e,a] copy this to E
	lea	start_of_bouncers_or_barrels_sprites_6980,a0	| [$2cc8: ld      hl,start_of_bouncers_or_barrels_sprites_6980] load HL with starting sprite address for the barrels
	add.w	d3,a0                            	| [$2ccb: add     hl,de] Now add in offset depending on the barrel number ( will vary from 0 to #28 by 4's)
	STORE_RAM_ADDRESS_LE	a0,sprite_variable_start_62ac   	| [$2ccc: ld      (sprite_variable_start_62ac),hl] store this info in #62AC. will vary from #80 to #A8
	move.b	#0x01,d0                        	| [$2ccf: ld      a,$01] A := 1
	move.b	d0,barrel_deployment_indicator_6393	| [$2cd1: ld      (barrel_deployment_indicator_6393),a] set barrel deployment indicator
	move.w	#0x0501,d3                      	| [$2cd4: ld      de,$0501] load DE with task #5, parameter 1 update onscreen bonus timer and play sound & change to red if below 1000
	jbsr	insert_task_309f                            	| [$2cd7: call    $309f] insert task
	lea	bonus_timer_62b1,a0            	| [$2cda: ld      hl,bonus_timer_62b1] load bonus counter into HL
	subq.b	#1,(a0)                         	| [$2cdd: dec     (hl)] decrement bonus counter.  Is it zero?
	jne	l_2ce6                             	| [$2cde: jp      nz,$2ce6] no, skip next 2 steps

	move.b	#0x01,d0                        	| [$2ce1: ld      a,$01] A := 1
	move.b	d0,time_has_run_out_indicator_6386	| [$2ce3: ld      (time_has_run_out_indicator_6386),a] store into bonus timer out indicator

l_2ce6:
	move.b	(a0),d0                         	| [$2ce6: ld      a,(hl)] load A with bonus counter
	cmp.b	#0x04,d0                         	| [$2ce7: cp      $04] bonus <= 400 ?
	jcc	l_2cf6                             	| [$2ce9: jp      nc,$2cf6] no, skip ahead

	lea	extra_barrels_sprites_69a8,a0  	| [$2cec: ld      hl,extra_barrels_sprites_69a8] else load HL with extra barrels sprites
	add.b	d0,d0                            	| [$2cef: add     a,a]
	add.b	d0,d0                            	| [$2cf0: add     a,a] A := A * 4
	clr.w	d3                               	| [$2cf2: ld      d,$00] D := 0.  DE now has offset based on timer
	move.b	d0,d3                           	| [$2cf1: ld      e,a] copy to E
	add.w	d3,a0                            	| [$2cf4: add     hl,de] compute which sprite to remove based on timer
	move.b	d3,(a0)                         	| [$2cf5: ld      (hl),d] clear the sprite

* IX holds 6700 +N*20 = start of barrel N info
* a barrel is being deployed

l_2cf6:
	move.b	#0x15,(0x07,a2)                 	| [$2cf6: ld      (ix+$07),$15] set barrel sprite value to #15
	move.b	#0x0b,(0x08,a2)                 	| [$2cfa: ld      (ix+$08),$0b] set barrel color to #0B
	clr.b	(0x15,a2)                        	| [$2cfe: ld      (ix+$15),$00] set +15 indicator to 0 = normal barrel,  [1 = blue barrel]
	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2d02: ld      a,(crazy_blue_barrel_indicator_6382)] load A with Crazy/Blue barrel indicator
	rol.b	#1,d0                            	| [$2d05: rlca] is this a blue barrel ?
	jcc	l_2d15                             	| [$2d06: jp      nc,$2d15] No blue barrel, then skip next 3 steps

* blue barrel

	move.b	#0x19,(0x07,a2)                 	| [$2d09: ld      (ix+$07),$19] set sprite for blue barrel
	move.b	#0x0c,(0x08,a2)                 	| [$2d0d: ld      (ix+$08),$0c] set sprite color to blue
	move.b	#0x01,(0x15,a2)                 	| [$2d11: ld      (ix+$15),$01] set blue barrel indicator

l_2d15:
	lea	kong_misc_counter_62af,a0  	| [$2d15: ld      hl,kong_misc_counter_62af] load HL with deployment timer
	subq.b	#1,(a0)                         	| [$2d18: dec     (hl)] count it down.  is the timer expired?
	beq.b	0f                               	| [...]
	rts                                    	| [$2d19: ret     nz] no, return [...]
0:

	move.b	#0x18,(a0)                      	| [$2d1a: ld      (hl),$18] else reset the counter back to #18
	* 2 = kong grabbing, 1 = kong holding, 0 = deploying, 3 = kong empty
	move.b	deployment_indicator_638f,d0    	| [$2d1c: ld      a,(deployment_indicator_638f)] load A with the deployment indicator. 
	                               	| [$2d1f: and     a] is a barrel being deployed right now?
	jeq	l_2d51                             	| [$2d20: jp      z,$2d51] yes, jump ahead

	move.b	d0,d2                           	| [$2d23: ld      c,a] else copy A to C
	lea	game_rom+0x3932,a0                      	| [$2d24: ld      hl,$3932] load HL with table data start
	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2d27: ld      a,(crazy_blue_barrel_indicator_6382)] load A with crazy/blue barrel indicator
	ror.b	#1,d0                            	| [$2d2a: rrca] Is this a crazy barrel?
	jcs	l_2d2f                             	| [$2d2b: jp      c,$2d2f] yes, skip next step

	subq.b	#1,d2                           	| [$2d2e: dec     c] no, Decrement C

l_2d2f:
	move.b	d2,d0                           	| [$2d2f: ld      a,c]
	add.b	d0,d0                            	| [$2d30: add     a,a]
	add.b	d0,d0                            	| [$2d31: add     a,a]
	add.b	d0,d0                            	| [$2d32: add     a,a]
	move.b	d0,d2                           	| [$2d33: ld      c,a]
	add.b	d0,d0                            	| [$2d34: add     a,a]
	add.b	d0,d0                            	| [$2d35: add     a,a]
	add.b	d2,d0                            	| [$2d36: add     a,c]
	clr.w	d3                               	| [$2d38: ld      d,$00] D: = 0
	move.b	d0,d3                           	| [$2d37: ld      e,a] A is #50 when barrel is crazy, #28 when normal
	add.w	d3,a0                            	| [$2d3a: add     hl,de] HL becomes #3982 when barrel is crazy, 395A when normal, 3932 when deploying all the way.  this will skip the final animation when dropping crazy barrel (?)
	jbsr	update_kong_sprites_004e                            	| [$2d3b: call    $004e] update kong's sprites
	lea	deployment_indicator_638f,a0   	| [$2d3e: ld      hl,deployment_indicator_638f] load HL with deployment indicator
	subq.b	#1,(a0)                         	| [$2d41: dec     (hl)] Decrease indicator
	jne	l_2d51                             	| [$2d42: jp      nz,$2d51] if indicator is not zero then jump ahead

	move.b	#0x01,d0                        	| [$2d45: ld      a,$01] else A := 1
	move.b	d0,kong_misc_counter_62af   	| [$2d47: ld      (kong_misc_counter_62af),a] Store into ???
	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2d4a: ld      a,(crazy_blue_barrel_indicator_6382)] load A with crazy/blue barrel indicator
	ror.b	#1,d0                            	| [$2d4d: rrca] Is this a crazy barrel?
	jcs	l_2d83                             	| [$2d4e: jp      c,$2d83] yes, jump ahead and load HL with #39CC and store into #62A8 and #62A9 and resume on #2D54

l_2d51:
	LOAD_ROM_ADDRESS_LE	unknown_rom_address_62a8,a0             	| [$2d51: ld      hl,(unknown_rom_address_62a8)] else load HL with (???)
l_2d54:
	move.b	(a0),d0                         	| [$2d54: ld      a,(hl)] load A with value in HL.  crazy barrel this value is #BB
	LOAD_RAM_ADDRESS_LE	barrel_start_address_62aa,a2	| [$2d55: ld      ix,(barrel_start_address_62aa)] load IX with Barrel start address saved above
	LOAD_RAM_ADDRESS_LE	sprite_variable_start_62ac,a1	| [$2d59: ld      de,(sprite_variable_start_62ac)] load DE with sprite variable start  EG #6980.  set in #2CCC
	cmp.b	#0x7f,d0                         	| [$2d5d: cp      $7f] A == #7F ? (time to deploy out of kong's hands ?)
	jeq	l_2d8c                             	| [$2d5f: jp      z,$2d8c] yes, jump ahead

	move.b	d0,d2                           	| [$2d62: ld      c,a] else copy A into C
	and.b	#0x7f,d0                         	| [$2d63: and     $7f] mask out leftmost bit.  result between 0 and  #7F
	move.b	d0,(a1)                         	| [$2d65: ld      (de),a] store into sprite X position
	move.b	(0x07,a2),d0                    	| [$2d66: ld      a,(ix+$07)] load A with barrel sprite value
	btst.b	#7,d2                           	| [$2d69: bit     7,c] test bit 7 of C
	jeq	l_2d70                             	| [$2d6b: jp      z,$2d70] yes, skip next step

	eor.b	#0x03,d0                         	| [$2d6e: xor     $03] no, toggle the rightmost 2 bits

l_2d70:
	addq.w	#1,a1                           	| [$2d70: inc     de] DE now has sprite value
	move.b	d0,(a1)+                         	| [$2d71: ld      (de),a] store new sprite
	move.b	d0,(0x07,a2)                    	| [$2d72: ld      (ix+$07),a] store into barrel sprite value
	move.b	(0x08,a2),d0                    	| [$2d75: ld      a,(ix+$08)] load A with barrel color
												| [$2d78: inc     de] DE now has sprite color value
	move.b	d0,(a1)+                         	| [$2d79: ld      (de),a] store color into sprite
	addq.w	#1,a0                           	| [$2d7a: inc     hl] increase HL.  EG #39CD for crazy barrel
	move.b	(a0)+,d0                         	| [$2d7b: ld      a,(hl)] load A with this value.  EG #4D for crazy barrel
												| [$2d7c: inc     de] DE now has Y position
	move.b	d0,(a1)                         	| [$2d7d: ld      (de),a] store into sprite Y position
												| [$2d7e: inc     hl] increase HL .  EG #39CE for crazy barrel
	STORE_ROM_ADDRESS_LE	a0,unknown_rom_address_62a8                 	| [$2d7f: ld      (unknown_rom_address_62a8),hl] store into 62A8.  EG 62A8 = CE, 62A9 = 39
	rts                                    	| [$2d82: ret] return

* arrive here because this barrel is crazy from #2D4E

l_2d83:
	lea	game_rom+0x39cc,a0                      	| [$2d83: ld      hl,$39cc] load HL with crazy barrel data

        * 39CC  BB
        * 39CD  4D

	STORE_ROM_ADDRESS_LE	a0,unknown_rom_address_62a8                 	| [$2d86: ld      (unknown_rom_address_62a8),hl] Load #62A8 and #62A9 with #39 and #CC
	jra	l_2d54                             	| [$2d89: jp      $2d54] jump back

* jump here from #2D5F
* kong is releasing a barrel (?)

l_2d8c:
	lea	game_rom+0x39c3,a0                      	| [$2d8c: ld      hl,$39c3] load HL with start of table data address
	STORE_ROM_ADDRESS_LE	a0,unknown_rom_address_62a8                 	| [$2d8f: ld      (unknown_rom_address_62a8),hl] store into ???
	move.b	#0x01,(0x01,a2)                 	| [$2d92: ld      (ix+$01),$01] set crazy barrel indicator
	move.b	crazy_blue_barrel_indicator_6382,d0	| [$2d96: ld      a,(crazy_blue_barrel_indicator_6382)] load A with crazy/blue barrel indicator

	ror.b	#1,d0                            	| [$2d99: rrca] roll right.  is this a crazy barrel?
	jcs	l_2da5                             	| [$2d9a: jp      c,$2da5] yes, skip next 2 steps

	clr.b	(0x01,a2)                        	| [$2d9d: ld      (ix+$01),$00] no , clear crazy indicator
	move.b	#0x02,(0x02,a2)                 	| [$2da1: ld      (ix+$02),$02] load motion indicator with 2 (rolling right)

l_2da5:
	move.b	#0x01,(a2)                 	| [$2da5: ld      (ix+$00),$01] barrel is now active
	move.b	#0x01,(0x0f,a2)                 	| [$2da9: ld      (ix+$0f),$01]
	clr.b	d0                               	| [$2dad: xor     a] A := 0
	clr.b	(0x10,a2)                    	| [$2dae: ld      (ix+$10),a] clear this indicator (???)
	clr.b	(0x11,a2)                    	| [$2db1: ld      (ix+$11),a]
	clr.b	(0x12,a2)                    	| [$2db4: ld      (ix+$12),a]
	clr.b	(0x13,a2)                    	| [$2db7: ld      (ix+$13),a]
	clr.b	(0x14,a2)                    	| [$2dba: ld      (ix+$14),a]
	clr.b	barrel_deployment_indicator_6393	| [$2dbd: ld      (barrel_deployment_indicator_6393),a] clear barrel deployment indicator
	clr.b	barrel_deployment_indicator_6392	| [$2dc0: ld      (barrel_deployment_indicator_6392),a] clear barrel deployment indicator
	move.b	(a1),d0                         	| [$2dc3: ld      a,(de)] load A with kong hand sprite X position
	move.b	d0,(0x03,a2)                    	| [$2dc4: ld      (ix+$03),a] store in barrel's X position
	addq.w	#3,a1                           	| [$2dc7: inc     de] * 3
	move.b	(a1),d0                         	| [$2dca: ld      a,(de)] load A with kong hand Y position
	move.b	d0,(0x05,a2)                    	| [$2dcb: ld      (ix+$05),a] store in barrel's Y position
	lea	game_rom+0x385c,a0                      	| [$2dce: ld      hl,$385c] load HL with table data start
	jbsr	update_kong_sprites_004e                            	| [$2dd1: call    $004e] update kong's sprites
	lea	kong_sprite_array_690b,a0      	| [$2dd4: ld      hl,kong_sprite_array_690b] load HL with start of Kong sprite
	move.b	#0xfc,d2                        	| [$2dd7: ld      c,$fc] load c with offset of -4
	jbsr	rst_38                            	| [$2dd9: rst     $38] move kong
	rts                                    	| [$2dda: ret] return

* deploys fireball/firefoxes
* Arrive here from main routine at #1995

l_2ddb:
	move.b	#0x0a,d0                        	| [$2ddb: ld      a,$0a] A := binary 1010 = code for rivets and conveyors
	jbsr	only_continues_if_given_level_0030                            	| [$2ddd: rst     $30] returns immediately on girders and elevators, else continue

	jbsr	continue_only_if_mario_alive_0010                            	| [$2dde: rst     $10] only continue if mario alive
	move.b	difficulty_level_6380,d0                 	| [$2ddf: ld      a,(difficulty_level_6380)] \  load B with (internal_difficulty+1)/2 (get's value between 1 and 3)
	addq.b	#1,d0                           	| [$2de2: inc     a]|
	                               	| [$2de3: and     a]| clear carry flag
	CLEAR_XC_FLAGS	| clear carry is not enough
	roxr.b	#1,d0                           	| [$2de4: rra]|
	move.b	d0,d1                           	| [$2de5: ld      b,a] /
	move.b	screen_number_6227,d0           	| [$2de6: ld      a,(screen_number_6227)] \  Increment B by 1 if we are on conveyors (to get value between 2 and 4)
	cmp.b	#0x02,d0                         	| [$2de9: cp      $02]|
	jne	l_2dee                             	| [$2deb: jr      nz,$2dee]|
	addq.b	#1,d1                           	| [$2ded: inc     b] /

l_2dee:

	move.b	#0xfe,d0                        	| [$2dee: ld      a,$fe] \  Load A with #FF>>(B-1) (note the first rotate right doesn't count towards the bit shift because the
	SET_XC_FLAGS                           	| [$2df0: scf]| carry flag is set)
l_2df1:
	roxr.b	#1,d0                           	| [$2df1: rra]|
 	                               	| [$2df2: and     a]| clear carry flag
	subq.b	#1,d1                           	| [...]
	jne	l_2df1                             	| [$2df3: djnz    $2df1] /

	move.b	d0,d1                           	| [$2df5: ld      b,a] \  The result of the above indicates the interval in frames between deploying successive fires.
	move.b	framecounter_601a,d0            	| [$2df6: ld      a,(framecounter_601a)]| On rivets we proceed every 256 frames for internal difficulty 1 and 2, 128 frames for internal difficulty
	and.b	d1,d0                            	| [$2df9: and     b]| 3 and 4 and 64 frames for internal difficulty 5. On conveyors these values are cut in half.
	beq.b	0f                               	| [...]
	rts                                    	| [$2dfa: ret     nz] / [...]
0:

	move.b	#0x01,d0                        	| [$2dfb: ld      a,$01] Time to deploy a fire. Load A with 1
	move.b	d0,unknown_63a0                 	| [$2dfd: ld      (unknown_63a0),a] deploy a firefox/fireball
	move.b	d0,deployment_indicator_639a    	| [$2e00: ld      (deployment_indicator_639a),a] set deployment indicator ?
	rts                                    	| [$2e03: ret] return

* called from main routine at #198F
* called during the elevators.  used to move the bouncers ????

update_bouncers_if_on_elevators_2e04:

	move.b	#0x04,d0                        	| [$2e04: ld      a,$04] A := 4 (0100 binary) to check for elevators screen
	jbsr	only_continues_if_given_level_0030                            	| [$2e06: rst     $30] if not elevators it will return to program

	jbsr	continue_only_if_mario_alive_0010                            	| [$2e07: rst     $10] if mario is alive, continue, else RET

	lea	start_of_bouncer_memory_area_6500,a2	| [$2e08: ld      ix,start_of_bouncer_memory_area_6500] load IX with start of bouncer memory area
	lea	start_of_bouncers_or_barrels_sprites_6980,a3	| [$2e0c: ld      iy,start_of_bouncers_or_barrels_sprites_6980] start of sprite memory for bouncers
	move.b	#NB_BARRELS,d1                        	| [$2e10: ld      b,$0a] for B = 1 to #0A (ten) .  do for all ten sprites

l_2e12:
	move.b	(a2),d0                    	| [$2e12: ld      a,(ix+$00)] load A with sprite status
	ror.b	#1,d0                            	| [$2e15: rrca] is the sprite active ?
	jcc	l_2ea7                             	| [$2e16: jp      nc,$2ea7] no, jump ahead and check to deploy a new one

	move.b	framecounter_601a,d0            	| [$2e19: ld      a,(framecounter_601a)] else load A with timer

* FrameCounter - Timer constantly counts down from FF to 00 and then FF to 00 again and again ... 1 count per frame
* result is that each of the boucners have their sprites changed once every 16 clicks, or every 1/16 of sec.?

	and.b	#0x0f,d0                         	| [$2e1c: and     $0f] mask out left 4 bits.  result between 0 and F
	jne	l_2e29                             	| [$2e1e: jp      nz,$2e29] if not zero, jump ahead..

	move.b	(0x01,a3),d0                    	| [$2e21: ld      a,(iy+$01)] load A with sprite value
	eor.b	#0x07,d0                         	| [$2e24: xor     $07] flip the right 3 bits
	move.b	d0,(0x01,a3)                    	| [$2e26: ld      (iy+$01),a] store result = change the bouncer fom open to closed

l_2e29:
	move.b	(0x0d,a2),d0                    	| [$2e29: ld      a,(ix+$0d)] load A with +D = either 1 or 4.  1 when going across , 4 when going down.
	cmp.b	#0x04,d0                         	| [$2e2c: cp      $04] is it == 4 ? (going down?)
	jeq	l_2e84                             	| [$2e2e: jp      z,$2e84] yes, jump ahead

	addq.b	#2,(0x03,a2)                    	| [$2e31: inc     (ix+$03)] no, increase X position * 2
	move.b	(0x0e,a2),d6                    	| [$2e37: ld      l,(ix+$0e)]
	move.b	(0x0f,a2),d5                    	| [$2e3a: ld      h,(ix+$0f)] load HL with table address for bouncer offsets of Y positions for each pixel across
	LOAD_D5_16_FROM_D5D6
	LOAD_ROM_ADDRESS_BE	d5,a0
	move.b	(a0),d0                         	| [$2e3d: ld      a,(hl)] load table data
	move.b	d0,d2                           	| [$2e3e: ld      c,a] copy to C
	cmp.b	#0x7f,d0                         	| [$2e3f: cp      $7f] == #7F ? (end code ?)
	jeq	l_2e9c                             	| [$2e41: jp      z,$2e9c] yes, jump ahead, reset HL to #39AA, play bouncer sound, and continue at #2E4B

	addq.w	#1,a0                           	| [$2e44: inc     hl] next HL
	add.b	(0x05,a2),d0                     	| [$2e45: add     a,(ix+$05)] add item's Y position
	move.b	d0,(0x05,a2)                    	| [$2e48: ld      (ix+$05),a] store into item's Y position

l_2e4b:
	STORE_ROM_ADDRESS_BE	a0,d5
	LOAD_D5D6_FROM_D5_16
	move.b	d6,(0x0e,a2)                    	| [$2e4b: ld      (ix+$0e),l]
	move.b	d5,(0x0f,a2)                    	| [$2e4e: ld      (ix+$0f),h] store the updated HL for next time
	move.b	(0x03,a2),d0                    	| [$2e51: ld      a,(ix+$03)] load A with X position
	cmp.b	#0xb7,d0                         	| [$2e54: cp      $b7] < #B7 ?
	jcs	l_2e6c                             	| [$2e56: jp      c,$2e6c] no, skip ahead

	move.b	d2,d0                           	| [$2e59: ld      a,c] yes, A := C
	cmp.b	#0x7f,d0                         	| [$2e5a: cp      $7f] == #7F (end code?)
	jne	l_2e6c                             	| [$2e5c: jp      nz,$2e6c] no, skip ahead

	move.b	#0x04,(0x0d,a2)                 	| [$2e5f: ld      (ix+$0d),$04] set +D to 4 (???)
	clr.b	d0                               	| [$2e63: xor     a] A := 0
								| [$2e64: ld      (play_sound_for_bouncer_6083),a] clear sound of bouncer
	move.w	#BOUNCER_FALLS_SND,d0
	jbsr	osd_sound_start
	*move.b	#0x03,d0                        	| [$2e67: ld      a,$03] load sound duration of 3
	*move.b	d0,play_sound_for_falling_bouncer_6084	| [$2e69: ld      (play_sound_for_falling_bouncer_6084),a] play sound for falling bouncer

l_2e6c:
	move.b	(0x03,a2),d0                    	| [$2e6c: ld      a,(ix+$03)] load A with X position
	move.b	d0,(a3)                    	| [$2e6f: ld      (iy+$00),a] store into sprite
	move.b	(0x05,a2),d0                    	| [$2e72: ld      a,(ix+$05)] load A with Y position
	move.b	d0,(0x03,a3)                    	| [$2e75: ld      (iy+$03),a] store into sprite

l_2e78:
													| [$2e78: ld      de,$0010] set offset to add 16
	add.w	#0x10,a2                            	| [$2e7b: add     ix,de] next sprite (IX)
													| [$2e7d: ld      e,$04] E := 4
	addq.w	#4,a3                       	     	| [$2e7f: add     iy,de] next sprite (IY)
	subq.b	#1,d1                       	    	| [...]
	jne	l_2e12                          		   	| [$2e81: djnz    $2e12] Next Bouncer

	rts                               		     	| [$2e83: ret] return

* arrive when bouncer is going straight down
* need to check when falling off bottom of screen

l_2e84:
	move.b	#0x03,d0                        	| [$2e84: ld      a,$03] A := 3
	add.b	(0x05,a2),d0                     	| [$2e86: add     a,(ix+$05)] add to Sprite's y position (move down 3)
	move.b	d0,(0x05,a2)                    	| [$2e89: ld      (ix+$05),a] store result
	cmp.b	#0xf8,d0                         	| [$2e8c: cp      $f8] are we at the bottom of screen?
	jcs	l_2e6c                             	| [$2e8e: jp      c,$2e6c] No, jump back to program

	clr.b	(0x03,a2)                        	| [$2e91: ld      (ix+$03),$00] yes, reset the sprite
	clr.b	(a2)                        	| [$2e95: ld      (ix+$00),$00] reset
	jra	l_2e6c                             	| [$2e99: jp      $2e6c] jump back to program

* arrive from #2E41

l_2e9c:
	lea	game_rom+0x39aa,a0                      	| [$2e9c: ld      hl,$39aa] load HL with start of table data
	*move.b	#0x03,d0                        	| [$2e9f: ld      a,$03] load sound duration of 3
	move.w	#BOUNCER_BOUNCES_SND,D0
	jbsr	osd_sound_start  	| [$2ea1: ld      (play_sound_for_bouncer_6083),a] play sound for bouncer
	jra	l_2e4b                             	| [$2ea4: jp      $2e4b] jump back

* jump here from #2E16

l_2ea7:
	move.b	bouncer_release_6396,d0         	| [$2ea7: ld      a,(bouncer_release_6396)] load A with bouncer release flag
	ror.b	#1,d0                            	| [$2eaa: rrca] time to deploy a bouncer?
	jcc	l_2e78                             	| [$2eab: jp      nc,$2e78] no, jump back

* deploy new bouncer

	clr.b	d0                               	| [$2eae: xor     a] A := 0
	move.b	d0,bouncer_release_6396         	| [$2eaf: ld      (bouncer_release_6396),a] reset bouncer release flag
	move.b	#0x50,(0x05,a2)                 	| [$2eb2: ld      (ix+$05),$50] set bouncer's Y position to #50
	move.b	#0x01,(0x0d,a2)                 	| [$2eb6: ld      (ix+$0d),$01] set value to sprite bouncing across, not down
	jbsr	random_0057                            	| [$2eba: call    $0057] load A with random number
	and.b	#0x0f,d0                         	| [$2ebd: and     $0f] mask bits, result is between 0 and #F
	add.b	#0xf8,d0                         	| [$2ebf: add     a,$f8] add #F8 = result is now between #F8 and #07
	move.b	d0,(0x03,a2)                    	| [$2ec1: ld      (ix+$03),a] store A into initial X position for bouncer sprite
	move.b	#0x01,(a2)                 	| [$2ec4: ld      (ix+$00),$01] set sprite as active
	lea	game_rom+0x39aa,a0                      	| [$2ec8: ld      hl,$39aa] values #39 and #AA to be inserted below.  #39AA is the start of table data for Y offsets to add for each movement
	
	move.b	#0xAA,(0x0e,a2)                    	| [$2ecb: ld      (ix+$0e),l]
	move.b	#0x39,(0x0f,a2)                    	| [$2ece: ld      (ix+$0f),h] store HL into +E and +F
	jra	l_2e78                             	| [$2ed1: jp      $2e78] jump back

* arrive from main routine at #1998
* checks for hammer grabs etc ?

handle_hammer_2ed4:
	move.b	#0x0b,d0                        	| [$2ed4: ld      a,$0b] B = # 1011 binary
	jbsr	only_continues_if_given_level_0030                            	| [$2ed6: rst     $30] continue here on girders, conveyors, rivets only.  elevators RET from this sub, it has no hammers.
	jbsr	continue_only_if_mario_alive_0010                            	| [$2ed7: rst     $10] continue here only if mario is alive, otherwise RET from this sub

	lea	hardware_address_of_hammer_sprite_6a18,a1	| [$2ed8: ld      de,hardware_address_of_hammer_sprite_6a18] load DE with hardware address of hammer sprite
	lea	software_address_of_hammer_sprite_6680,a2	| [$2edb: ld      ix,software_address_of_hammer_sprite_6680] load IX with software address of hammer sprite
	move.b	(0x01,a2),d0                    	| [$2edf: ld      a,(ix+$01)] load A with 1st hammer active indicator
	ror.b	#1,d0                            	| [$2ee2: rrca] rotate right.  carry set?  (is this hammer active?)
	jcs	l_2eed                             	| [$2ee3: jp      c,$2eed] yes, skip next 2 steps

	lea	hardware_address_of_2nd_hammer_sprite_6a1c,a1	| [$2ee6: ld      de,hardware_address_of_2nd_hammer_sprite_6a1c] else load DE with hardware address of 2nd hammer sprite
	lea	second_hammer_sprite_6690,a2   	| [$2ee9: ld      ix,second_hammer_sprite_6690] load IX with 2nd hammer sprite

l_2eed:
	clr.b	(0x0e,a2)                        	| [$2eed: ld      (ix+$0e),$00] store 0 into +#E == ???
	move.b	#0xf0,(0x0f,a2)                 	| [$2ef1: ld      (ix+$0f),$f0] store #F0 into +#F (???)
	move.b	hammer_active_6217,d0                 	| [$2ef5: ld      a,(hammer_active_6217)] load A with hammer indicator
	ror.b	#1,d0                            	| [$2ef8: rrca] is the hammer already active?
	jcc	l_2f97                             	| [$2ef9: jp      nc,$2f97] no, skip ahead and check for new hammer grab

	                               	| [$2efc: xor     a] A := 0
	clr.b	mario_is_grabbing_the_hammer_until_he_lands_6218	| [$2efd: ld      (mario_is_grabbing_the_hammer_until_he_lands_6218),a] store into grabbing the hammer indicator. the grab is complete.
	lea	background_music_value_6089,a0 	| [$2f00: ld      hl,background_music_value_6089] load HL with music address
	move.b	#MUS_HAMMER,d0
	move.b	d0,(a0)                      	| [$2f03: ld      (hl),$04] set music for hammer
	jbsr	osd_sound_start
	move.b	#0x06,(0x09,a2)                 	| [$2f05: ld      (ix+$09),$06] set width ?
	move.b	#0x03,(0x0a,a2)                 	| [$2f09: ld      (ix+$0a),$03] set height ?
	move.b	#0x1e,d1                        	| [$2f0d: ld      b,$1e] B := #1E
	move.b	mario_movement_indicator_sprite_value_6207,d0	| [$2f0f: ld      a,(mario_movement_indicator_sprite_value_6207)] load A with mario movement indicator/sprite value
	asl.b	#1,d0                            	| [$2f12: sla     a] shift left.  is bit 7 on?
	jcc	l_2f1b                             	| [$2f14: jp      nc,$2f1b] no, skip next 2 steps

	or.b	#0x80,d0                          	| [$2f17: or      $80] turn on bit 7 in A
	bset.b	#7,d1                           	| [$2f19: set     7,b] turn on bit 7 in B

l_2f1b:
	or.b	#0x08,d0                          	| [$2f1b: or      $08] turn on bit 3 in A
	move.b	d0,d2                           	| [$2f1d: ld      c,a] copy to C
	move.b	hammer_timer_6394,d0            	| [$2f1e: ld      a,(hammer_timer_6394)] load A with hammer timer
	btst.b	#3,d0                           	| [$2f21: bit     3,a] is bit 3 on in A?
	jeq	l_2f43                             	| [$2f23: jp      z,$2f43] no, skip ahead

* animate the hammer

	bset.b	#0,d1                           	| [$2f26: set     0,b]
	bset.b	#0,d2                           	| [$2f28: set     0,c]
	move.b	#0x05,(0x09,a2)                 	| [$2f2a: ld      (ix+$09),$05] set width?
	move.b	#0x06,(0x0a,a2)                 	| [$2f2e: ld      (ix+$0a),$06] set height?
	clr.b	(0x0f,a2)                        	| [$2f32: ld      (ix+$0f),$00]
	move.b	#0xf0,(0x0e,a2)                 	| [$2f36: ld      (ix+$0e),$f0] set offset for left side of mario (#F0 == -#10)
	btst.b	#7,d2                           	| [$2f3a: bit     7,c] is mario facing left?
	jeq	l_2f43                             	| [$2f3c: jp      z,$2f43] yes, skip next step

	move.b	#0x10,(0x0e,a2)                 	| [$2f3f: ld      (ix+$0e),$10] set offset for right side of mario

l_2f43:
	move.b	d2,d0                           	| [$2f43: ld      a,c] A := C
	move.b	d0,mario_sprite_value_694d      	| [$2f44: ld      (mario_sprite_value_694d),a] store into mario sprite value
	move.b	#0x07,d2                        	| [$2f47: ld      c,$07] C := 7
	lea	hammer_timer_6394,a0           	| [$2f49: ld      hl,hammer_timer_6394] load HL with hammer timer
	addq.b	#1,(a0)                         	| [$2f4c: inc     (hl)] increase.  at zero?
	jne	l_2fb7                             	| [$2f4d: jp      nz,$2fb7] no skip ahead

* hammer is changing or ending

	lea	hammer_length_6395,a0          	| [$2f50: ld      hl,hammer_length_6395] load HL with hammer length.
	addq.b	#1,(a0)                         	| [$2f53: inc     (hl)] increase
	move.b	(a0),d0                         	| [$2f54: ld      a,(hl)] get the value
	cmp.b	#0x02,d0                         	| [$2f55: cp      $02] is the hammer all used up?
	jne	l_2fbe                             	| [$2f57: jp      nz,$2fbe] no, skip ahead and change its color every 8 frames

* arrive here when hammer runs out

	                               	| [$2f5a: xor     a] A := 0
	clr.b	hammer_length_6395           	| [$2f5b: ld      (hammer_length_6395),a] clear hammer length
	clr.b	hammer_active_6217                 	| [$2f5e: ld      (hammer_active_6217),a] store into hammer indicator
	clr.b	(0x01,a2)                    	| [$2f61: ld      (ix+$01),a] clear hammer active indicator
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2f64: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	neg.b	d0                               	| [$2f67: neg] take negative
	move.b	d0,(0x0e,a2)                    	| [$2f69: ld      (ix+$0e),a] store into +E
	move.b	mario_movement_indicator_sprite_value_6207,d0	| [$2f6c: ld      a,(mario_movement_indicator_sprite_value_6207)] load A with mario movement indicator/sprite value
	move.b	d0,mario_sprite_value_694d      	| [$2f6f: ld      (mario_sprite_value_694d),a] store into mario sprite value
	clr.b	(a2)                        	| [$2f72: ld      (ix+$00),$00] clear hammer active bit
	move.b	restored_when_hammer_runs_out_6389,d0	| [$2f76: ld      a,(restored_when_hammer_runs_out_6389)] load A with previous background music
	move.b	d0,background_music_value_6089  	| [$2f79: ld      (background_music_value_6089),a] set music with what it was before the hammer was grabbed
	jbsr	osd_sound_start

*

l_2f7c:
	exg	a1,a0                              	| [$2f7c: ex      de,hl] DE <> HL
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$2f7d: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] load A with mario's X position
	add.b	(0x0e,a2),d0                     	| [$2f80: add     a,(ix+$0e)] add hammer offset
	move.b	d0,(a0)                         	| [$2f83: ld      (hl),a] store into Hammer X position
	move.b	d0,(0x03,a2)                    	| [$2f84: ld      (ix+$03),a] store into hammer X position
	addq.w	#1,a0                           	| [$2f87: inc     hl] next
	move.b	d1,(a0)                         	| [$2f88: ld      (hl),b] store sprite graphic value
	addq.w	#1,a0                           	| [$2f89: inc     hl] next
	move.b	d2,(a0)                         	| [$2f8a: ld      (hl),c] store into hammer color
	addq.w	#1,a0                           	| [$2f8b: inc     hl] next
	move.b	mario_y_position_6205,d0	| [$2f8c: ld      a,(mario_y_position_6205)] load A with mario's Y position
	add.b	(0x0f,a2),d0                     	| [$2f8f: add     a,(ix+$0f)] add hammer offset
	move.b	d0,(a0)                         	| [$2f92: ld      (hl),a] store into hammer Y position
	move.b	d0,(0x05,a2)                    	| [$2f93: ld      (ix+$05),a] store into hammer Y position
	rts                                    	| [$2f96: ret] return

* arrive from #2EF9, check for grabbing hammer ?

l_2f97:
	move.b	mario_is_grabbing_the_hammer_until_he_lands_6218,d0	| [$2f97: ld      a,(mario_is_grabbing_the_hammer_until_he_lands_6218)] load A with 0, turns to 1 while mario is grabbing the hammer until he lands
	ror.b	#1,d0                            	| [$2f9a: rrca] is mario grabbing the hammer?
	bcs.b	0f                               	| [...]
	rts                                    	| [$2f9b: ret     nc] no, return [...]
0:

* arrive here when hammer is grabbed

	move.b	#0x06,(0x09,a2)                 	| [$2f9c: ld      (ix+$09),$06] set width ?
	move.b	#0x03,(0x0a,a2)                 	| [$2fa0: ld      (ix+$0a),$03] set height ?
	move.b	mario_movement_indicator_sprite_value_6207,d0	| [$2fa4: ld      a,(mario_movement_indicator_sprite_value_6207)] load A with mario movement indicator/sprite value
	CLEAR_XC_FLAGS
	roxl.b	#1,d0                            	| [$2fa7: rlca] rotate left the high bit into carry flag
	move.b	#0x3c,d0                        	| [$2fa8: ld      a,$3c] A := #3C
	roxr.b	#1,d0                           	| [$2faa: rra] rotate right the carry bit back in
	move.b	d0,d1                           	| [$2fab: ld      b,a] copy to B
	move.b	#0x07,d2                        	| [$2fac: ld      c,$07] C := 7
	move.b	background_music_value_6089,d0  	| [$2fae: ld      a,(background_music_value_6089)] load A with background music value
	move.b	d0,restored_when_hammer_runs_out_6389	| [$2fb1: ld      (restored_when_hammer_runs_out_6389),a] save so it can be restored when hammer runs out.  see #2F76
	jra	l_2f7c                             	| [$2fb4: jp      $2f7c] return to program

* arrive from #2F4D

l_2fb7:
	move.b	hammer_length_6395,d0           	| [$2fb7: ld      a,(hammer_length_6395)] load A with hammer length
	                               	| [$2fba: and     a] == 0 ?  (full strength)
	jeq	l_2f7c                             	| [$2fbb: jp      z,$2f7c] yes, jump back now

* change hammer color ?
* hammer is half strength

l_2fbe:
	move.b	framecounter_601a,d0            	| [$2fbe: ld      a,(framecounter_601a)] load A with this clock counts down from #FF to 00 over and over...
	btst.b	#3,d0                           	| [$2fc1: bit     3,a] check bit 3 (?).  zero ?  will do this every 8 frames
	jeq	l_2f7c                             	| [$2fc3: jp      z,$2f7c] yes, jump back now

	move.b	#0x01,d2                        	| [$2fc6: ld      c,$01] else C := 1 to change hammer color
	jra	l_2f7c                             	| [$2fc8: jp      $2f7c] jump back

* arrive here from main routine #19BF
* this is the last subroutine from there
* for non-girder levels, this sub
* checks for bonus timer changes
* if the bonus counts down, it also
* sets a possible new fire to be released
* sets a bouncer to be deployed
* updates the bonus timer onscreen
* checks for bonus time running out

l_2fcb:
	move.b	#0x0e,d0                        	| [$2fcb: ld      a,$0e] A := #E = 1110 binary
	jbsr	only_continues_if_given_level_0030                            	| [$2fcd: rst     $30] is this the girders?  if so, return immediately

	lea	timer_62b4,a0                  	| [$2fce: ld      hl,timer_62b4] else load HL with timer
	subq.b	#1,(a0)                         	| [$2fd1: dec     (hl)] count down timer.  at zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$2fd2: ret     nz] no, return [...]
0:

	move.b	#0x03,d0                        	| [$2fd3: ld      a,$03] else A := 3
	move.b	d0,fire_release_62b9            	| [$2fd5: ld      (fire_release_62b9),a] store into fire release - a new fire can be released
	move.b	d0,bouncer_release_6396         	| [$2fd8: ld      (bouncer_release_6396),a] store into bouncer release - a new bouncer can be deployed
	move.w	#0x0501,d3                      	| [$2fdb: ld      de,$0501] load task #5, parameter #1 = update onscreen bonus timer and play sound & change to red if below 1000
	jbsr	insert_task_309f                            	| [$2fde: call    $309f] insert task
	move.b	intial_timer_value_62b3,d0      	| [$2fe1: ld      a,(intial_timer_value_62b3)] load A with intial timer value.
	move.b	d0,(a0)                         	| [$2fe4: ld      (hl),a] reset the timer
	lea	bonus_timer_62b1,a0            	| [$2fe5: ld      hl,bonus_timer_62b1] load HL with bonus timer
	subq.b	#1,(a0)                         	| [$2fe8: dec     (hl)] Decrement.  is the bonus timer zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$2fe9: ret     nz] no, return [...]
0:

	move.b	#0x01,d0                        	| [$2fea: ld      a,$01] else time has run out.  A := 1
	move.b	d0,time_has_run_out_indicator_6386	| [$2fec: ld      (time_has_run_out_indicator_6386),a] set time has run out indicator
	rts                                    	| [$2fef: ret] return

* called during a barrel roll
* D5/D6 contains the X and Y position of the barrel.  Y has been inflated by 4
* called from #2A3A
* called from #2AA2 with HL preloaded with mario's position offset a bit
* returns with D7 modified in some special way
*

convert_hl_into_vram_address_2ff0:
	move.b	d6,d0                           	| [$2ff0: ld      a,l] load A with Y position (inflated by 4)
	CLEAR_XC_FLAGS
	ror.b	#3,d0                            	| [$2ff1: rrca] Roll right 3 times (divide Y by 8)
	and.b	#0x1f,d0                         	| [$2ff4: and     $1f] mask out left 3 bits to zero (number has been divided by 8)
	move.b	d0,d6                           	| [$2ff6: ld      l,a] Load L with this new position
	move.b	d5,d0                           	| [$2ff7: ld      a,h] load A with barrel's X position
	not.b	d0                               	| [$2ff8: cpl] A is inverted (1's complement)
	and.b	#0xf8,d0                         	| [$2ff9: and     $f8] Mask out right 3 bits to zero
	move.b	d0,d4                           	| [$2ffb: ld      e,a] load E with result
	clr.b	d0                               	| [$2ffc: xor     a] A := 0
	move.b	d0,d5                           	| [$2ffd: ld      h,a] H := 0
	roxl.b	#1,d4                           	| [$2ffe: rl      e] rotate E left
	roxl.b	#1,d0                           	| [$3000: rla] Rotate A left [does nothing?  A is 0] clears carry!
	roxl.b	#1,d4                           	| [$3001: rl      e] rotate E left again
	roxl.b	#1,d0                           	| [$3003: rla] rotate A left again ?
	add.b	#0x74,d0                         	| [$3004: add     a,$74] Add #74 to A.   A = #74 now ?
	move.b	d0,d3                           	| [$3006: ld      d,a] Store this in D
	LOAD_D3_16_FROM_D3D4
	LOAD_D5_16_FROM_D5D6
	add.w	d3,d5                            	| [$3007: add     hl,de] Add DE into HL
	move.w	d5,d7
	.ifndef	RELEASE
	* check if in range
	move.w	d0,-(a7)
	jbsr	osd_r_videoram
	move.b	d0,d0
	move.w	(a7)+,d0
	.endif
	rts                                    	| [$3008: ret] return


*
* called here in the middle of a barrel being rolled left or right...
* or when mario is moving
* called from four locations
* A is preloaded with ?
*

l_3009:
	move.b	d0,d3                           	| [$3009: ld      d,a] D := A
	ror.b	#1,d0                            	| [$300a: rrca] roll right.  is A odd?
	jcs	l_3022                             	| [$300b: jp      c,$3022] yes, skip ahead

* A is even

	move.b	#0x93,d2                        	| [$300e: ld      c,$93] C := #93
	ror.b	#2,d0                            	| [$3010: rrca] * 2
	jcc	l_3017                             	| [$3012: jp      nc,$3017] no carry, skip next step

	move.b	#0x6c,d2                        	| [$3015: ld      c,$6c] C := #6C

l_3017:
	rol.b	#1,d0                            	| [$3017: rlca] roll left
	jcs	l_3031                             	| [$3018: jp      c,$3031] if carry, skip ahead

	move.b	d2,d0                           	| [$301b: ld      a,c] A := C
	and.b	#0xf0,d0                         	| [$301c: and     $f0] mask bits, 4 lowest bits set to zero
	move.b	d0,d2                           	| [$301e: ld      c,a] store back into C
	jra	l_3031                             	| [$301f: jp      $3031] skip ahead

* arrive from #300B when A is odd

l_3022:
	move.b	#0xb4,d2                        	| [$3022: ld      c,$b4] C := #B4
	ror.b	#2,d0                            	| [$3024: rrca] * 2
	jcc	l_302b                             	| [$3026: jp      nc,$302b] no, skip next step

	move.b	#0x1e,d2                        	| [$3029: ld      c,$1e] C := #1E

l_302b:
	btst.b	#2,d1                           	| [$302b: bit     2,b] is bit 2 on B at zero?
	jeq	l_3031                             	| [$302d: jp      z,$3031] yes, skip next step

	subq.b	#1,d1                           	| [$3030: dec     b] else decrease B

l_3031:
	move.b	d2,d0                           	| [$3031: ld      a,c] A := C
	ror.b	#2,d0                            	| [$3032: rrca] * 2
	move.b	d0,d2                           	| [$3034: ld      c,a] C := A
	and.b	#0x03,d0                         	| [$3035: and     $03] mask bits, now between 0 and 3
	cmp.b	d1,d0                            	| [$3037: cp      b] == B ?
	jne	l_3031                             	| [$3038: jp      nz,$3031] no, loop again

	move.b	d2,d0                           	| [$303b: ld      a,c] A := C
	ror.b	#2,d0                            	| [$303c: rrca] * 2
	and.b	#0x03,d0                         	| [$303e: and     $03] mask bits, now between 0 and 3
	cmp.b	#0x03,d0                         	| [$3040: cp      $03] == 3 ?
	beq.b	0f                               	| [...]
	rts                                    	| [$3042: ret     nz] no, return [...]
0:

	bclr.b	#2,d3                           	| [$3043: res     2,d] clear bit 2 of D (copy of original input A)
	subq.b	#1,d3                           	| [$3045: dec     d] decrease.  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$3046: ret     nz] no, return [...]
0:

	move.b	#0x04,d0                        	| [$3047: ld      a,$04] else A := 4
	rts                                    	| [$3049: ret] return

* called from #0AF0 and #0B38
* rolls up kong's ladder during intro

l_304a:
	move.w	#-0x20,d3                      	| [$304a: ld      de,$ffe0] load DE with offset
	move.b	kong_ladder_climb_counter_638e,d0	| [$304d: ld      a,(kong_ladder_climb_counter_638e)] load A with kong ladder climb counter
	clr.w	d1                               	| [$3051: ld      b,$00] B := 0
	move.b	d0,d1                           	| [$3050: ld      c,a] copy to C
	move.w	#0x7600,d7                      	| [$3053: ld      hl,$7600] load HL with screen RAM address
	jbsr	l_3064                            	| [$3056: call    $3064] roll up left ladder
	move.w	#0x75c0,d7                      	| [$3059: ld      hl,$75c0] load HL with screen RAM address
	jbsr	l_3064                            	| [$305c: call    $3064] roll up right ladder
	lea	kong_ladder_climb_counter_638e,a0	| [$305f: ld      hl,kong_ladder_climb_counter_638e] load HL with kong ladder climb counter
	subq.b	#1,(a0)                         	| [$3062: dec     (hl)] decrease
	rts                                    	| [$3063: ret] return

* called from #3056 and #305C above

l_3064:
	add.w	d1,d7                            	| [$3064: add     hl,bc] add offset based on how far up kong is
	jbsr	osd_r_videoram                         	| [$3065: ld      a,(hl)] get value from screen
	add.w	d3,d7                            	| [$3066: add     hl,de] add offset
	jbsr	osd_w_videoram                         	| [$3067: ld      (hl),a] store value to screen
	rts                                    	| [$3068: ret] return

* arrive from #0A79 when intro screen indicator == 3 or 5

l_3069:
	jbsr	rst_18                            	| [$3069: rst     $18] count down timer and only continue here if zero, else RET
	LOAD_RAM_ADDRESS_LE	timer_unknown_63c0,a0       	| [$306a: ld      hl,(timer_unknown_63c0)] load HL with timer ???
	addq.b	#1,(a0)                         	| [$306d: inc     (hl)] increase
	rts                                    	| [$306e: ret] return

* called from 3 locations

kong_climbing_ladder_with_girl_306f:
	lea	kong_misc_counter_62af,a0  	| [$306f: ld      hl,kong_misc_counter_62af] load HL with kong climbing counter
	addq.b	#1,(a0)                         	| [$3072: inc     (hl)] increase
	move.b	(a0),d0                         	| [$3073: ld      a,(hl)] load A with the counter
	and.b	#0x07,d0                         	| [$3074: and     $07] mask bits.  now between 0 and 7.  zero?
	beq.b	0f                               	| [...]
	rts                                    	| [$3076: ret     nz] no, return [...]
0:

* animate kong climbing up the ladder

	lea	kong_sprite_array_690b,a0      	| [$3077: ld      hl,kong_sprite_array_690b] load HL with kong sprite array
	move.b	#0xfc,d2                        	| [$307a: ld      c,$fc] C := -4
	jbsr	rst_38                            	| [$307c: rst     $38] move kong
	move.b	#0x81,d2                        	| [$307d: ld      c,$81] C := #81
	lea	kongs_right_leg_address_sprite_6909,a0	| [$307f: ld      hl,kongs_right_leg_address_sprite_6909] load HL with kong's right leg address sprite
	jbsr	l_3096                            	| [$3082: call    $3096] animate kong sprite
	lea	kongs_right_arm_address_sprite_691d,a0	| [$3085: ld      hl,kongs_right_arm_address_sprite_691d] load HL with kong's right arm address sprite
	jbsr	l_3096                            	| [$3088: call    $3096] animate kong sprite
	jbsr	random_0057                            	| [$308b: call    $0057] load A with random number
	and.b	#0x80,d0                         	| [$308e: and     $80] mask bits, now either 0 or #80: flip girl or not
	lea	sprite_of_girl_under_kongs_arms_692d,a0	| [$3090: ld      hl,sprite_of_girl_under_kongs_arms_692d] load HL with sprite of girl under kong's arms
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$3093: xor     (hl)] toggle the sprite
	move.b	d0,(a0)                         	| [$3094: ld      (hl),a] store result - toggles the girl to make her wiggle randomly
	rts                                    	| [$3095: ret] return

* called from #3082 and #3088 above

l_3096:
	move.b	#0x02,d1                        	| [$3096: ld      b,$02] For B = 1 to 2

l_3098:
	* here d3 = 4 (when debugging) so seems OK
	move.b	d2,d0                           	| [$3098: ld      a,c] A := C
	move.b	(a0),d7
	eor.b	d7,d0                            	| [$3099: xor     (hl)] toggle with the bits in this memory location
	move.b	d0,(a0)                         	| [$309a: ld      (hl),a] store A into this location
	add.w	d3,a0                            	| [$309b: add     hl,de] add offset for next location
	subq.b	#1,d1                           	| [...]
	jne	l_3098                             	| [$309c: djnz    $3098] Next B

	rts                                    	| [$309e: ret] return

* insert task
* DE are loaded with task # and parameter
* tasks are decoded at #02E3
* tasks are pushed into #60C0 through #60FF

insert_task_309f:
	movem.w	d3/d4,-(sp)
	LOAD_D3D4_FROM_D3_16
	move.l	a0,-(sp)                        	| [$309f: push    hl] save HL
	* jotd once again we emulate H/L, start address is known this is quite easy
	lea	start_of_task_list_60c0-0xC0,a0     	| [$30a0: ld      hl,start_of_task_list_60c0] load HL with start of task list [why?  L is set later, only H needs to be loaded here]
	moveq	#0,d7
	move.b	task_list_pointer_60b0,d0       	| [$30a3: ld      a,(task_list_pointer_60b0)] load A with task pointer
	move.b	d0,d7                           	| [$30a6: ld      l,a] HL now has task pointer full address
	add.w	d7,a0
	btst.b	#7,(a0)                         	| [$30a7: bit     7,(hl)] test high bit 7 of the task at this address.  zero?
	jeq	l_30bb                             	| [$30a9: jp      z,$30bb] yes, skip ahead, restore HL and return. [when would this happen??? if task list is full???]

	move.b	d3,(a0)+                         	| [$30ac: ld      (hl),d] else store task number into task list
	addq.b	#1,d7                           	| [$30ad: inc     l] next HL
	move.b	d4,(a0)+                       	| [$30ae: ld      (hl),e] store task parameter
	addq.b	#1,d7                       	| [$30af: inc     l] next HL
	move.b	d7,d0                           	| [$30b0: ld      a,l] load A with low byte of task pointer
	cmp.b	#0xc0,d0                         	| [$30b1: cp      $c0] is A > #C0 ? (did the task list roll over?)
	jcc	l_30b8                             	| [$30b3: jp      nc,$30b8] no, skip next instruction

	move.b	#0xc0,d0                        	| [$30b6: ld      a,$c0] yes, reset A to #C0 for start of task list

l_30b8:
	move.b	d0,task_list_pointer_60b0       	| [$30b8: ld      (task_list_pointer_60b0),a] store A into task list pointer

l_30bb:
	move.l	(sp)+,a0                        	| [$30bb: pop     hl] restore HL
	movem.w	(sp)+,d3/d4
	rts                                    	| [$30bc: ret] return to program

* arrive here from #1615 when rivets cleared
* clears all sprites for firefoxes, hammers and bonus items

l_30bd:
	lea	start_of_hammers_6950,a0       	| [$30bd: ld      hl,start_of_hammers_6950] load HL with start of hammers
	move.b	#0x02,d1                        	| [$30c0: ld      b,$02] B := 2
	jbsr	l_30e4                            	| [$30c2: call    $30e4] clear hammers ?
	lea	start_of_hammers_6950+0x30,a0                        	| [$30c5: ld      l,$80] L := #80
	move.b	#0x0a,d1                        	| [$30c7: ld      b,$0a] B := #A
	jbsr	l_30e4                            	| [$30c9: call    $30e4] clear barrels ?
	lea	start_of_hammers_6950+0xB8-0x50,a0                        	| [$30cc: ld      l,$b8] L := #B8
	move.b	#0x0b,d1                        	| [$30ce: ld      b,$0b] B := #B
	jbsr	l_30e4                            	| [$30d0: call    $30e4] clear firefoxes ?
	lea	start_of_bonus_items_6a0c,a0   	| [$30d3: ld      hl,start_of_bonus_items_6a0c] load HL with start of bonus items
	move.b	#0x05,d1                        	| [$30d6: ld      b,$05] B := 5
	jra	l_30e4                             	| [$30d8: jp      $30e4] clear bonus items

* called from #12DF
* clears mario and elevators from the screen

l_30db:
	lea	mario_sprite_x_position_694c,a0	| [$30db: ld      hl,mario_sprite_x_position_694c] load address for mario sprite X position
	clr.b	(a0)                             	| [$30de: ld      (hl),$00] clear this memory = move mario off screen
	lea		elevator_sprites_6958,a0          	| [$30e0: ld      l,$58] HL := #6958 = elevator sprite start
	move.b	#0x06,d1                        	| [$30e2: ld      b,$06] for B = 1 to 6

l_30e4:
	                           	| [$30e4: ld      a,l] load A with low byte addr

l_30e5:
	clr.b	(a0)                             	| [$30e5: ld      (hl),$00] clear this sprite position to zero = move off screen
	addq.w	#0x04,a0                        	| [$30e7: add     a,$04] add 4 for next sprite
	                           	| [$30e9: ld      l,a] store into HL
	subq.b	#1,d1                           	| [...]
	jne	l_30e5                             	| [$30ea: djnz    $30e5] next B

	rts                                    	| [$30ec: ret] return

* called from main routine at #198C

l_30ed:
	jbsr	l_30fa                            	| [$30ed: call    $30fa] Check internal difficulty and timers and return here based on difficulty a percentage of the time
	jbsr	l_313c                            	| [$30f0: call    $313c] Deploy fire if fire deployment flag is set
	jbsr	l_31b1                            	| [$30f3: call    $31b1] Process all movement for all fireballs
	jbsr	l_34f3                            	| [$30f6: call    $34f3] update all fires and firefoxes
	rts                                    	| [$30f9: ret] return

* This routine is used to adjust the fireball speed based on the internal difficulty. It works by forcing the entire fireball movement routine to
* be skipped on certain frames, returning directly back to the main routine in such cases. The higher the internal difficlty, the less often it
* short-circuits back to the main routine, the faster they will move.
* called from #30ED ABOVE

l_30fa:
	move.b	difficulty_level_6380,d0                 	| [$30fa: ld      a,(difficulty_level_6380)] \  Jump if internal difficulty is less than 6 (Is it possible to not jump here?)
	cmp.b	#0x06,d0                         	| [$30fd: cp      $06]|
	jcs	l_3103                             	| [$30ff: jr      c,$3103] /

	move.b	#0x05,d0                        	| [$3101: ld      a,$05] load A with 5 = max internal difficulty
l_3103:
	jbsr	rst_28                            	| [$3103: rst     $28] jump to address based on internal difficulty

	.long	l_3110  | 0       | #3110
	.long	l_3110  | 1       | #3110
	.long	l_311b  | 2       | #311B
	.long	l_3126  | 3       | #3126
	.long	l_3126  | 4       | #3126
	.long	l_3131  | 5       | #3131

* internal difficulty == 0 or 1. In this case, the fireball movement routine is only executed every other frame, so that fireballs move slowly.

l_3110:
	move.b	framecounter_601a,d0 				| LD      A,(FrameCounter)       | load A with this clock counts down from #FF to,0x00 over and over...
	move.b	d1,d5                           	| [$3112: ld      h,b] load H with B == ??? from previous subroutine ???? [what is this doing here ?]
	and.b	#0x01,d0                         	| [$3113: and     $01] \  If lowest bit of timer is 0 Return and continue as normal
	cmp.b	#0x01,d0                         	| [$3115: cp      $01]|
	bne.b	0f                               	| [...]
	rts                                    	| [$3117: ret     z] / [...]
0:

	addq.w	#4,sp                           	| [$3118: inc     sp] \  Else return to #198F instead of #30F0, skipping fireball movement routine * 2
	rts                                    	| [$311a: ret] /

* internal difficulty == 2. Here the fireball movement routine is executed for 5 consecutive frames out of every 8 frames.

l_311b:
	move.b	framecounter_601a,d0            	| [$311b: ld      a,(framecounter_601a)] \  If the lowest 3 bits of timer are less than 5 (equal to 0, 1, 2, 3, or 4) then return and continue as
	and.b	#0x07,d0                         	| [$311e: and     $07]| normal
	cmp.b	#0x05,d0                         	| [$3120: cp      $05]|
	bpl.b	0f                               	| [...]
	rts                                    	| [$3122: ret     m] / [...]
0:

	addq.w	#4,sp                           	| [$3123: inc     sp] \  Else return to #198F instead of #30F0, skipping fireball movement routine * 2
	rts                                    	| [$3125: ret] /

* difficulty == 3 or 4. Here the fireball movement routine is executed for 3 out of every 4 frames.

l_3126:
	move.b	framecounter_601a,d0            	| [$3126: ld      a,(framecounter_601a)] \  If the lowest 2 bits of the timer are not 11 then return and continue as normal
	and.b	#0x03,d0                         	| [$3129: and     $03]|
	cmp.b	#0x03,d0                         	| [$312b: cp      $03]|
	bpl.b	0f                               	| [...]
	rts                                    	| [$312d: ret     m] / [...]
0:

	addq.w	#4,sp                           	| [$312e: inc     sp] \  Else return to #198F instead of #30F0, skipping fireball movement routine * 2
	rts                                    	| [$3130: ret] /

* difficulty == 5. Here the fireball movement routine is executed for 7 out of every 8 frames.

l_3131:
	move.b	framecounter_601a,d0            	| [$3131: ld      a,(framecounter_601a)] \  If the lowest 3 bits of the timer are not 111 then return and continue as normal
	and.b	#0x07,d0                         	| [$3134: and     $07]|
	cmp.b	#0x07,d0                         	| [$3136: cp      $07]|
	bpl.b	0f                               	| [...]
	rts                                    	| [$3138: ret     m] / [...]
0:

	addq.w	#4,sp                           	| [$3139: inc     sp] \  Else return to #198F instead of #30F0, skipping fireball movement routine * 2
	rts                                    	| [$313b: ret] /

* This routine checks the fire deployment flag and deploys the actual fireball if it is set (as long as there is a free slot). It also keeps an
* updated count of the number of fireballs on screen and sets the color of fireballs based on the hammer status.
* called from #30F0

l_313c:
	lea	start_of_fires_table_6400,a2   	| [$313c: ld      ix,start_of_fires_table_6400] load IX with start of fire address
	clr.b	d0                               	| [$3140: xor     a] \ Reset # of fires onscreen to 0, this routine will count them.
	move.b	d0,unknown_63a1                 	| [$3141: ld      (unknown_63a1),a] /
	move.b	#NB_FIRES,d1                        	| [$3144: ld      b,$05] For B = 1 to 5 firefoxes
	move.w	#0x0020,d3                      	| [$3146: ld      de,$0020] load DE with offset to add for next firefox 32

l_3149:
	move.b	(a2),d0                    	| [$3149: ld      a,(ix+$00)] \  Jump if sprite slot is unused to maybe deploy a fire there.
	                               	| [$314c: cp      $00]|
	jeq	l_317c                             	| [$314e: jp      z,$317c] /

	move.b	unknown_63a1,d0                 	| [$3151: ld      a,(unknown_63a1)] \  This fire slot is active. Increment count for # of fires onscreen
	addq.b	#1,d0                           	| [$3154: inc     a]|
	move.b	d0,unknown_63a1                 	| [$3155: ld      (unknown_63a1),a] /
	move.b	#0x01,d0                        	| [$3158: ld      a,$01] \  Set fire color to #01 (normal) if hammer is not active, and #00 (blue) if hammer is active
	move.b	d0,(0x08,a2)                    	| [$315a: ld      (ix+$08),a]|
	move.b	hammer_active_6217,d0                 	| [$315d: ld      a,(hammer_active_6217)]|
	cmp.b	#0x01,d0                         	| [$3160: cp      $01]|
	jne	l_316a                             	| [$3162: jp      nz,$316a]|
	clr.b	d0                               	| [$3165: ld      a,$00]|
	move.b	d0,(0x08,a2)                    	| [$3167: ld      (ix+$08),a] /

l_316a:
	add.w	d3,a2                            	| [$316a: add     ix,de] next sprite
	subq.b	#1,d1                           	| [...]
	jne	l_3149                             	| [$316c: djnz    $3149] next B

	lea	unknown_63a0,a0                	| [$316e: ld      hl,unknown_63a0] \ Clear fire deployment flag
	clr.b	(a0)                             	| [$3171: ld      (hl),$00] /
	move.b	unknown_63a1,d0                 	| [$3173: ld      a,(unknown_63a1)] \  Return all the way back to the main routine if no fires are active, otherwise just return.
	                               	| [$3176: cp      $00]|
	beq.b	0f                               	| [...]
	rts                                    	| [$3178: ret     nz]| [...]
0:
	addq.w	#4,sp                           	| [$3179: inc     sp]| * 2
	rts                                    	| [$317b: ret] /

* arrive here from #314E
l_317c:
	move.b	unknown_63a1,d0                 	| [$317c: ld      a,(unknown_63a1)] \  Jump back and don't deploy fire if there are already 5 fires active (Can this ever happen here?)
	cmp.b	#0x05,d0                         	| [$317f: cp      $05]|
	jeq	l_316a                             	| [$3181: jp      z,$316a] /
	move.b	screen_number_6227,d0           	| [$3184: ld      a,(screen_number_6227)] \  Jump ahead if screen is not conveyors (i.e., the screen is rivets)
	cmp.b	#0x02,d0                         	| [$3187: cp      $02]|
	jne	l_3195                             	| [$3189: jp      nz,$3195] /
	move.b	unknown_63a1,d0                 	| [$318c: ld      a,(unknown_63a1)] \  Return if current count of # of fires == internal difficulty, on conveyors we never have more fireballs
	move.b	d0,d2                           	| [$318f: ld      c,a]| on screen than the internal difficulty
	move.b	difficulty_level_6380,d0                 	| [$3190: ld      a,(difficulty_level_6380)]|
	cmp.b	d2,d0                            	| [$3193: cp      c]|
	bne.b	0f                               	| [...]
	rts                                    	| [$3194: ret     z] / [...]
0:
l_3195:
	move.b	unknown_63a0,d0                 	| [$3195: ld      a,(unknown_63a0)] \  Jump back and don't deploy fire if fire deployment flag is not set
	cmp.b	#0x01,d0                         	| [$3198: cp      $01]|
	jne	l_316a                             	| [$319a: jp      nz,$316a] /

	move.b	d0,(a2)                    	| [$319d: ld      (ix+$00),a] Deploy a fire. Set status indicator to 1 = active
	move.b	d0,(0x18,a2)                    	| [$31a0: ld      (ix+$18),a] Set spawning indicator to 1
	clr.b	d0                               	| [$31a3: xor     a] \ Clear fire deployment flag
	move.b	d0,unknown_63a0                 	| [$31a4: ld      (unknown_63a0),a] /
	move.b	unknown_63a1,d0                 	| [$31a7: ld      a,(unknown_63a1)] \  Increment count of # of active fires
	addq.b	#1,d0                           	| [$31aa: inc     a]|
	move.b	d0,unknown_63a1                 	| [$31ab: ld      (unknown_63a1),a] /
	jra	l_316a                             	| [$31ae: jp      $316a] jump back and loop for next

* This subroutine handles all movement for all fireballs.
* called from #30F3

l_31b1:
	jbsr	l_31dd                            	| [$31b1: call    $31dd] Check if freezers should enter freezer mode
	clr.b	d0                               	| [$31b4: xor     a] \ Index of fireball being processed := 0
	move.b	d0,unknown_63a2                 	| [$31b5: ld      (unknown_63a2),a] /
	lea	current_fireball_data_address_63e0,a0	| [$31b8: ld      hl,current_fireball_data_address_63e0] \ Address of fireball data array for current fireball being processed := #63E0 = #6400 - #20
	STORE_RAM_ADDRESS_LE	a0,address_of_fireball_slot_for_this_fireball_63c8	| [$31bb: ld      (address_of_fireball_slot_for_this_fireball_63c8),hl] / This gets incremented by #20 at the start of the following loop

* Loop start
l_31be:
	LOAD_RAM_ADDRESS_LE	address_of_fireball_slot_for_this_fireball_63c8,a0	| [$31be: ld      hl,(address_of_fireball_slot_for_this_fireball_63c8)] \  Move on to next fireball by incrementing address of fireball data array for current fireball by #20
	move.w	#0x20,d1                        	| [$31c1: ld      bc,$0020]| 32
	add.w	d1,a0                            	| [$31c4: add     hl,bc]|
	STORE_RAM_ADDRESS_LE	a0,address_of_fireball_slot_for_this_fireball_63c8	| [$31c5: ld      (address_of_fireball_slot_for_this_fireball_63c8),hl] /
	move.b	(a0),d0                         	| [$31c8: ld      a,(hl)] \  Jump if fireball is not active
	                               	| [$31c9: and     a]|
	jeq	l_31d0                             	| [$31ca: jp      z,$31d0] /

	jbsr	l_3202                            	| [$31cd: call    $3202] Handle all movement for this fire

l_31d0:
	move.b	unknown_63a2,d0                 	| [$31d0: ld      a,(unknown_63a2)] \  Increment index of current fireball being processed
	addq.b	#1,d0                           	| [$31d3: inc     a]|
	move.b	d0,unknown_63a2                 	| [$31d4: ld      (unknown_63a2),a] /
	cmp.b	#NB_FIRES,d0                         	| [$31d7: cp      $05] \ Loop if index is less than 5
	jne	l_31be                             	| [$31d9: jp      nz,$31be] /

	rts                                    	| [$31dc: ret] return

* This subroutine checks if fires 2 and 4 should enter freezer mode. They always both enter at the same time and they enter with a 25% probability
* every 256 frames (note that this is 256 actual frames, not 256 fireball code execution frames).
* called from #31B1 above

l_31dd:
	move.b	difficulty_level_6380,d0                 	| [$31dd: ld      a,(difficulty_level_6380)] \  Return if internal difficulty is < 3, no freezers are allowed until difficulty 3.
	cmp.b	#0x03,d0                         	| [$31e0: cp      $03]|
	bpl.b	0f                               	| [...]
	rts                                    	| [$31e2: ret     m] / [...]
0:

	jbsr	l_31f6                            	| [$31e3: call    $31f6] Check if we should enter freezer mode (25% probability every 256 frames of entering freezer mode)
	cmp.b	#0x01,d0                         	| [$31e6: cp      $01] \ Return if should not enter freezer mode
	beq.b	0f                               	| [...]
	rts                                    	| [$31e8: ret     nz] / [...]
0:

	lea	freezer_indicator_of_2nd_fire_6439,a0	| [$31e9: ld      hl,freezer_indicator_of_2nd_fire_6439] \  Set freezer indicator of 2nd fire to #02 to enable freezer mode
	move.b	#0x02,d0                        	| [$31ec: ld      a,$02]|
	move.b	d0,(a0)                         	| [$31ee: ld      (hl),a] /

	lea	freezer_indicator_of_4th_fire_6479,a0	| [$31ef: ld      hl,freezer_indicator_of_4th_fire_6479] \  Set freezer indicator of 4th fire to #02 to enable freezer mode
	move.b	#0x02,d0                        	| [$31f2: ld      a,$02]|
	move.b	d0,(a0)                         	| [$31f4: ld      (hl),a] /
	rts                                    	| [$31f5: ret] return

* Every 256 frames this subroutine has a 25% chance of loading 1 into A. Otherwise a value not equal to 1 is loaded.
* called from #31E3

l_31f6:
	move.b	rngtimer1_6018,d0               	| [$31f6: ld      a,(rngtimer1_6018)] \  Return with 1 not loaded in A if lowest 2 bits of RNG are not 01. (75% probability of returning)
	and.b	#0x03,d0                         	| [$31f9: and     $03]|
	cmp.b	#0x01,d0                         	| [$31fb: cp      $01]|
	beq.b	0f                               	| [...]
	rts                                    	| [$31fd: ret     nz] / [...]
0:

	move.b	framecounter_601a,d0            	| [$31fe: ld      a,(framecounter_601a)] \ Else return A with timer that constantly counts down from FF to 00  ... 1 count per frame
	rts                                    	| [$3201: ret] /

* This subroutine handles all movement for a single fireball.
* called from #31CD above

l_3202:
	LOAD_RAM_ADDRESS_LE	address_of_fireball_slot_for_this_fireball_63c8,a2	| [$3202: ld      ix,(address_of_fireball_slot_for_this_fireball_63c8)] Load IX with address of fireball data array for current fireball
 	move.b	(0x18,a2),d0                    	| [$3206: ld      a,(ix+$18)] \  Jump if fireball is currently in the process of spawning
	cmp.b	#0x01,d0                         	| [$3209: cp      $01]|
	jeq	l_327a                             	| [$320b: jp      z,$327a] /

	move.b	(0x0d,a2),d0                    	| [$320e: ld      a,(ix+$0d)] \  Jump if fireball is currently on a ladder
	cmp.b	#0x04,d0                         	| [$3211: cp      $04]|
	jpl	l_3230                             	| [$3213: jp      p,$3230] /

	move.b	(0x19,a2),d0                    	| [$3216: ld      a,(ix+$19)] \  Jump if freezer mode is enguaged for this fireball
	cmp.b	#0x02,d0                         	| [$3219: cp      $02]|
	jeq	l_327e                             	| [$321b: jp      z,$327e] /

	jbsr	l_330f                            	| [$321e: call    $330f] Check if fireball should randomly reverse direction
	move.b	rngtimer1_6018,d0               	| [$3221: ld      a,(rngtimer1_6018)] \  Jump and do not climb any ladder with 75% probability, so a ladder is climbed with 25% probability.
	and.b	#0x03,d0                         	| [$3224: and     $03]| Note that left moving fireballs always skip the ladder climbing check and instead jump to the end of
	jne	l_3233                             	| [$3226: jp      nz,$3233] /  this subroutine without updating position.

l_3229:
	move.b	(0x0d,a2),d0                    	| [$3229: ld      a,(ix+$0d)] \  Jump to end of subroutine if fireball is moving left. This is reached with 25% probability so left-moving
	                               	| [$322c: and     a]| fireballs skip all movement with 25% probability, so their speed is randomized but averages 25% slower
	jeq	l_3257                             	| [$322d: jp      z,$3257] /  than the speed of right-moving fireballs.

* Fireball is on a ladder or about to mount ladder (as long as doing so is permitted).
l_3230:
	jbsr	l_333d                            	| [$3230: call    $333d] Handle fireball mounting/dismounting of ladders

l_3233:
	move.b	(0x0d,a2),d0                    	| [$3233: ld      a,(ix+$0d)] \  Jump if fireball is currently on a ladder
	cmp.b	#0x04,d0                         	| [$3236: cp      $04]|
	jpl	l_3291                             	| [$3238: jp      p,$3291] /

* Fireball is moving left or right
	jbsr	l_33ad                            	| [$323b: call    $33ad] Handle fire movement left or right, animate fireball, and adjust Y-position for slanted girders
	jbsr	l_298c                            	| [$323e: call    $298c] Load A with 1 if girder edge nearby, 0 otherwise
	cmp.b	#0x01,d0                         	| [$3241: cp      $01] \ Jump if we have reached the edge of a girder
	jeq	l_3297                             	| [$3243: jp      z,$3297] /

	LOAD_RAM_ADDRESS_LE	address_of_fireball_slot_for_this_fireball_63c8,a2	| [$3246: ld      ix,(address_of_fireball_slot_for_this_fireball_63c8)] Load IX with address of fireball slot for this fireball
	move.b	(0x0e,a2),d0                    	| [$324a: ld      a,(ix+$0e)] \  Jump if X-position is < #10 (i.e., fireball has reached left edge of screen)
	cmp.b	#0x10,d0                         	| [$324d: cp      $10]|
	jcs	l_328c                             	| [$324f: jp      c,$328c] /

	cmp.b	#0xf0,d0                         	| [$3252: cp      $f0] \ Jump if X-position is >= #F0 (i.e., fireball has reached right edge of screen)
	jcc	l_3284                             	| [$3254: jp      nc,$3284] /

l_3257:
	move.b	(0x13,a2),d0                    	| [$3257: ld      a,(ix+$13)] \  Jump if our index into the Y-position adjustment table hasn't reached 0 yet
	                               	| [$325a: cp      $00]|
	jne	l_32b9                             	| [$325c: jp      nz,$32b9] /

	move.b	#0x11,d0                        	| [$325f: ld      a,$11] Reset index into Y-position adjustment table

l_3261:
	move.b	d0,(0x13,a2)                    	| [$3261: ld      (ix+$13),a] Store updated index into Y-position adjustment table
	clr.w	d3                               	| [$3264: ld      d,$00] \  Index the Y-position adjustment table using +#13 to get in A the amount to adjust the Y-position by to
	move.b	d0,d3                           	| [$3266: ld      e,a]| make the fireball bob up and down
	lea	game_rom+0x3a7a,a0                      	| [$3267: ld      hl,$3a7a]|
	add.w	d3,a0                            	| [$326a: add     hl,de]|
	move.b	(a0),d0                         	| [$326b: ld      a,(hl)] /

        * 3A7A:  FF 00 FF FF FE FE FE FE FE FE FE FE FE FE FE FF FF 00

	move.b	(0x0e,a2),d1                    	| [$326c: ld      b,(ix+$0e)] \ Copy effective X-position into actual X-position (these two are always the same)
	move.b	d1,(0x03,a2)                    	| [$326f: ld      (ix+$03),b] /
	move.b	(0x0f,a2),d2                    	| [$3272: ld      c,(ix+$0f)] \  Compute the actual Y-position by adding the adjustment to the effective Y-position
	add.b	d2,d0                            	| [$3275: add     a,c]|
	move.b	d0,(0x05,a2)                    	| [$3276: ld      (ix+$05),a] /
	rts                                    	| [$3279: ret] return

* Arrive from #320B when fireball is spawning
l_327a:
	jbsr	l_32bd                            	| [$327a: call    $32bd] Handle fireball movement while spawning
	rts                                    	| [$327d: ret] return

* Arrive from #321B when freezer mode is enguaged
l_327e:
	jbsr	l_32d6                            	| [$327e: call    $32d6] Handle freezing fireball
	jra	l_3229                             	| [$3281: jp      $3229] Jump back to program

* Arrive from #3254 when fireball has reached right edge of screen
l_3284:
	move.b	#0x02,d0                        	| [$3284: ld      a,$02] Set direction to "special" left

l_3286:
	move.b	d0,(0x0d,a2)                    	| [$3286: ld      (ix+$0d),a] Store new direction, either 1 for right or 2 for left
	jra	l_3257                             	| [$3289: jp      $3257] Jump back

* Arrive from #324F when fireball has reached left edge of screen
l_328c:
	move.b	#0x01,d0                        	| [$328c: ld      a,$01] Set direction to right
	jra	l_3286                             	| [$328e: jp      $3286] Jump back

* Fireball is moving up or down a ladder
l_3291:
	jbsr	l_33e7                            	| [$3291: call    $33e7] Handle fireball movement up/down the ladder and animate the fireball
	jra	l_3257                             	| [$3294: jp      $3257] Jump back

* Arrived from #3243 when fire is at edge of girder
l_3297:
	LOAD_RAM_ADDRESS_LE	address_of_fireball_slot_for_this_fireball_63c8,a2	| [$3297: ld      ix,(address_of_fireball_slot_for_this_fireball_63c8)] Load IX with address of fireball slot for this fireball
	move.b	(0x0d,a2),d0                    	| [$329b: ld      a,(ix+$0d)] \  Jump if fireball direction is left
	cmp.b	#0x01,d0                         	| [$329e: cp      $01]|
	jne	l_32b1                             	| [$32a0: jp      nz,$32b1] /

	move.b	#0x02,d0                        	| [$32a3: ld      a,$02] Set direction to "special" left
	subq.b	#1,(0x0e,a2)                    	| [$32a5: dec     (ix+$0e)] Decrement fireball X-position, make fireball move left

l_32a8:
	move.b	d0,(0x0d,a2)                    	| [$32a8: ld      (ix+$0d),a] Store new direction, either 1 for right, or 2 for left
	jbsr	l_33c3                            	| [$32ab: call    $33c3] Since we just moved a pixel, adjust Y-position for slanted girders on barrel screen
	jra	l_3257                             	| [$32ae: jp      $3257] Jump back

l_32b1:
	move.b	#0x01,d0                        	| [$32b1: ld      a,$01] Set direction to right
	addq.b	#1,(0x0e,a2)                    	| [$32b3: inc     (ix+$0e)] Incremement fireball X-position, make fireball move right
	jra	l_32a8                             	| [$32b6: jp      $32a8] Jump back

* Arrived from #325C
l_32b9:
	subq.b	#1,d0                           	| [$32b9: dec     a] Decrement index into Y-position adjustment table
	jra	l_3261                             	| [$32ba: jp      $3261] Jump back

* This subroutine is responsible for handling fireball movement while the fireball is spawning. Here the fireball may be following a fixed trajectory
* such as when jumping out of an oil can for example.
* called from #327A

l_32bd:
	move.b	screen_number_6227,d0           	| [$32bd: ld      a,(screen_number_6227)] \  Jump if we are currently on barrels
	cmp.b	#0x01,d0                         	| [$32c0: cp      $01]|
	jeq	l_32ce                             	| [$32c2: jp      z,$32ce] /

	cmp.b	#0x02,d0                         	| [$32c5: cp      $02] \ Jump if we are on conveyors
	jeq	l_32d2                             	| [$32c7: jp      z,$32d2] /

	jbsr	l_34b9                            	| [$32ca: call    $34b9] Spawn fireball in proper location on rivets
	rts                                    	| [$32cd: ret] return

l_32ce:
	jbsr	l_342c                            	| [$32ce: call    $342c] Handle fireball movement while coming out of oilcan on barrels
	rts                                    	| [$32d1: ret] return

l_32d2:
	jbsr	l_3478                            	| [$32d2: call    $3478] Handle fireball movement while coming out of oilcan on conveyors
	rts                                    	| [$32d5: ret] return

* This subroutine handles a freezer when freezer mode is activated, including checking when to freeze and when to leave freezer mode.
* Called from #327E

l_32d6:
	move.b	(0x1c,a2),d0                    	| [$32d6: ld      a,(ix+$1c)] \  Jump if fireball freeze timer is non-zero, meaning we are frozen and waiting for the timer to reach 0
	                               	| [$32d9: cp      $00]| to unfreeze.
	jne	l_32fd                             	| [$32db: jp      nz,$32fd] /

	move.b	(0x1d,a2),d0                    	| [$32de: ld      a,(ix+$1d)] \  We reach this when a fireball is not frozen, but freezer mode is activated. Jump if the freeze flag is
	cmp.b	#0x01,d0                         	| [$32e1: cp      $01]| not set (This flag is only set when the fireball reaches the top of a ladder).
	jne	l_330b                             	| [$32e3: jp      nz,$330b] /

* It is time to maybe freeze the fireball at the top of a ladder.
	clr.b	(0x1d,a2)                        	| [$32e6: ld      (ix+$1d),$00] Reset the freeze flag to zero
	move.b	mario_y_position_6205,d0	| [$32ea: ld      a,(mario_y_position_6205)] \  Jump if Mario is above fireball, in this case we leave freezer mode immediately without freezing.
	move.b	(0x0f,a2),d1                    	| [$32ed: ld      b,(ix+$0f)]|
	sub.b	d1,d0                            	| [$32f0: sub     b]|
	jcs	l_3303                             	| [$32f1: jp      c,$3303] /

	move.b	#0xff,(0x1c,a2)                 	| [$32f4: ld      (ix+$1c),$ff] Freeze the fireball for 256 fireball execution frames

l_32f8:
	clr.b	(0x0d,a2)                        	| [$32f8: ld      (ix+$0d),$00] Set direction to "frozen"
	rts                                    	| [$32fc: ret] return

* Jump here from #32DB when fireball still frozen
l_32fd:
	subq.b	#1,(0x1c,a2)                    	| [$32fd: dec     (ix+$1c)] Decrement freeze timer
	jne	l_32f8                             	| [$3300: jp      nz,$32f8] Jump if it is still not time to unfreeze

* It is time to unfreeze
l_3303:
	clr.b	(0x19,a2)                        	| [$3303: ld      (ix+$19),$00] Clear the freezer mode flag
	clr.b	(0x1c,a2)                        	| [$3307: ld      (ix+$1c),$00] Clear the freeze timer

l_330b:
	jbsr	l_330f                            	| [$330b: call    $330f] Check if fireball should randomly freeze out in the open (note this is the same as the direction reversal
                                        * routine for non-freezing fireballs, only now setting direction to 00 indicates "frozen" instead of "left")
	rts                                    	| [$330e: ret] return

* This subroutine randomly reversed direction of fire every 43 fireball execution frames. Note that this is not actual frames, the actual number of
* frames will vary based on internal difficulty.
* called from #321E and from #330B

l_330f:
	move.b	(0x16,a2),d0                    	| [$330f: ld      a,(ix+$16)] \  Jump without reversing if direction reverse timer hasn't reached 0 yet
	                               	| [$3312: cp      $00]|
	jne	l_3332                             	| [$3314: jp      nz,$3332] /

	move.b	#0x2b,(0x16,a2)                 	| [$3317: ld      (ix+$16),$2b] Reset direction reverse counter to #2B
	clr.b	(0x0d,a2)                        	| [$331b: ld      (ix+$0d),$00] \  Set fireball direction to be left (or frozen for freezers) and jump with 50% probability
	move.b	rngtimer1_6018,d0               	| [$331f: ld      a,(rngtimer1_6018)]|
	ror.b	#1,d0                            	| [$3322: rrca]|
	jcc	l_3332                             	| [$3323: jp      nc,$3332] /

	move.b	(0x0d,a2),d0                    	| [$3326: ld      a,(ix+$0d)] \  Jump if direction fireball direction is 1, which is impossible, so this is a NOP.
	cmp.b	#0x01,d0                         	| [$3329: cp      $01]|
	jeq	l_3336                             	| [$332b: jp      z,$3336] /

	move.b	#0x01,(0x0d,a2)                 	| [$332e: ld      (ix+$0d),$01] Else set fireball direction to be right
l_3332:
	subq.b	#1,(0x16,a2)                    	| [$3332: dec     (ix+$16)] Decrement direction reverse timer
	rts                                    	| [$3335: ret] return

* jump here from #332B [never arrive here , buggy software]
l_3336:
	move.b	#0x02,(0x0d,a2)                 	| [$3336: ld      (ix+$0d),$02] Set fireball direction to be "special" left
	jra	l_3332                             	| [$333a: jp      $3332] jump back

* This subroutine serves two purposes. If a fireball is currently on a ladder it checks to see if the fireball has reached the other end of the ladder
* and if so dismounts the ladder. Otherwise, if the fireball is not on a ladder it checks to see if there are any ladders nearby that can be taken,
* and if so it mounts the ladder.
* called from #3230

l_333d:
	move.b	(0x0d,a2),d0                    	| [$333d: ld      a,(ix+$0d)] \  Jump if fireball is climbing up a ladder
	cmp.b	#0x08,d0                         	| [$3340: cp      $08]|
	jeq	l_3371                             	| [$3342: jp      z,$3371] /

	cmp.b	#0x04,d0                         	| [$3345: cp      $04] \ Jump if fireball is climbing down a ladder
	jeq	l_338a                             	| [$3347: jp      z,$338a] /

* Else firefox is not on a ladder, but will mount one if permitted to do so
	jbsr	l_33a1                            	| [$334a: call    $33a1] Return without taking ladder if fireball is on the top girder and the screen is not rivets
	move.b	(0x0f,a2),d0                    	| [$334d: ld      a,(ix+$0f)] \  D := Y-position of bottom of fireball
	add.b	#0x08,d0                         	| [$3350: add     a,$08]|
	move.b	d0,d3                           	| [$3352: ld      d,a] /
	move.b	(0x0e,a2),d0                    	| [$3353: ld      a,(ix+$0e)] A := fireball's X-position
	move.w	#0x15,d1                        	| [$3356: ld      bc,$0015] BC := #0015, the number of ladders to check 21
	jbsr	check_for_ladders_nearby_236e                            	| [$3359: call    $236e] Check for ladders nearby, return if none, else A := 0 if at bottom of ladder, A := 1 if at top
	tst.b	d0                               	| [$335c: and     a] \ Jump if there is a ladder nearby to go up
	jeq	l_3399                             	| [$335d: jp      z,$3399] /

* Else there is a ladder nearby to go down
	move.b	d1,(0x1f,a2)                    	| [$3360: ld      (ix+$1f),b] Store B into +#1F = Y-position of bottom of ladder
	move.b	mario_y_position_6205,d0	| [$3363: ld      a,(mario_y_position_6205)] \  Return without taking the ladder if Mario is at or above the Y-position of the fireball
	move.b	d0,d1                           	| [$3366: ld      b,a]|
	move.b	(0x0f,a2),d0                    	| [$3367: ld      a,(ix+$0f)]|
	sub.b	d1,d0                            	| [$336a: sub     b]|
	bcs.b	0f                               	| [...]
	rts                                    	| [$336b: ret     nc] / [...]
0:

	move.b	#0x04,(0x0d,a2)                 	| [$336c: ld      (ix+$0d),$04] Else set direction to descending ladder
	rts                                    	| [$3370: ret] return

* Arrived because fireball is moving up a ladder
l_3371:
	move.b	(0x0f,a2),d0                    	| [$3371: ld      a,(ix+$0f)] \  Return if fireball is not at the top of the ladder
	add.b	#0x08,d0                         	| [$3374: add     a,$08]|
	move.b	(0x1f,a2),d1                    	| [$3376: ld      b,(ix+$1f)]|
	cmp.b	d1,d0                            	| [$3379: cp      b]|
	beq.b	0f                               	| [...]
	rts                                    	| [$337a: ret     nz] / [...]
0:

* Fireball at top of ladder
	clr.b	(0x0d,a2)                        	| [$337b: ld      (ix+$0d),$00] Set fireball direction to left
	move.b	(0x19,a2),d0                    	| [$337f: ld      a,(ix+$19)] \  If freezer mode is enguaged then set the freeze flag and return, otherwise just return.
	cmp.b	#0x02,d0                         	| [$3382: cp      $02]|
	beq.b	0f                               	| [...]
	rts                                    	| [$3384: ret     nz]| [...]
0:
	move.b	#0x01,(0x1d,a2)                 	| [$3385: ld      (ix+$1d),$01]|
	rts                                    	| [$3389: ret] /

* Arrive because fireball is moving down a ladder
l_338a:
	move.b	(0x0f,a2),d0                    	| [$338a: ld      a,(ix+$0f)] \  Return if fireball is not at the bottom of the ladder
	add.b	#0x08,d0                         	| [$338d: add     a,$08]|
	move.b	(0x1f,a2),d1                    	| [$338f: ld      b,(ix+$1f)]|
	cmp.b	d1,d0                            	| [$3392: cp      b]|
	beq.b	0f                               	| [...]
	rts                                    	| [$3393: ret     nz] / [...]
0:

	clr.b	(0x0d,a2)                        	| [$3394: ld      (ix+$0d),$00] Fireball has reached the bottom, set the direction to left
	rts                                    	| [$3398: ret] return

* Arrive because there is a ladder nearby to go up
l_3399:
	move.b	d1,(0x1f,a2)                    	| [$3399: ld      (ix+$1f),b] Store B into +#1F = Y-position of top of ladder
	move.b	#0x08,(0x0d,a2)                 	| [$339c: ld      (ix+$0d),$08] Else set direction to ascending ladder
	rts                                    	| [$33a0: ret] return

* This subroutine returns to the higher subroutine (causing a ladder to NOT be taken) if a fireball is on the top girder and we are not on rivets.
* called from #334A

l_33a1:
	move.b	#0x07,d0                        	| [$33a1: ld      a,$07] \ Return if immediately we are on rivets, fireballs do not get stuck on the top in this case
	jbsr	only_continues_if_given_level_0030                            	| [$33a3: rst     $30] /

	move.b	(0x0f,a2),d0                    	| [$33a4: ld      a,(ix+$0f)] \ Return if Y-position is >= 59 (i.e., fireball is not on the top girder)
	cmp.b	#0x59,d0                         	| [$33a7: cp      $59]|
	bcs.b	0f                               	| [...]
	rts                                    	| [$33a9: ret     nc] / [...]
0:

	addq.w	#4,sp                           	| [$33aa: inc     sp] \  Else return to higher subroutine. This prevents fireballs from coming down on conveyors & girders once * 2
	rts                                    	| [$33ac: ret] /

* This subroutine handles movemnt of a fireball to the left and right. It also animates the fireball and adjusts its Y-position if travelling up/down
* a slanted girder on the barrel screen.
* called from #323B

l_33ad:
	move.b	(0x0d,a2),d0                    	| [$33ad: ld      a,(ix+$0d)] \  Jump if fireball direction is right
	cmp.b	#0x01,d0                         	| [$33b0: cp      $01]|
	jeq	l_33d9                             	| [$33b2: jp      z,$33d9] /

* Fireball is moving left
	move.b	(0x07,a2),d0                    	| [$33b5: ld      a,(ix+$07)] \  Set direction bit in fireball graphics to face left
	and.b	#0x7f,d0                         	| [$33b8: and     $7f]|
	move.b	d0,(0x07,a2)                    	| [$33ba: ld      (ix+$07),a] /
	subq.b	#1,(0x0e,a2)                    	| [$33bd: dec     (ix+$0e)] Decrement X-position

l_33c0:
	jbsr	l_3409                            	| [$33c0: call    $3409] Animate the fireball
* Fall into below subroutine

* This subroutine adjusts a fireball's Y-position based on movement up/down a slanted girder on the barrel screen.
* called from #32AB

l_33c3:
	move.b	screen_number_6227,d0           	| [$33c3: ld      a,(screen_number_6227)] \  Return if we are not on barrels
	cmp.b	#0x01,d0                         	| [$33c6: cp      $01]|
	beq.b	0f                               	| [...]
	rts                                    	| [$33c8: ret     nz] / [...]
0:
	move.b	(0x0e,a2),d5                    	| [$33c9: ld      h,(ix+$0e)] Load H with fireball X-position
	move.b	(0x0f,a2),d6                    	| [$33cc: ld      l,(ix+$0f)] Load L with fireball Y-position
	move.b	(0x0d,a2),d1                    	| [$33cf: ld      b,(ix+$0d)] Load B with fireball direction
	jbsr	l_2333                            	| [$33d2: call    $2333] Check for fireball moving up/down a slanted girder ?
	move.b	d6,(0x0f,a2)                    	| [$33d5: ld      (ix+$0f),l] Store adjusted Y-position
	rts                                    	| [$33d8: ret] return

* Fireball is moving right
l_33d9:
	move.b	(0x07,a2),d0                    	| [$33d9: ld      a,(ix+$07)] \  Set direction bit in fireball graphics to face right
	or.b	#0x80,d0                          	| [$33dc: or      $80]|
	move.b	d0,(0x07,a2)                    	| [$33de: ld      (ix+$07),a] /
	addq.b	#1,(0x0e,a2)                    	| [$33e1: inc     (ix+$0e)] Increment X-position
	jra	l_33c0                             	| [$33e4: jp      $33c0] Jump back to program

* This subroutine handles fireball movement up and down ladders. Fireball movement up a ladder is 1/3 the speed of movement down a ladder, and
* movement down a ladder is the same speed as movement to the right. The subroutine also animates the fireball as it climbs.
* called from #3291

l_33e7:
	jbsr	l_3409                            	| [$33e7: call    $3409] Animate the fireball
	move.b	(0x0d,a2),d0                    	| [$33ea: ld      a,(ix+$0d)] \  Jump if fireball is moving down the ladder
	cmp.b	#0x08,d0                         	| [$33ed: cp      $08]|
	jne	l_3405                             	| [$33ef: jp      nz,$3405] /

	move.b	(0x14,a2),d0                    	| [$33f2: ld      a,(ix+$14)] \  Jump if it is not time to climb one pixel yet
	                               	| [$33f5: and     a]|
	jne	l_3401                             	| [$33f6: jp      nz,$3401] /

	move.b	#0x02,(0x14,a2)                 	| [$33f9: ld      (ix+$14),$02] Reset ladder climb timer to 2
	subq.b	#1,(0x0f,a2)                    	| [$33fd: dec     (ix+$0f)] Decrement fireball's Y position, move up one pixel
	rts                                    	| [$3400: ret] return

l_3401:
	subq.b	#1,(0x14,a2)                    	| [$3401: dec     (ix+$14)] Decrease ladder climb timer
	rts                                    	| [$3404: ret] return

l_3405:
	addq.b	#1,(0x0f,a2)                    	| [$3405: inc     (ix+$0f)] Increment fireball's Y position, move down one pixel
	rts                                    	| [$3408: ret] return

* This subroutine handles fireball animation.
* called from #33E7 and from #33C0

l_3409:
	move.b	(0x15,a2),d0                    	| [$3409: ld      a,(ix+$15)] \  Jump if it is not time to change animation frames yet
	                               	| [$340c: and     a]|
	jne	l_3428                             	| [$340d: jp      nz,$3428] /

	move.b	#0x02,(0x15,a2)                 	| [$3410: ld      (ix+$15),$02] Reset animation change timer
	addq.b	#1,(0x07,a2)                    	| [$3414: inc     (ix+$07)] \  Toggles the lowest 4 bits of +#07 between D and E, this toggles between two possible graphics that
	move.b	(0x07,a2),d0                    	| [$3417: ld      a,(ix+$07)]| the fireball can use
	and.b	#0x0f,d0                         	| [$341a: and     $0f]|
	cmp.b	#0x0f,d0                         	| [$341c: cp      $0f]|
	beq.b	0f                               	| [...]
	rts                                    	| [$341e: ret     nz]| [...]
0:
	move.b	(0x07,a2),d0                    	| [$341f: ld      a,(ix+$07)]|
	eor.b	#0x02,d0                         	| [$3422: xor     $02]|
	move.b	d0,(0x07,a2)                    	| [$3424: ld      (ix+$07),a] /
	rts                                    	| [$3427: ret] return

l_3428:
	subq.b	#1,(0x15,a2)                    	| [$3428: dec     (ix+$15)] Decrement animation change timer
	rts                                    	| [$342b: ret] return

* The subroutine handles fireball movement as it spawns out of the oilcan on barrels.
* Called from #32CE

l_342c:
	move.b	(0x1a,a2),d6                    	| [$342c: ld      l,(ix+$1a)] \ Load HL with address into Y-position table
	move.b	(0x1b,a2),d5                    	| [$342f: ld      h,(ix+$1b)] /
	LOAD_D5_16_FROM_D5D6
	LOAD_ROM_ADDRESS_BE	d5,a0
	                               	| [$3432: xor     a] \  Jump if HL is non-zero (i.e., if this is not the very first spawning frame)
	move.b	#0x00,d1                        	| [$3433: ld      bc,$0000]| 0
	move.b	#0x00,d2                        	| [$3433: ld      bc,$0000]| 0
	tst.w	d5		| adc     hl,bc       |                   	|
	jne	l_3442                             	| [$3438: jp      nz,$3442] /

	lea	game_rom+0x3a8c,a0                      	| [$343b: ld      hl,$3a8c] We just began to spawn, load HL with address of start of Y-position table
	move.b	#0x26,(0x03,a2)                 	| [$343e: ld      (ix+$03),$26] Initialize X position to #26, the X-position of the oilcan

* This table stores the Y-positions a fireball should have each frame to follow a parabolic arc used when fireballs are coming out of oilcans.
        * 3A8C:  E8 E5 E3 E2
        * 3A90:  E1 E0 DF DE DD DD DC DC DC DC DC DC DD DD DE DF
        * 3AA0:  E0 E1 E2 E3 E4 E5 E7 E9 EB ED F0 AA

l_3442:
	addq.b	#1,(0x03,a2)                    	| [$3442: inc     (ix+$03)] Increment X-position

l_3445:
	move.b	(a0),d0                         	| [$3445: ld      a,(hl)] \  Jump if we've reached the end of the Y-position table (marked by #AA)
	cmp.b	#0xaa,d0                         	| [$3446: cp      $aa]|
	jeq	l_3456                             	| [$3448: jp      z,$3456] /

	move.b	d0,(0x05,a2)                    	| [$344b: ld      (ix+$05),a] Else store table data into fire's Y-position
	addq.w	#1,a0                           	| [$344e: inc     hl] \  Advance to next table entry, for the next frame
	STORE_ROM_ADDRESS_BE	a0,d5
	LOAD_D5D6_FROM_D5_16
	
	move.b	d6,(0x1a,a2)                    	| [$344f: ld      (ix+$1a),l]|
	move.b	d5,(0x1b,a2)                    	| [$3452: ld      (ix+$1b),h] /
	rts                                    	| [$3455: ret] return

* Fire has completed its spawning and is now free-floating
l_3456:
	clr.b	d0                               	| [$3456: xor     a] A := 0
	move.b	d0,(0x13,a2)                    	| [$3457: ld      (ix+$13),a] Clear fire animation height counter
	move.b	d0,(0x18,a2)                    	| [$345a: ld      (ix+$18),a] Clear firefox spawning indicator
	move.b	d0,(0x0d,a2)                    	| [$345d: ld      (ix+$0d),a] Set direction to left
	move.b	d0,(0x1c,a2)                    	| [$3460: ld      (ix+$1c),a] Clear the still indicator
	move.b	(0x03,a2),d0                    	| [$3463: ld      a,(ix+$03)] \ Make copy of X-position
	move.b	d0,(0x0e,a2)                    	| [$3466: ld      (ix+$0e),a] /
	move.b	(0x05,a2),d0                    	| [$3469: ld      a,(ix+$05)] \ Make copy of Y-position
	move.b	d0,(0x0f,a2)                    	| [$346c: ld      (ix+$0f),a] /
	clr.b	(0x1a,a2)                        	| [$346f: ld      (ix+$1a),$00] \ Clear address into Y-position spawning table
	clr.b	(0x1b,a2)                        	| [$3473: ld      (ix+$1b),$00] / [these last two could have been written above with one less byte each]
	rts                                    	| [$3477: ret] return

* This subroutine handles fireball movement as it spawns out of the oilcan on conveyors.
* Called from #32D2

l_3478:
	move.b	(0x1a,a2),d6                    	| [$3478: ld      l,(ix+$1a)] \ Load HL with address into Y-position table
	move.b	(0x1b,a2),d5                    	| [$347b: ld      h,(ix+$1b)] /
	LOAD_D5_16_FROM_D5D6
	LOAD_ROM_ADDRESS_BE	d5,a0
													| [$347e: xor     a] \  Jump if HL is non-zero (i.e., if this is not the very first spawning frame)
	                        	| [$347f: ld      bc,$0000]| 0
	                        	| [$347f: ld      bc,$0000]| 0
	tst.w	d5				| adc     hl,bc       |                   	|
	jne	l_349a                             	| [$3484: jp      nz,$349a] /

	lea	game_rom+0x3aac,a0                      	| [$3487: ld      hl,$3aac] load HL with start of table data
	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$348a: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] \  Jump if Mario is on left side of the screen, in this case we spawn the fireball on the left
	btst.b	#7,d0                           	| [$348d: bit     7,a]|
	jeq	l_34a8                             	| [$348f: jp      z,$34a8] /

	move.b	#0x01,(0x0d,a2)                 	| [$3492: ld      (ix+$0d),$01] Set fireball direction to "right"
	move.b	#0x7e,(0x03,a2)                 	| [$3496: ld      (ix+$03),$7e] Initialize X position to #7E

l_349a:

	move.b	(0x0d,a2),d0                    	| [$349a: ld      a,(ix+$0d)] \  Jump if fireball moving left
	cmp.b	#0x01,d0                         	| [$349d: cp      $01]|
	jne	l_34b3                             	| [$349f: jp      nz,$34b3] /

	addq.b	#1,(0x03,a2)                    	| [$34a2: inc     (ix+$03)] Moving right, Increment X-position
	jra	l_3445                             	| [$34a5: jp      $3445] Jump back, remainder of subroutine shared with the above subroutine

l_34a8:
	move.b	#0x02,(0x0d,a2)                 	| [$34a8: ld      (ix+$0d),$02] Set fireball direction to "special" left (This isn't actually used at all after spawning, since immediately
                                        * after spawning it will check to reverse rection and receive a direction of either "right" or "left".
	move.b	#0x80,(0x03,a2)                 	| [$34ac: ld      (ix+$03),$80] Initialize X position to #80
	jra	l_349a                             	| [$34b0: jp      $349a] Jump back [why there?  after setting direction, we should jump directly to #34B3]

l_34b3:
	subq.b	#1,(0x03,a2)                    	| [$34b3: dec     (ix+$03)] Moving left, Decrement X-position
	jra	l_3445                             	| [$34b6: jp      $3445] Jump back, remainder of subroutine shared with the above subroutine


* On rivets, this subroutine spawns a fireball on a random platform besides the very top on the side of the screen opposite the the side that Mario
* is on.
* Called from #32CA when screen is elevators or rivets


l_34b9:
	move.b	screen_number_6227,d0           	| [$34b9: ld      a,(screen_number_6227)] \  Return if current screen is elevators (Can this ever happen?)
	cmp.b	#0x03,d0                         	| [$34bc: cp      $03]|
	bne.b	0f                               	| [...]
	rts                                    	| [$34be: ret     z] / [...]
0:

	move.b	jump_if_bit_7_of_mario_x_position_is_set_6203,d0	| [$34bf: ld      a,(jump_if_bit_7_of_mario_x_position_is_set_6203)] \  Jump if bit 7 of Mario's X-position is set (i.e., Mario is on the right half of the screen)
	btst.b	#7,d0                           	| [$34c2: bit     7,a]|
	jne	l_34ed                             	| [$34c4: jp      nz,$34ed] /

	lea	game_rom+0x3ac4,a0                      	| [$34c7: ld      hl,$3ac4] Load HL with start of table data for spawning fireball on right side

* Possible X and Y positions to spawn a fireball on the right side of the screen
* First value is X position, 2nd value is Y position

* 3AC4:  EE F0  | bottom, right
* 3AC6:  DB A0  | middle, right
* 3AC8:  E6 C8  | 2nd from bottom, right
* 3ACA:  D6 78  | 2nd from top, right
* 3ACC:  EB F0  | unused?
* 3ACE:  DB A0  | unused?
* 3AD0:  E6 C8  | unused?
* 3AD2:  E6 C8  | unused?

* Possible X and Y positions to spawn a fireball on the left side of the screen
* First value is X position, 2nd value is Y position

* 3AD4:  1B C8  | 2nd from bottom, left
* 3AD6:  23 A0  | middle, left
* 3AD8:  2B 78  | 2nd from top, left
* 3ADA:  12 F0  | bottom, left
* 3ADC:  1B C8  | unused?
* 3ADE:  23 A0  | unused?
* 3AE0:  12 F0  | unused?
* 3AE2:  1B C8  | unused?



l_34ca:
	clr.w	d1                               	| [$34ca: ld      b,$00] \  Load BC with one of #0000, #0002, #0004, or #0006 randomly
	move.b	rngtimer2_6019,d0               	| [$34cc: ld      a,(rngtimer2_6019)]|
	and.b	#0x06,d0                         	| [$34cf: and     $06]|
	move.b	d0,d1                           	| [$34d1: ld      c,a] /
	add.w	d1,a0                            	| [$34d2: add     hl,bc] add this result into HL to get offset into table
	move.b	(a0),d0                         	| [$34d3: ld      a,(hl)] \  Copy X-position from table into fireball X-position
	move.b	d0,(0x03,a2)                    	| [$34d4: ld      (ix+$03),a]|
	move.b	d0,(0x0e,a2)                    	| [$34d7: ld      (ix+$0e),a] /
	addq.w	#1,a0                           	| [$34da: inc     hl] next table entry
	move.b	(a0),d0                         	| [$34db: ld      a,(hl)] \  Copy Y-position from table into fireball Y-position
	move.b	d0,(0x05,a2)                    	| [$34dc: ld      (ix+$05),a]|
	move.b	d0,(0x0f,a2)                    	| [$34df: ld      (ix+$0f),a] /
	clr.b	d0                               	| [$34e2: xor     a] A := 0
	move.b	d0,(0x0d,a2)                    	| [$34e3: ld      (ix+$0d),a] Set fireball direction to left
	move.b	d0,(0x18,a2)                    	| [$34e6: ld      (ix+$18),a] Clear fireball spawning indicator
	move.b	d0,(0x1c,a2)                    	| [$34e9: ld      (ix+$1c),a] Clear +1C = still indicator
	rts                                    	| [$34ec: ret] return

l_34ed:
	lea	game_rom+0x3ad4,a0                      	| [$34ed: ld      hl,$3ad4] Load HL with alternate start of table data for spawning fireball on left side.
	jra	l_34ca                             	| [$34f0: jp      $34ca] Jump back

* update fires or firefoxes to hardware
* called from #30F6

l_34f3:
	lea	start_of_fires_table_6400,a0   	| [$34f3: ld      hl,start_of_fires_table_6400] start of fire/firefox data
	lea	start_of_firefox_sprites_69d0,a1	| [$34f6: ld      de,start_of_firefox_sprites_69d0] start of firefox sprites (hardware)
	move.b	#NB_FIRES,d1                        	| [$34f9: ld      b,$05] For B = 1 to 5

l_34fb:
	move.b	(a0),d0                         	| [$34fb: ld      a,(hl)] get firefox data
	                               	| [$34fc: and     a] is this sprite active ?
	jeq	l_351e                             	| [$34fd: jp      z,$351e] no, jump away and set for next sprite

	addq.w	#3,a0                           	| [$3500: inc     l] * 3
	move.b	(a0),d0                         	| [$3503: ld      a,(hl)] load A with firefox X position
	move.b	d0,(a1)+                         	| [$3504: ld      (de),a] store into sprite X position
	addq.w	#0x04,a0                        	| [$3505: ld      a,$04] A := 4
												| [$3507: add     a,l] add to L
												| [$3508: ld      l,a] HL now points to firefox's Y position (IX + #07)
	                           	| [$3509: inc     e] next DE, now it has sprite Y position
	move.b	(a0)+,d0                         	| [$350a: ld      a,(hl)] load A with firefox Y position
	move.b	d0,(a1)+                         	| [$350b: ld      (de),a] store into hardaware sprite Y position
												| [$350c: inc     l] next HL
	                           	| [$350d: inc     e] next DE
	move.b	(a0),d0                         	| [$350e: ld      a,(hl)] load A with firefox sprite color value
	move.b	d0,(a1)+                         	| [$350f: ld      (de),a] store sprite color
	subq.w	#3,a0                           	| [$3510: dec     l] * 3
	                           	| [$3513: inc     e] next DE
	move.b	(a0),d0                         	| [$3514: ld      a,(hl)] load A with sprite value
	move.b	d0,(a1)+                         	| [$3515: ld      (de),a] store sprite value to hardware
												| [$3516: inc     de] next DE

l_3517:
	add.w	#0x1b,a0                        	| [$3517: ld      a,$1b] A := #1B
												| [$3519: add     a,l] add to L
											| [$351a: ld      l,a] store into L.  HL how has #1B more.  The next sprite is referenced
	subq.b	#1,d1                           	| [...]
	jne	l_34fb                             	| [$351b: djnz    $34fb] Next Firefox

	rts                                    	| [$351d: ret] return

* arrive here when firefox is not being used, sets pointer for next sprite

l_351e:
	addq.w	#0x05,a0                        	| [$351e: ld      a,$05] A := 5
											| [$3520: add     a,l] add to L
											| [$3521: ld      l,a] store into L.  HL is now 5 more than before
	                        	| [$3522: ld      a,$04] A := 4
	addq.w	#4,a1                            	| [$3524: add     a,e] add to E
	                           	| [$3525: ld      e,a] store into E.  DE is now 4 more than before.  next sprite
	jra	l_3517                             	| [$3526: jp      $3517] jump back

* table data
* used for item scoring :  100, 200 , 300 etc
* called from #0525


item_scoring_table_3529:
	.byte	0x00,0x00,0x00
	.byte	0x00,0x01,0x00
	.byte	0x00,0x02,0x00
	.byte	0x00,0x03,0x00
	.byte	0x00,0x04,0x00
	.byte	0x00,0x05,0x00
	.byte	0x00,0x06,0x00
	.byte	0x00,0x07,0x00
	.byte	0x00,0x08,0x00
	.byte	0x00,0x09,0x00
	.byte	0x00,0x00,0x00
	.byte	0x00,0x10,0x00
	.byte	0x00,0x20,0x00
	.byte	0x00,0x30,0x00
	.byte	0x00,0x40,0x00
	.byte	0x00,0x50,0x00
	.byte	0x00,0x60,0x00
	.byte	0x00,0x70,0x00
	.byte	0x00,0x80,0x00
	.byte	0x00,0x90,0x00

*  table data .. loaded at #025A when game is powered on or reset
* transferred into #6100 to #61AA
* high score table

* first 2 bytes form a VRAM address. EG #7794 through #779C
* 3rd byte is the place.  1 through 5
* 4th and 5th bytes are either "ST" or "ND" or "RD" or "TH"
* 6th and 7th bytes are #10 for blank spaces
* 8th through 13th bytes are the score digits
* 14 through end are #10 for blank spaces, ended by #3F end code
* after this is the actual score
* the last 2 bytes are ???

l_3565:
	.byte	0x94,0x77,0x01,0x23,0x24,0x10,0x10,0x00,0x00,0x07,0x06,0x05,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x50,0x76,0x00,0xF4,0x76
l_3587:
	.byte	0x96,0x77,0x02,0x1E,0x14,0x10,0x10,0x00,0x00,0x06,0x01,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x00,0x61,0x00,0xF6,0x76
l_35A9:
	.byte	0x98,0x77,0x03,0x22,0x14,0x10,0x10,0x00,0x00,0x05,0x09,0x05,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x50,0x59,0x00,0xF8,0x76
l_35CB:
	.byte	0x9A,0x77,0x04,0x24,0x18,0x10,0x10,0x00,0x00,0x05,0x00,0x05,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x50,0x50,0x00,0xFA,0x76
l_35EE:
	.byte	0x9C,0x77,0x05,0x24,0x18,0x10,0x10,0x00,0x00,0x04,0x03,0x00,0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x00,0x00,0x43,0x00,0xFC,0x76

* data read at #1611
* used for high score entry ???

l_360F:
	.byte	0x3B
l_3610:
	.byte	0x5C,0x4B,0x5C,0x5B,0x5C,0x6B,0x5C,0x7B,0x5C,0x8B,0x5C,0x9B,0x5C,0xAB,0x5C,0xBB
l_3620:
	.byte	0x5C,0xCB,0x5C,0x3B,0x6C,0x4B,0x6C,0x5B,0x6C,0x6B,0x6C,0x7B,0x6C,0x8B,0x6C,0x9B
l_3630:
	.byte	0x6C,0xAB,0x6C,0xBB,0x6C,0xCB,0x6C,0x3B,0x7C,0x4B,0x7C,0x5B,0x7C,0x6B,0x7C,0x7B
l_3640:
	.byte	0x7C,0x8B,0x7C,0x9B,0x7C,0xAB,0x7C,0xBB,0x7C,0xCB,0x7C

* #364B is used from #05E9

l_364B:
	.byte	0x8B,0x36           | 0       | #368B "GAME OVER"
l_364D:                         |
	.byte	0x01,0x00           | 1       | unused ?
l_364F:                         |
	.byte	0x98,0x36           | 2       | #3698 "PLAYER <I>"
l_3651:                         |
	.byte	0xA5,0x36           | 3       | #36A5 "PLAYER <II>"
l_3653:                         |
	.byte	0xB2,0x36           | 4       | #36B2 "HIGH SCORE"
l_3655:                         |
	.byte	0xBF,0x36           | 5       | #36BF "CREDIT"
l_3657:                         |
	.byte	0x06,0x00           | 6       | unused ?
l_3659:                         |
	.byte	0xCC,0x36           | 7       | #36CC "HOW HIGH CAN YOU GET?"
                                |         | "IT'S ON LIKE KONKEY DONG!"
l_365B:                         |
	.byte	0x08,0x00           | 8       | unused ?
l_365D:                         |
	.byte	0xE6,0x36           | 9       | #36E6 "ONLY 1 PLAYER BUTTON"
l_365F:                         |
	.byte	0xFD,0x36           | A       | #36FD "1 OR 2 PLAYERS BUTTON"
l_3661:                         |
	.byte	0x0B,0x00           | B       | unused ?
l_3663:                         |
	.byte	0x15,0x37           | C       | #3715 "PUSH"
l_3665:                         |
	.byte	0x1C,0x37           | D       | #371C "NAME REGISTRATION"
l_3667:                         |
	.byte	0x30,0x37           | E       | #3730 "NAME:"
l_3669:                         |
	.byte	0x38,0x37           | F       | #3738 "---"
l_366B:
	.byte	0x47,0x37,0x10      | #3747 "A" through "J"
l_366D:
	.byte	0x5D,0x37,0x11      | #375D "K through "T"
l_366F:
	.byte	0x73,0x37,0x12      | #3773 "U" through "Z" and "RUBEND"
l_3671:
	.byte	0x8B,0x37,0x13      | #378B "REGI TIME"
l_3673:
	.byte	0x00,0x61,0x14      | #6100 High score entry 1 ?
l_3675:
	.byte	0x22,0x61,0x15      | #6122 High score entry 2 ?
l_3677:
	.byte	0x44,0x61,0x16      | #6144 High score entry 3 ?
l_3679:
	.byte	0x66,0x61,0x17      | #6166 High score entry 4 ?
l_367B:
	.byte	0x88,0x61,0x18      | #6188 High score entry 5?
l_367D:
	.byte	0x9E,0x37,0x19      | #379E "RANK SCORE NAME"
l_367F:
	.byte	0xB6,0x37,0x1A      | #37B6 "YOUR NAME WAS REGISTERED"
l_3681:
	.byte	0xD2,0x37,0x1B      | #37D2 "INSERT COIN"
l_3683:
	.byte	0xE1,0x37,0x1C      | #37E1 "PLAYER    COIN"
l_3685:
	.byte	0x1D,0x00,0x1D      | unused ?
l_3687:
	.byte	0x00,0x3F,0x1E      | #3F00 "(C) 1981"
l_3689:
	.byte	0x09,0x3F,0x1F      | #3F09 "NINTENDO OF AMERICA"

l_368A:
	.byte	0x96,0x76,0x17,0x11,0x1D          |   ..GAM
l_3690:
	.byte	0x15,0x10,0x10,0x1F,0x26,0x15,0x22,0x3F,0x94,0x76,0x20,0x1C,0x11,0x29,0x15,0x22 | E..OVER...PLAYER
l_36A0:                                                                                     |
	.byte	0x10,0x30,0x32,0x31,0x3F,0x94,0x76,0x20,0x1C,0x11,0x29,0x15,0x22,0x10,0x30,0x33 | .<I>...PLAYER.<2
l_36B0:                                                                                     |
	.byte	0x31,0x3F,0x80,0x76,0x18,0x19,0x17,0x18,0x10,0x23,0x13,0x1F,0x22,0x15,0x3F,0x9F | >...HIGH.SCORE..
l_36C0:                                                                                     |
	.byte	0x75,0x13,0x22,0x15,0x14,0x19,0x24,0x10,0x10,0x10,0x10,0x3F,0x5E,0x77,0x18,0x1F | .CREDIT.......HO
l_36D0:                                                                                     |
	.byte	0x27,0x10,0x18,0x19,0x17,0x18,0x10,0x13,0x11,0x1E,0x10,0x29,0x1F,0x25,0x10,0x17 | W.HIGH.CAN.YOU.G
l_36E0:                                                                                     |
	.byte	0x15,0x24,0x10,0xFB,0x10,0x3F,0x29,0x77,0x1F,0x1E,0x1C,0x29,0x10,0x01,0x10,0x20 | ET.?....ONLY.1.P
l_36F0:                                                                                     |
	.byte	0x1C,0x11,0x29,0x15,0x22,0x10,0x12,0x25,0x24,0x24,0x1F,0x1E,0x3F,0x29,0x77,0x01 | LAYER.BUTTON...1
l_3700:                                                                                     |
	.byte	0x10,0x1F,0x22,0x10,0x02,0x10,0x20,0x1C,0x11,0x29,0x15,0x22,0x23,0x10,0x12,0x25 | .OR.2.PLAYERS.BU
l_3710:                                                                                     |
	.byte	0x24,0x24,0x1F,0x1E,0x3F,0x27,0x76,0x20,0x25,0x23,0x18,0x3F,0x06,0x77,0x1E,0x11 | TTON...PUSH...NA
l_3720:                                                                                     |
	.byte	0x1D,0x15,0x10,0x22,0x15,0x17,0x19,0x23,0x24,0x22,0x11,0x24,0x19,0x1F,0x1E,0x3F | ME.REGISTRATION.
l_3730:                                                                                     |
	.byte	0x88,0x76,0x1E,0x11,0x1D,0x15,0x2E,0x3F,0xE9,0x75,0x2D,0x2D,0x2D,0x10,0x10,0x10 | ..NAME:...---...
l_3740:                                                                                     |
	.byte	0x10,0x10,0x10,0x10,0x10,0x10,0x3F,0x0B,0x77,0x11,0x10,0x12,0x10,0x13,0x10,0x14 | .........A.B.C.D
l_3750:                                                                                     |
	.byte	0x10,0x15,0x10,0x16,0x10,0x17,0x10,0x18,0x10,0x19,0x10,0x1A,0x3F,0x0D,0x77,0x1B | .E.F.G.H.I.J...K
l_3760:                                                                                     |
	.byte	0x10,0x1C,0x10,0x1D,0x10,0x1E,0x10,0x1F,0x10,0x20,0x10,0x21,0x10,0x22,0x10,0x23 | .L.M.N.O.P.Q.R.S
l_3770:                                                                                     |
	.byte	0x10,0x24,0x3F,0x0F,0x77,0x25,0x10,0x26,0x10,0x27,0x10,0x28,0x10,0x29,0x10,0x2A | .T...U.V.W.X.Y.Z
l_3780:                                                                                     |
	.byte	0x10,0x2B,0x10,0x2C,0x44,0x45,0x46,0x47,0x48,0x10,0x3F,0xF2,0x76,0x22,0x15,0x17 | ...-RUBEND...REG
l_3790:                                                                                     |
	.byte	0x19,0x10,0x24,0x19,0x1D,0x15,0x10,0x10,0x30,0x03,0x00,0x31,0x10,0x3F,0x92,0x77 | I.TIME..........
l_37A0:                                                                                     |
	.byte	0x22,0x11,0x1E,0x1B,0x10,0x10,0x23,0x13,0x1F,0x22,0x15,0x10,0x10,0x1E,0x11,0x1D | RANK..SCORE..NAM
l_37B0:                                                                                     |
	.byte	0x15,0x10,0x10,0x10,0x10,0x3F,0x72,0x77,0x29,0x1F,0x25,0x22,0x10,0x1E,0x11,0x1D | E.......YOUR.NAM
l_37C0:                                                                                     |
	.byte	0x15,0x10,0x27,0x11,0x23,0x10,0x22,0x15,0x17,0x19,0x23,0x24,0x15,0x22,0x15,0x14 | E.WAS.REGISTERED
l_37D0:                                                                                     |
	.byte	0x42,0x3F,0xA7,0x76,0x19,0x1E,0x23,0x15,0x22,0x24,0x10,0x13,0x1F,0x19,0x1E,0x10 | ....INSERT.COIN.
l_37E0:                                                                                     |
	.byte	0x3F,0x0A,0x77,0x10,0x10,0x20,0x1C,0x11,0x29,0x15,0x22,0x10,0x10,0x10,0x10,0x13 | .....PLAYER....C
l_37F0:                                                                                     |
	.byte	0x1F,0x19,0x1E,0x3F,0xFC,0x76,0x49,0x4A,0x10,0x1E,0x19,0x1E,0x24,0x15,0x1E,0x14 | OIN......NINTEND
l_3800:
	.byte	0x1F,0x10,0x10,0x10,0x10,0x3F                  |              O.....

* ???

l_3806:
	.byte	0x7C,0x75,0x01,0x09,0x08,0x01,0x3F

* table data used for game intro

l_380D:
	.byte	0x02,0x97,0x38,0x68,0x38   | top level where girl sits
l_3812:
	.byte	0x02,0xDF,0x54,0x10,0x54   | kongs level girder
l_3817:
	.byte	0x02,0xEF,0x6D,0x20,0x6D   | 2nd girder down
l_381C:
	.byte	0x02,0xDF,0x8E,0x10,0x8E   | 3rd girder down
l_3821:
	.byte	0x02,0xEF,0xAF,0x20,0xAF   | 4th girder down
l_3826:
	.byte	0x02,0xDF,0xD0,0x10,0xD0   | 5th girder down
l_382B:
	.byte	0x02,0xEF,0xF1,0x10,0xF1   | bottom girder
l_3830:
	.byte	0x00,0x53,0x18,0x53,0x54   | kong's ladder (left)
l_3835:
	.byte	0x00,0x63,0x18,0x63,0x54   | kong's ladder (right)
l_383A:
	.byte	0x00,0x93,0x38,0x93,0x54   | ladder to reach girl
l_383F:
	.byte	0x00,0x83,0x54,0x83,0xF1   | long ladder (left)
l_3834:
	.byte	0x00,0x93,0x54,0x93,0xF1   | long ladder (right)
l_3849:
	.byte	0xAA               | end of data code

* table data
* used for timer graphic and zero score inside

l_384A:
	.byte	0x8D,0x7D,0x8C
l_384D:
	.byte	0x6F,0x00,0x7C
l_3850:
	.byte	0x6E,0x00,0x7C
l_3853:
	.byte	0x6D,0x00,0x7C
l_3856:
	.byte	0x6C,0x00,0x7C
l_3859:
	.byte	0x8F,0x7F,0x8E

* table data
* used for antimation of kong

l_385C:
	.byte	0x47,0x27,0x08,0x50
l_3860:
	.byte	0x2F,0xA7,0x08,0x50
l_3864:
	.byte	0x3B,0x25,0x08,0x50
l_3868:
	.byte	0x00,0x70,0x08,0x48
l_386C:
	.byte	0x3B,0x23,0x07,0x40
l_3870:
	.byte	0x46,0xA9,0x08,0x44
l_3874:
	.byte	0x00,0x70,0x08,0x48
l_3878:
	.byte	0x30,0x29,0x08,0x44
l_387C:
	.byte	0x00,0x70,0x08,0x48
l_3880:
	.byte	0x00,0x70,0x0A,0x48

* table data used to draw the girl from #0D7A and #0B2A

l_3884:
	.byte	0x6F,0x10,0x09,0x23
l_3888:
	.byte	0x6F,0x11,0x0A,0x33

* used for animation of kong

l_388C:
	.byte	0x50,0x34,0x08,0x3C
l_3890:
	.byte	0x00,0x35,0x08,0x3C
l_3894:
	.byte	0x53,0x32,0x08,0x40
l_3898:
	.byte	0x63,0x33,0x08,0x40
l_389C:
	.byte	0x00,0x70,0x08,0x48
l_38A0:
	.byte	0x53,0x36,0x08,0x50
l_38A4:
	.byte	0x63,0x37,0x08,0x50
l_38A8:
	.byte	0x6B,0x31,0x08,0x41
l_38AC:
	.byte	0x00,0x70,0x08,0x48
l_38B0:
	.byte	0x6A,0x14,0x0A,0x48

* used when kong jump at end of intro

l_38B4:
	.byte	0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFE
l_38C0:
	.byte	0xFE,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x01,0x01,0x01
l_38CA:
	.byte	0x7F                       | end code


* used when kong jumps to left during intro at #0B70

l_38CB:
	.byte	0xFF,0xFF,0xFF,0xFF,0xFF
l_38D0:
	.byte	0x00,0xFF,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x01,0x01,0x7F

* used after kong has jumped
* used in #0DA7.  end code is #AA

l_38DC:
	.byte	0x04,0x7F,0xF0,0x10,0xF0
l_38E1:
	.byte	0x02,0xDF,0xF2,0x70,0xF8
l_38E6:
	.byte	0x02,0x6F,0xF8,0x10,0xF8
l_38EB:
	.byte	0xAA

l_38EC:
	.byte	0x04,0xDF,0xD0,0x90,0xD0
l_38F1:
	.byte	0x02,0xDF,0xDC,0x20,0xD1
l_38F6:
	.byte	0xAA

l_38F7:
	.byte	0xFF,0xFF,0xFF,0xFF,0xFF   | unused ?

l_38FC:
	.byte	0x04,0xDF,0xA8,0x20,0xA8
l_3901:
	.byte	0x04,0x5F,0xB0,0x20,0xB0
l_3906:
	.byte	0x02,0xDF,0xB0,0x20,0xBB
l_390B:
	.byte	0xAA

l_390C:
	.byte	0x04,0xDF,0x88,0x30,0x88
l_3911:
	.byte	0x04,0xDF,0x90,0xB0,0x90
l_3916:
	.byte	0x02,0xDF,0x9A,0x20,0x8F
l_391B:
	.byte	0xAA

l_391C:
	.byte	0x04,0xBF,0x68,0x20,0x68
l_3921:
	.byte	0x04,0x3F,0x70,0x20,0x70
l_3926:
	.byte	0x02,0xDF,0x6E,0x20,0x79
l_3927:
	.byte	0xAA

l_392C:
	.byte	0x02,0xDF,0x58,0xA0,0x55   | top right ledge angled down
l_3931:
	.byte	0xAA

* this is table data
* used for animation of kong
* used from #2D24

l_3932:
	.byte	0x00,0x70,0x08,0x44
l_3936:
	.byte	0x2B,0xAC,0x08,0x4C
l_393A:
	.byte	0x3B,0xAE,0x08,0x4C
l_393E:
	.byte	0x3B,0xAF,0x08,0x3C
l_3942:
	.byte	0x4B,0xB0,0x07,0x3C
l_3946:
	.byte	0x4B,0xAD,0x08,0x4C
l_394A:
	.byte	0x00,0x70,0x08,0x44
l_394E:
	.byte	0x00,0x70,0x08,0x44
l_3952:
	.byte	0x00,0x70,0x08,0x44
l_3956:
	.byte	0x00,0x70,0x0A,0x44

* used to animate kong

l_395A:
	.byte	0x47,0x27,0x08,0x4C
l_395E:
	.byte	0x2F,0xA7,0x08,0x4C
l_3962:
	.byte	0x3B,0x25,0x08,0x4C
l_3966:
	.byte	0x00,0x70,0x08,0x44
l_396A:
	.byte	0x3B,0x23,0x07,0x3C
l_396E:
	.byte	0x4B,0x2A,0x08,0x3C
l_3972:
	.byte	0x4B,0x2B,0x08,0x4C
l_3976:
	.byte	0x2B,0xAA,0x08,0x3C
l_397A:
	.byte	0x2B,0xAB,0x08,0x4C
l_397E:
	.byte	0x00,0x70,0x0A,0x44

* used for kong's middle deploy

l_3982:
	.byte	0x00,0x70,0x08,0x44
l_3986:
	.byte	0x4B,0x2C,0x08,0x4C
l_398A:
	.byte	0x3B,0x2E,0x08,0x4C
l_398E:
	.byte	0x3B,0x2F,0x08,0x3C
l_3992:
	.byte	0x2B,0x30,0x07,0x3C
l_3996:
	.byte	0x2B,0x2D,0x08,0x4C
l_399A:
	.byte	0x00,0x70,0x08,0x44
l_399E:
	.byte	0x00,0x70,0x08,0x44
l_39A2:
	.byte	0x00,0x70,0x08,0x44
l_39A6:
	.byte	0x00,0x70,0x0A,0x44

* used in #2E3D on elevators
* used for bouncers| each is an offset that is added to the Y position as it moves

l_39AA:
	.byte	0xFD,0xFD,0xFD,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0x00,0xFF,0x00,0x00,0x01,0x00,0x01,0x01,0x02,0x02,0x02,0x02,0x03,0x03,0x03
l_39C2:
	.byte	0x7F       | end code

* used in #2D8C for barrel release

l_39C3:
	.byte	0x1E,0x4E,0xBB,0x4C,0xD8,0x4E,0x59,0x4E,0x7F

* table data having to do with crazy barrels.
* used in #2D83
l_39cc:
	.byte		0xBB                | for crazy barrels
	.byte		0x4D                |
	.byte		0x7F                | deployed when #7F

* table data
* kong is beating his chest

l_39CF:
	.byte	0x47,0x27,0x08,0x50
l_39D3:
	.byte	0x2D,0x26,0x08,0x50
l_39D7:
	.byte	0x3B,0x25,0x08,0x50
l_39DA:
	.byte	0x00,0x70,0x08,0x48
l_39DF:
	.byte	0x3B,0x24,0x07,0x40
l_39E3:
	.byte	0x4B,0x28,0x08,0x40
l_39E7:
	.byte	0x00,0x70,0x08,0x48
l_39EA:
	.byte	0x30,0x29,0x08,0x44
l_39EF:
	.byte	0x00,0x70,0x08,0x48
l_39F3:
	.byte	0x00,0x70,0x0A,0x48

* table data for animation of kong #28 bytes (40 decimal)
* used in #0445
* the kong is beating his chest with right leg lifted

l_39F7:
	.byte	0x49,0xA6,0x08,0x50,0x2F,0xA7,0x08,0x50,0x3B,0x25,0x08,0x50,0x00,0x70,0x08,0x48
l_3A07:
	.byte	0x3B,0x24,0x07,0x40,0x46,0xA9,0x08,0x44,0x00,0x70,0x08,0x48,0x2B,0xA8,0x08,0x40
l_3A17:
	.byte	0x00,0x70,0x08,0x48,0x00,0x70,0x0A,0x48

* table data for upside down kong after rivets cleared
* used in #1870
* #28 bytes = 40 bytes decimal

l_3A1F:
	.byte	0x73,0xA7,0x88,0x60
l_3A23:
	.byte	0x8B,0x27,0x88,0x60
l_3A27:
	.byte	0x7F,0x25,0x88,0x60
l_3A2B:
	.byte	0x00,0x70,0x88,0x68
l_3A2F:
	.byte	0x7F,0x24,0x87,0x70
l_3A33:
	.byte	0x74,0x29,0x88,0x6C
l_3A37:
	.byte	0x00,0x70,0x88,0x68
l_3A3B:
	.byte	0x8A,0xA9,0x88,0x6C
l_3A3F:
	.byte	0x00,0x70,0x88,0x68
l_3A43:
	.byte	0x00,0x70,0x8A,0x68

* table data
* used when rivets are cleared

l_3A47:
	.byte	0x05,0xAF,0xF0,0x50,0xF0,0xAA
l_3A4D:
	.byte	0x05,0xAF,0xE8,0x50,0xE8,0xAA
l_3A53:
	.byte	0x05,0xAF,0xE0,0x50,0xE0,0xAA
l_3A59:
	.byte	0x05,0xAF,0xD8,0x50,0xD8,0xAA
l_3A5F:
	.byte	0x05,0xB7,0x58,0x48,0x58,0xAA

* this table is used for the various screen patterns for the levels
* code 1 = girders, 4 = rivets, 2 = pies, 3 = elevators
* used from #1947 and from #1799 and from #09BA

l_3A65:
	.byte	0x01,0x04                    | level 1
l_3A67:
	.byte	0x01,0x03,0x04                 | level 2
l_3A6A:
	.byte	0x01,0x02,0x03,0x04              | level 3
l_3A6E:
	.byte	0x01,0x02,0x01,0x03,0x04           | level 4
l_3A73:
	.byte	0x01,0x02,0x01,0x03,0x01,0x04        | level 5 +
l_3A79:
	.byte	0x7F                       | end code

* table data referenced in #3267

l_3A7A:
	.byte	0xFF,0x00,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0x00

* table data referenced in #343B

l_3A8C:
	.byte	0xE8,0xE5,0xE3,0xE2
l_3A90:
	.byte	0xE1,0xE0,0xDF,0xDE,0xDD,0xDD,0xDC,0xDC,0xDC,0xDC,0xDC,0xDC,0xDD,0xDD,0xDE,0xDF
l_3AA0:
	.byte	0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE7,0xE9,0xEB,0xED,0xF0,0xAA

* table data refeernced in #
* controls the positions of fires coming out of the oil can on the conveyors

l_3AAC:
	.byte	0x80,0x7B,0x78,0x76,0x74,0x73,0x72,0x71,0x70,0x70,0x6F,0x6F,0x6F,0x70,0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78
l_3AC3:
	.byte	0xAA               | end code

* table data referenced in #34C7

l_3AC4:
	.byte	0xEE,0xF0,0xDB,0xA0,0xE6,0xC8,0xD6,0x78,0xEB,0xF0,0xDB,0xA0,0xE6,0xC8,0xE6,0xC8

* table data referenced in #34ED

l_3AD4:
	.byte	0x1B,0xC8,0x23,0xA0,0x2B,0x78,0x12,0xF0,0x1B,0xC8,0x23,0xA0,0x12,0xF0,0x1B,0xC8

* start of table data
* used for screen 1 (girders)
* 120 bytes long
* 1st byte is the code [6 = X character, 5 = circle girder used in rivets, 3 = conveyor, 2 = girder, 1 = broken ladder, 0 = ladder]
* 2nd and 3rd bytes are the X,Y locations to start drawing
* data used for #6300


l_3AE4:
	.byte	0x02,0x97,0x38,0x68,0x38   | top girder where girl sits
l_3AE9:
	.byte	0x02,0x9F,0x54,0x10,0x54   | girder where kong sits
l_3AED:
	.byte	0x02,0xDF,0x58,0xA0,0x55   | 1st slanted girder at top right
l_3AF3:
	.byte	0x02,0xEF,0x6D,0x20,0x79   | 2nd slanted girder (has hammer at left side)
l_3AF8:
	.byte	0x02,0xDF,0x9A,0x10,0x8E   | 3rd slanted girder
l_3AFD:
	.byte	0x02,0xEF,0xAF,0x20,0xBB   | 4th slanted girder
l_3B02:
	.byte	0x02,0xDF,0xDC,0x10,0xD0   | 5th slanted girder (has hammer at right side)
l_3B07:
	.byte	0x02,0xFF,0xF0,0x80,0xF7   | bottom slanted girder
l_3B0C:
	.byte	0x02,0x7F,0xF8,0x00,0xF8   | bottom flat girder where mario starts
l_3B11:
	.byte	0x00,0xCB,0x57,0xCB,0x6F   | short ladder at top right
l_3B16:
	.byte	0x00,0xCB,0x99,0xCB,0xB1   | short ladder at center right
l_3B1B:
	.byte	0x00,0xCB,0xDB,0xCB,0xF3   | short ladder at bottom right
l_3B20:
	.byte	0x00,0x63,0x18,0x63,0x54   | kong's ladder (right)
l_3B25:
	.byte	0x01,0x63,0xD5,0x63,0xF8   | bottom broken ladder
l_3B2A:
	.byte	0x00,0x33,0x78,0x33,0x90   | short ladder at left side under top hammer
l_3B2F:
	.byte	0x00,0x33,0xBA,0x33,0xD2   | short ladder at left side above oil can
l_3B34:
	.byte	0x00,0x53,0x18,0x53,0x54   | kong's ladder (left)
l_3B39:
	.byte	0x01,0x53,0x92,0x53,0xB8   | second broken ladder from bottom, on 3rd girder
l_3B3E:
	.byte	0x00,0x5B,0x76,0x5B,0x92   | longer ladder under the top left hammer
l_3B43:
	.byte	0x00,0x73,0xB6,0x73,0xD6   | longer ladder to left of bottom hammer
l_3B48:
	.byte	0x00,0x83,0x95,0x83,0xB5   | center longer ladder
l_3B4D:
	.byte	0x00,0x93,0x38,0x93,0x54   | ladder leading to girl
l_3B52:
	.byte	0x01,0xBB,0x70,0xBB,0x98   | third broken ladder on right side near top
l_3B57:
	.byte	0x01,0x6B,0x54,0x6B,0x75   | fourth broken ladder near kong
l_3B5C:
	.byte	0xAA               |,0xAA code signals end of data

* table data for screen 2 conveyors
* 135 bytes long

l_3B5D:
	.byte	0x06,0x8F,0x90,0x70,0x90   | central patch of XXX's
l_3B62:
	.byte	0x06,0x8F,0x98,0x70,0x98   | central patch of XXX's
l_3B67:
	.byte	0x06,0x8F,0xA0,0x70,0xA0   | central patch of XXX's
l_3B6C:
	.byte	0x00,0x63,0x18,0x63,0x58   | kong's ladder (right)
l_3B71:
	.byte	0x00,0x63,0x80,0x63,0xA8   | center ladder to left of oil can fire
l_3B76:
	.byte	0x00,0x63,0xD0,0x63,0xF8   | bottom level ladder #2 of 4
l_3B7B:
	.byte	0x00,0x53,0x18,0x53,0x58   | kong's ladder (left)
l_3B80:
	.byte	0x00,0x53,0xA8,0x53,0xD0   | ladder under the hat
l_3B85:
	.byte	0x00,0x9B,0x80,0x9B,0xA8   | center ladder to right of oil can fire
l_3B8A:
	.byte	0x00,0x9B,0xD0,0x9B,0xF8   | bottom level ladder #3 of 4
l_3B8F:
	.byte	0x01,0x23,0x58,0x23,0x80   | top broken ladder left side
l_3B94:
	.byte	0x01,0xDB,0x58,0xDB,0x80   | top broken ladder right side
l_3B99:
	.byte	0x00,0x2B,0x80,0x2B,0xA8   | ladder on left platform with hammer
l_3B9E:
	.byte	0x00,0xD3,0x80,0xD3,0xA8   | ladder on right plantform with umbrella
l_3BA3:
	.byte	0x00,0xA3,0xA8,0xA3,0xD0   | ladder to right of bottom hammer
l_3BA8:
	.byte	0x00,0x2B,0xD0,0x2B,0xF8   | bottom level ladder #1 of 4
l_3BAD:
	.byte	0x00,0xD3,0xD0,0xD3,0xF8   | bottom level ladder #4 of 4
l_3BB2:
	.byte	0x00,0x93,0x38,0x93,0x58   | ladder leading to girl
l_3BB7:
	.byte	0x02,0x97,0x38,0x68,0x38   | girder where girl sits
l_3BBC:
	.byte	0x03,0xEF,0x58,0x10,0x58   | top conveyor girder
l_3BC1:
	.byte	0x03,0xF7,0x80,0x88,0x80   | top right conveyor next to oil can
l_3BC6:
	.byte	0x03,0x77,0x80,0x08,0x80   | top left conveyor next to oil can
l_3BCB:
	.byte	0x02,0xA7,0xA8,0x50,0xA8   | center ledge
l_3BD0:
	.byte	0x02,0xE7,0xA8,0xB8,0xA8   | right center ledge
l_3BD5:
	.byte	0x02,0x3F,0xA8,0x18,0xA8   | left center ledge (has hammer)
l_3BDA:
	.byte	0x03,0xEF,0xD0,0x10,0xD0   | main lower conveyor girder (has hammer)
l_3BDF:
	.byte	0x02,0xEF,0xF8,0x10,0xF8   | bottom level girder
l_3BE4:
	.byte	0xAA               | end code

* table data for the elevators
* 165 bytes long

l_3BE5:
	.byte	0x00,0x63,0x18,0x63,0x58   | kong's ladder (right)
l_3BEA:
	.byte	0x00,0x63,0x88,0x63,0xD0   | center ladder right
l_3BEF:
	.byte	0x00,0x53,0x18,0x53,0x58   | long's ladder (left)
l_3BF4:
	.byte	0x00,0x53,0x88,0x53,0xD0   | center ladder left
l_3BF9:
	.byte	0x00,0xE3,0x68,0xE3,0x90   | far top right ladder leading to purse
l_3BFE:
	.byte	0x00,0xE3,0xB8,0xE3,0xD0   | far bottom right ladder
l_3C03:
	.byte	0x00,0xCB,0x90,0xCB,0xB0   | ladder leading to purse (lower level)
l_3C08:
	.byte	0x00,0xB3,0x58,0xB3,0x78   | ladder leading to kong's level
l_3C0D:
	.byte	0x00,0x9B,0x80,0x9B,0xA0   | ladder to right of top right elevator
l_3C12:
	.byte	0x00,0x93,0x38,0x93,0x58   | ladder leading up to girl
l_3C17:
	.byte	0x00,0x23,0x88,0x23,0xC0   | long ladder on left side
l_3C1C:
	.byte	0x00,0x1B,0xC0,0x1B,0xE8   | bottom left ladder
l_3C21:
	.byte	0x02,0x97,0x38,0x68,0x38   | girder girl is on
l_3C26:
	.byte	0x02,0xB7,0x58,0x10,0x58   | kong's girder
l_3C2B:
	.byte	0x02,0xEF,0x68,0xE0,0x68   | girder where purse is
l_3C30:
	.byte	0x02,0xD7,0x70,0xC8,0x70   | girder to left of purse
l_3C35:
	.byte	0x02,0xBF,0x78,0xB0,0x78   | girder holding ladder that leads up to kong's level
l_3C3A:
	.byte	0x02,0xA7,0x80,0x90,0x80   | girder to right of top right elevator
l_3C3F:
	.byte	0x02,0x67,0x88,0x48,0x88   | top girder for central ladder section between elevators
l_3C34:
	.byte	0x02,0x27,0x88,0x10,0x88   | girder that holds the umbrella
l_3C39:
	.byte	0x02,0xEF,0x90,0xC8,0x90   | girder under the girder that has the purse
l_3C4E:
	.byte	0x02,0xA7,0xA0,0x98,0xA0   | bottom girder for section to right of top right elevator
l_3C53:
	.byte	0x02,0xBF,0xA8,0xB0,0xA8   | small floating girder
l_3C58:
	.byte	0x02,0xD7,0xB0,0xC8,0xB0   | small girder
l_3C5D:
	.byte	0x02,0xEF,0xB8,0xE0,0xB8   | small girder
l_3C62:
	.byte	0x02,0x27,0xC0,0x10,0xC0   | girder just above mario start
l_3C67:
	.byte	0x02,0xEF,0xD0,0xD8,0xD0   | small girder on far right bottom
l_3C6C:
	.byte	0x02,0x67,0xD0,0x50,0xD0   | bottom girder for central ladder section between elevators
l_3C71:
	.byte	0x02,0xCF,0xD8,0xC0,0xD8   | small girder
l_3C76:
	.byte	0x02,0xB7,0xE0,0xA8,0xE0   | small girder
l_3C7B:
	.byte	0x02,0x9F,0xE8,0x88,0xE8   | floating girder where the right side elevator gets off
l_3C80:
	.byte	0x02,0x27,0xE8,0x10,0xE8   | girder where mario starts
l_3C85:
	.byte	0x02,0xEF,0xF8,0x10,0xF8   | long bottom girder (mario dies if he gets that low)
l_3C8A:
	.byte	0xAA               | end code

* table data for the rivets

l_3C8B:
	.byte	0x00,0x7B,0x80,0x7B,0xA8   | center ladder level 3
l_3C90:
	.byte	0x00,0x7B,0xD0,0x7B,0xF8   | bottom center ladder
l_3C95:
	.byte	0x00,0x33,0x58,0x33,0x80   | top left ladder
l_3C9A:
	.byte	0x00,0x53,0x58,0x53,0x80   | top left ladder (right side)
l_3C9F:
	.byte	0x00,0xAB,0x58,0xAB,0x80   | top right ladder (left side)
l_3CA4:
	.byte	0x00,0xCB,0x58,0xCB,0x80   | top right ladder
l_3CA9:
	.byte	0x00,0x2B,0x80,0x2B,0xA8   | level 3 ladder left side
l_3CAE:
	.byte	0x00,0xD3,0x80,0xD3,0xA8   | level 3 ladder right side
l_3CB3:
	.byte	0x00,0x23,0xA8,0x23,0xD0   | level 2 ladder left side
l_3CB8:
	.byte	0x00,0x5B,0xA8,0x5B,0xD0   | level 2 ladder #2 of 4
l_3CBD:
	.byte	0x00,0xA3,0xA8,0xA3,0xD0   | level 2 ladder #3 of 4
l_3CC2:
	.byte	0x00,0xDB,0xA8,0xDB,0xD0   | level 2 ladder right side
l_3CC7:
	.byte	0x00,0x1B,0xD0,0x1B,0xF8   | bottom left ladder
l_3CCC:
	.byte	0x00,0xE3,0xD0,0xE3,0xF8   | bottom right ladder
l_3CD1:
	.byte	0x05,0xB7,0x30,0x48,0x30   | girder above kong
l_3CD6:
	.byte	0x05,0xCF,0x58,0x30,0x58   | girder kong stands on
l_3CDB:
	.byte	0x05,0xD7,0x80,0x28,0x80   | level 4 girder
l_3CE0:
	.byte	0x05,0xDF,0xA8,0x20,0xA8   | level 3 girder
l_3CE5:
	.byte	0x05,0xE7,0xD0,0x18,0xD0   | level 2 girder
l_3CEA:
	.byte	0x05,0xEF,0xF8,0x10,0xF8   | bottom level girder
l_3CEF:
	.byte	0xAA               | end code

*

l_3CF0:
	.byte	0x10,0x82,0x85,0x8B,0x10,0x85,0x80,0x8B,0x10,0x87,0x85,0x8B,0x81,0x80,0x80,0x8B |  .25m.50m.75m100m
l_3D00:
	.byte	0x81,0x82,0x85,0x8B,0x81,0x85,0x80,0x8B                          | 125m150m

* used to draw the game logo in attract mode
* data called from #07F7
* data grouped in 3's
* first byte is a loop counter - how many things to draw, going down
* 2nd and 3rd bytes are coordinates to start

l_3D08:
	.byte	0x05,0x88,0x77,0x01,0x68,0x77,0x01,0x6C,0x77,0x03,0x49,0x77              | D
l_3D14:
	.byte	0x05,0x08,0x77,0x01,0xE8,0x76,0x01,0xEC,0x76,0x05,0xC8,0x76              | O
l_3D20:
	.byte	0x05,0x88,0x76,0x02,0x69,0x76,0x02,0x4A,0x76,0x05,0x28,0x76              | N
l_3D2C:
	.byte	0x05,0xE8,0x75,0x01,0xCA,0x75,0x03,0xA9,0x75,0x01,0x88,0x75,0x01,0x8C,0x75     | K
l_3D3B:
	.byte	0x05,0x48,0x75,0x01,0x28,0x75,0x01,0x2A,0x75                       | E (part 1)
l_3D44:
	.byte	0x01,0x2C,0x75,0x01,0x08,0x75,0x01,0x0A,0x75,0x01,0x0C,0x75              | E (part 2)
l_3D50:
	.byte	0x03,0xC8,0x74,0x03,0xAA,0x74,0x03,0x88,0x74                       | Y
l_3D59:
	.byte	0x05,0x2F,0x77,0x05,0x0F,0x77,0x02,0xF0,0x76,0x02,0xCF,0x76,0x02,0xD2,0x76     | K
l_3D68:
	.byte	0x05,0x8F,0x76,0x05,0x6F,0x76,0x01,0x4F,0x76,0x01,0x53,0x76,0x05,0x2F,0x76     | O
l_3D77:
	.byte	0x05,0xEF,0x75,0x02,0xD0,0x75,0x02,0xB1,0x75,0x05,0x8F,0x75              | N
l_3D83:
	.byte	0x03,0x50,0x75,0x05,0x2F,0x75,0x01,0x0F,0x75,0x01,0x13,0x75              | G (part 1)
l_3D8F:
	.byte	0x01,0xEF,0x74,0x01,0xF1,0x74,0x01,0xF3,0x74,0x02,0xD1,0x74              | G (part 2)
l_3D9B:
	.byte	0x00                                               | end code

* table code reference from #0F6F
* values are copied into #6280 through #6280 + #40

l_3D9C:
	.byte	0x00,0x00,0x23,0x68
l_3DA0:
	.byte	0x01,0x11,0x00,0x00,0x00,0x10,0xDB,0x68,0x01,0x40,0x00,0x00,0x08,0x01,0x01,0x01
l_3DB0:
	.byte	0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x01,0xC0,0xFF
l_3DC0:
	.byte	0x01,0xFF,0xFF,0x34,0xC3,0x39,0x00,0x67,0x80,0x69,0x1A,0x01,0x00,0x00,0x00,0x00
l_3DD0:
	.byte	0x00,0x00,0x00,0x00,0x04,0x00,0x10,0x00,0x00,0x00,0x00,0x00

* data used for the barrel pile next to kong
* called from #0FD7

l_3DDC:
	.byte	0x1E,0x18,0x0B,0x4B       | first barrel
	.byte	0x14,0x18,0x0B,0x4B       | second barrel
	.byte	0x1E,0x18,0x0B,0x3B       | third barrel
	.byte	0x14,0x18,0x0B,0x3B       | fourth barrel

* the following is table data that gets copied to #6407 - location and other data of the fires?
* 05 is a loop varialbe
* 1C loops value corresponds to total length of table

l_3DEC:
	.byte	0x3D,0x01,0x03,0x02

* table data that also gets called from #1138
* DE is #6407 - Fire # 1 y value
* B is 05 and C is 1C

l_3DF0:
	.byte	0x4D,0x01,0x04,0x01

l_3DF4:
	.byte	0x27,0x70,0x01,0xE0,0x00,0x00        | initial data for fires on girders ?
l_3DFA:
	.byte	0x7F,0x40,0x01,0x78,0x02,0x00        | initial data for conveyors to release a fire ?

* table data called from #0FF5.  4 bytes

l_3E00:
	.byte	0x27,0x49,0x0C,0xF0               | oil can for girders
	.byte	0x7F,0x49,0x0C,0x88               | oil can for conveyors ?

* another table called and copied into #6687-668A an #6697-#669A - has to do with the hammers
* B counter is #02 and C is #0C
* called from #122E
* 3E0C is called also from #1000

l_3E08:
	.byte	0x1E,0x07            |,0x1E is the hammer sprite value.,0x07 is hammer color
l_3E0A:
	.byte	0x03,0x09            | ???
l_3E0C:
	.byte	0x24,0x64            | position of top hammer for girders.,0x24 is X,,0x64 is Y
l_3E0E:
	.byte	0xBB,0xC0            | bottom hammer for girders at,0xBB,,0xC0

l_3E10:
	.byte	0x23,0x8D,0x7B,0xB4      | for conveyors

l_3E14:
	.byte	0x1B,0x8C,0x7C,0x64      | for rivets
l_3E18:
	.byte	0x4B,0x0E,0x04,0x02      | ???

* 2 ladder sprites for conveyors
* 46 = ladder

l_3E1C:
	.byte	0x23,0x46,0x03,0x68              | ladder at,0x23,,0x68
l_3E20:
	.byte	0xDB,0x46,0x03,0x68              | ladder at,0xDB,,0x68

* the 6 conveyor pulleys

l_3E24:
	.byte	0x17,0x50,0x00,0x5C              |,0x50 = edge of conveyor pulley
l_3E28:
	.byte	0xE7,0xD0,0x00,0x5C              |,0xD0 = edge of conveyor pulley inverted
l_3E2C:
	.byte	0x8C,0x50,0x00,0x84
l_3E30:
	.byte	0x73,0xD0,0x00,0x84
l_3E34:
	.byte	0x17,0x50,0x00,0xD4
l_3E38:
	.byte	0xE7,0xD0,0x00,0xD4

* bonus items on conveyors

l_3e3c:
	.byte	0x53,0x73,0x0A,0xA0               | position of hat on pies is,0x53,A0
	.byte	0x8B,0x74,0x0A,0xF0               | position of purse on pies is,0x8B,F0
	.byte	0xDB,0x75,0x0A,0xA0               | umbrella on the pies is at,0xDB,A0

* bonus items for elevators

l_3E48:
	.byte	0x5B,0x73,0x0A,0xC8               |  hat at,0x5B,C8
	.byte	0xE3,0x74,0x0A,0x60               |  purse at,0xE3,60
	.byte	0x1B,0x75,0x0A,0x80               |  umbrella on elevator is,0x80,1B

* bonus items for rivets

l_3E54:
	.byte	0xDB,0x73,0x0A,0xC8               | hat on rivets at,0xDB,C8
	.byte	0x93,0x74,0x0A,0xF0               | purse on rivets at,0x93,F0
	.byte	0x33,0x75,0x0A,0x50               | umbrella on rivets at,0x33,50

* used in elevators - called from #10CC

l_3E60:
	.byte	0x44,0x03,0x08,0x04

* used in elevators, called from #11EC
* used for elevator sprites

l_3E64:
	.byte	0x37,0xF4
l_3E66:
	.byte	0x37,0xC0
l_3E68:
	.byte	0x37,0x8C                    | elevators on left all have X value of,0x37

l_3E6A:
	.byte	0x77,0x70
l_3E6C:
	.byte	0x77,0xA4
l_3E6E:
	.byte	0x77,0xD8                    | elevators on right all have X value of,0x77

	.align	2
	
* award points for jumping a barrels and items
* arrive from #1DD7
* A is preloaded with 1,3, or 7
* patch ?

set_scoring_sprites_3e70:
	move.w	#0x0001,d3                      	| [$3e70: ld      de,$0001] 100 points 1
	move.b	#0x7b,d1                        	| [$3e73: ld      b,$7b] sprite for 100
	CLEAR_XC_FLAGS
	roxr.b	#1,d0                           	| [$3e75: rra] is the score set for 100 ?
 	jcc	l_1e28                             	| [$3e76: jp      nc,$1e28] yes, award points

	move.b	#0x03,d3                        	| [$3e79: ld      e,$03] else set 300 points
	move.b	#0x7d,d1                        	| [$3e7b: ld      b,$7d] sprite for 300
	roxr.b	#1,d0                           	| [$3e7d: rra] is the score set for 300 ?
	jcc	l_1e28                             	| [$3e7e: jp      nc,$1e28] yes, award points

	move.b	#0x05,d3                        	| [$3e81: ld      e,$05] else set 500 points [bug, should be 800]
	move.b	#0x7f,d1                        	| [$3e83: ld      b,$7f] sprite for 800
	jra	l_1e28                             	| [$3e85: jp      $1e28] award points


* called from #286B
* a patch ?

l_3e88:
	move.b	screen_number_6227,d0           	| [$3e88: ld      a,(screen_number_6227)] load A with screen number

	movem.w	d5/d6,-(sp)                        	| [$3e8b: push    hl] save HL
	jbsr	rst_28                            	| [$3e8c: rst     $28] jump to new location based on screen number

* data for above:

	.long	0| unused
	.long	l_3e99| #3E99 - girders
	.long	check_collisions_in_conveyors_28b0| #28B0 - pie
	.long	check_collisions_in_elevators_28e0| #28E0 - elevator
	.long	check_collisions_in_rivets_2901| #2901 - rivets


* checks for jumps over items on girders

l_3e99:
	movem.w	(sp)+,d5/d6                        	| [$3e99: pop     hl] restore HL
	clr.b	d0                               	| [$3e9a: xor     a] A := 0
	move.b	d0,numobstaclesjumped_6060      	| [$3e9b: ld      (numobstaclesjumped_6060),a] clear counter for barrels jumped
	move.b	#NB_BARRELS,d1                        	| [$3e9e: ld      b,$0a] For B = 1 to #A barrels
	move.w	#0x0020,d3                      	| [$3ea0: ld      de,$0020] load DE with offset 32
	lea	start_of_barrel_info_table_6700,a2	| [$3ea3: ld      ix,start_of_barrel_info_table_6700] load IX with start of barrel info table
	jbsr	check_enemies_being_jumped_3ec3                            	| [$3ea7: call    $3ec3] call sub below.  check for barrels under jump

	move.b	#NB_FIRES,d1                        	| [$3eaa: ld      b,$05] for B = 1 to 5 fires
	lea	start_of_fires_table_6400,a2   	| [$3eac: ld      ix,start_of_fires_table_6400] start of fires table
	jbsr	check_enemies_being_jumped_3ec3                            	| [$3eb0: call    $3ec3] check for fires being jumped

	move.b	numobstaclesjumped_6060,d0      	| [$3eb3: ld      a,(numobstaclesjumped_6060)] load A with counter for items jumped
	                               	| [$3eb6: and     a] nothing jumped ?
	bne.b	0f                               	| [...]
	rts                                    	| [$3eb7: ret     z] yes, return [...]
0:

	cmp.b	#0x01,d0                         	| [$3eb8: cp      $01] was 1 item jumped?
	bne.b	0f                               	| [...]
	rts                                    	| [$3eba: ret     z] yes, return| 1 is the code for 100 pts [...]
0:

	cmp.b	#0x03,d0                         	| [$3ebb: cp      $03] were less than 3 items jumped ?
	bcc.b	0f                               	| [...]
	move.b	#0x03,d0                        	| [$3ebd: ld      a,$03] A := 3  = code for 2 items, 300 pts score
	rts                                    	| [$3ebf: ret     c] yes, return [...]
0:

	move.b	#0x07,d0                        	| [$3ec0: ld      a,$07] else A := 7 = code for 3+ items, awards 800 points
	rts                                    	| [$3ec2: ret] return

* subroutine called from #3EA7 above
* checks for mario jumping over barrels or fires
* H is preloaded with either 5 or #13 (19 decimal) for the area under mario ?
* C is preloaded with mario's Y position + #C (12 decimal)
* IX preloaded with start of array for fires or barrels, EG #6700 or #6400
* L is preloaded with height window value ?
* DE is preloaded with offset to add for next sprite

check_enemies_being_jumped_3ec3:
	btst.b	#0,(a2)                    	| [$3ec3: bit     0,(ix+$00)] is this barrel/fire active?
	jeq	l_3efa                             	| [$3ec7: jp      z,$3efa] no, jump ahead to try next one

	move.b	d2,d0                           	| [$3eca: ld      a,c] load A with mario's adjusted Y position
	sub.b	(0x05,a2),d0                     	| [$3ecb: sub     (ix+$05)] subtract the fire/barrel Y position.  did the result go negative?
	jcc	l_3ed3                             	| [$3ece: jp      nc,$3ed3] no, skip next step

	neg.b	d0                               	| [$3ed1: neg] Negate A (A := 0 - A)

l_3ed3:
	addq.b	#1,d0                           	| [$3ed3: inc     a] increment A
	sub.b	d6,d0                            	| [$3ed4: sub     l] subtract L (height window?)  Is there a carry ?
	jcs	l_3ede                             	| [$3ed5: jp      c,$3ede] yes, skip next two steps

	sub.b	(0x0a,a2),d0                     	| [$3ed8: sub     (ix+$0a)] else subtract the items' height???
	jcc	l_3efa                             	| [$3edb: jp      nc,$3efa] if out of range, jump ahead to try next one

* we are within the Y range, test X range next

l_3ede:
	move.b	(0x03,a3),d0                    	| [$3ede: ld      a,(iy+$03)] load A with mario's X position
	sub.b	(0x03,a2),d0                     	| [$3ee1: sub     (ix+$03)] subtract the item's X position
	jcc	l_3ee9                             	| [$3ee4: jp      nc,$3ee9] if no carry, skip next step

	neg.b	d0                               	| [$3ee7: neg] negate A

l_3ee9:
	sub.b	d5,d0                            	| [$3ee9: sub     h] subtract the horizontal window (5 or 19 pixels)
	jcs	l_3ef3                             	| [$3eea: jp      c,$3ef3] if out of range, skip next 2 steps

	sub.b	(0x09,a2),d0                     	| [$3eed: sub     (ix+$09)] subtract the item's width???
	jcc	l_3efa                             	| [$3ef0: jp      nc,$3efa] if out of range, skip ahead to try next one

* item was jumped

l_3ef3:
	      	| [$3ef3: ld      a,(numobstaclesjumped_6060)] load A with counter of how many barrels/fires jumped
	addq.b	#1,numobstaclesjumped_6060                           	| [$3ef6: inc     a] increase it
	      	| [$3ef7: ld      (numobstaclesjumped_6060),a] store

l_3efa:
	add.w	d3,a2                            	| [$3efa: add     ix,de] add offset for next barrel or fire
	subq.b	#1,d1                           	| [...]
	jne	check_enemies_being_jumped_3ec3                             	| [$3efc: djnz    $3ec3] Next B

	rts                                    	| [$3efe: ret] return

* ... overwrites the message from game creators...

l_3EFF:
	.byte	0x00
l_3F00:
	.byte	0x5C,0x76,0x49,0x4A,0x01,0x09,0x08,0x01,0x3F,0x7D,0x77,0x1E,0x19,0x1E,0x24,0x15  |.(C)1981...NINTE
l_3F10:
	.byte	0x1E,0x14,0x1F,0x10,0x1F,0x16,0x10,0x11,0x1D,0x15,0x22,0x19,0x13,0x11,0x10,0x19  |NDO.OF.AMERICA.I
l_3F20:
	.byte	0x1E,0x13,0x2B,0x3F                                      |NC..
	.align	2
* called from #081C : patch to draw the TM logo on attract screen

l_3f24:
	move.w	#0x74af,d7                      	| [$3f24: ld      hl,$74af] load HL with screen VRAM address
	move.w	#0xffe0,d3                      	| [$3f27: ld      de,$ffe0] load offset
	move.b	#0x9f,d0                      	| [$3f2a: ld      (hl),$9f] draw first part of TM logo to screen
	jbsr	osd_w_videoram
	add.w	d3,d7                            	| [$3f2c: add     hl,de] next screen location
	move.b	#0x9e,d0                      	| [$3f2d: ld      (hl),$9e] draw second part of TM logo to screen
	jbsr	osd_w_videoram
	rts                                    	| [$3f2f: ret] return

*
*
* Original Dkong code, taken from mame set dkongj
*
*3F00:  43 4F 4E 47 52 41 54 55 4C 41 54 49 4F 4E 20 21  CONGRATULATION !
*3F10:  49 46 20 59 4F 55 20 41 4E 41 4C 59 53 45 20 20  IF YOU ANALYSE
*3F20:  44 49 46 46 49 43 55 4C 54 20 54 48 49 53 20 20  DIFFICULT THIS
*
*


l_3f30:
	.byte	0x50,0x52,0x4F,0x47,0x52,0x41,0x4D,0x2C,0x57,0x45,0x20,0x57,0x4F,0x55,0x4C,0x44  |PROGRAM,WE WOULD
	.byte	0x20,0x54,0x45,0x41,0x43,0x48,0x20,0x59,0x4F,0x55,0x2E,0x2A,0x2A,0x2A,0x2A,0x2A  | TEACH YOU.*****
	.byte	0x54,0x45,0x4C,0x2E,0x54,0x4F,0x4B,0x59,0x4F,0x2D,0x4A,0x41,0x50,0x41,0x4E,0x20  |TEL.TOKYO-JAPAN
	.byte	0x30,0x34,0x34,0x28,0x32,0x34,0x34,0x29,0x32,0x31,0x35,0x31,0x20,0x20,0x20,0x20  |044(244)2151
	.byte	0x45,0x58,0x54,0x45,0x4E,0x54,0x49,0x4F,0x4E,0x20,0x33,0x30,0x34,0x20,0x20,0x20  |EXTENTION 304
	.byte	0x53,0x59,0x53,0x54,0x45,0x4D,0x20,0x44,0x45,0x53,0x49,0x47,0x4E,0x20,0x20,0x20  |SYSTEM DESIGN
	.byte	0x49,0x4B,0x45,0x47,0x41,0x4D,0x49,0x20,0x43,0x4F,0x2E,0x20,0x4C,0x49,0x4D,0x2E  |IKEGAMI CO. LIM.


* jump here from #0CD1
* a patch ?

l_3fa0:
	jbsr	l_3fa6                            	| [$3fa0: call    $3fa6] call sub below
	jra	l_0d5f                             	| [$3fa3: jp      $0d5f] return to program [this was original line wiped by patch ?]

* called from #3FA0 above

l_3fa6:
	move.b	#0x02,d0                        	| [$3fa6: ld      a,$02] A := 2
	jbsr	only_continues_if_given_level_0030                            	| [$3fa8: rst     $30] check to see if the level is pie factory.  If not, RET to #3FA3 [then jump to #0D5F]

	move.b	#0x02,d1                        	| [$3fa9: ld      b,$02] for B = 1 to 2
	move.w	#0x776c,d7                      	| [$3fab: ld      hl,$776c] load HL with video RAM address for top rectractable ladder

l_3fae:
	move.b	#0x10,d0                      	| [$3fae: ld      (hl),$10] clear the top of the ladder
	jbsr	osd_w_videoram
	addq.w	#2,d7                           	| [$3fb0: inc     hl] * 2
	move.b	#0xc0,d0                      	| [$3fb2: ld      (hl),$c0] draw a ladder 2 rows down
	jbsr	osd_w_videoram
	move.w	#0x748c,d7                      	| [$3fb4: ld      hl,$748c] set HL for next loop - does the other side of the screen | [sloppy?  this instruction not needed on 2nd loop]
	subq.b	#1,d1                           	| [...]
	jne	l_3fae                             	| [$3fb7: djnz    $3fae] Next B

	rts                                    	| [$3fb9: ret] return [to #3FA3, then jump to #0D5F]

l_3FBA:
	.byte	0x00,0x00,0x00,0x00,0x00,0x00                | unused

* called from #2285
* [seems like a patch ? - resets mario sprite when ladder descends]

l_3fc0:
	lea	mario_sprite_value_694d,a0     	| [$3fc0: ld      hl,mario_sprite_value_694d] load HL with mario sprite value
	move.b	#0x03,(a0)                      	| [$3fc3: ld      (hl),$03] store 3 = mario on ladder with left hand up
	addq.w	#2,a0                           	| [$3fc5: inc     l] * 2
	rts                                    	| [$3fc7: ret] return


*
*
*http://www.brasington.org/arcade/tech/dk/
*
*
*
*
*Function Chip Type 2-Board location 4-Board location
*Color Maps 256x4 prom 2E (CPU) 2K (CPU)
*Color Maps 256x4 prom 2F (CPU) 2J (CPU)
*Character Colors 256x4 prom 2N (VIDEO) 5F (VIDEO)
*Fixed Characters 2716 3N (VIDEO) 5H (VIDEO)
*Fixed Characters 2716 3P (VIDEO) 5K (VIDEO)
*Code 0x3000-0x3fff 2532 5A (CPU) 5K (CPU)
*Code 0x2000-0x2fff 2532 5B (CPU) 5H (CPU)
*Code 0x1000-0x1Fff 2532 5C (CPU) 5G (CPU)
*Code 0x0000-0x0Fff 2532 5E (CPU) 5F (CPU)
*Not used - vacant     5L (CPU)
*Moving Objects 2716 7C (VIDEO) 4M (CLK)
*Moving Objects 2716 7D (VIDEO) 4N (CLK)
*Moving Objects 2716 7E (VIDEO) 4R (CLK)
*Moving Objects 2716 7F (VIDEO) 4S (CLK)
*Digital Sound 2716 3F (CPU) 3J (SOU)
*Digital Sound 2716 3H (CPU) 3I (SOU)
*Z80 CPU  Z80 7C (CPU) 5C (CPU)
*8035 MPU (music) 8035 7H (CPU) 3H (SOU)
*CPU RAM 2114 3A (CPU) XX (CPU)
*CPU RAM 2114 4A (CPU) XX (CPU)
*CPU RAM 2114 3B (CPU) XX (CPU)
*CPU RAM 2114 4B (CPU) XX (CPU)
*CPU RAM 2114 3C (CPU) XX (CPU)
*CPU RAM 2114 4C (CPU) XX (CPU)
*Character RAM 2114 2P (VIDEO) XX (VIDEO)
*Character RAM 2114 2R (VIDEO) XX (VIDEO)
*Object RAM 2148 6P (VIDEO) XX (VIDEO)
*Object RAM 2148 6R (VIDEO) XX (VIDEO)



*change to konkey dong:

*l_3D08:
*	.byte	0x05,0x0F,0x77,0x01,0xEF,0x76,0x01,0xF3,0x76,0x03,0xD0,0x76              | D transposed to where K is
*
*l_3D59:
*	.byte	0x05,0x2F,0x77,0x05,0x88,0x77,0x02,0x69,0x77,0x02,0x48,0x77,0x02,0x4B,0x77     | K transposed to where D is


*:dkong:20500000:3D66:00004B77:0000FFFF:konkey dong
*:dkong:20710000:3D61:77024877:FFFFFFFF:konkey dong (2/6)
*:dkong:20710000:3D5D:88770269:FFFFFFFF:konkey dong (3/6)
*:dkong:20510000:3D12:0000D076:00FFFFFF:konkey dong (4/6)
*:dkong:20710000:3D0D:7601F376:FFFFFFFF:konkey dong (5/6)
*:dkong:20710000:3D09:0F7701EF:FFFFFFFF:konkey dong (6/6)

*c_5At_g.bin:

*76
*77

* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
    subq.w    #1,d1
0:
    move.b    (a0)+,(a1)+
    dbf        d1,0b
    clr.w    d1
    rts

* < A0: source (HL)
* < D1: length to search
* > D0.B value searched for (A)
* > Z flag if found
cpir:
    subq.w    #1,d1
0:
    cmp.b    (a0)+,d0
    beq.b    1f
    dbf        d1,0b
    clr.w    d1
    * not found: unset Z
    cmp.b   #1,d1
1:
    rts

* < all registers d1-d4/a0/a1/a4
* > all registers swapped
*: note regscopy must be defined somewhere in RAM
*: with a size of 56
exx:
    lea     regscopy+28,a6
    * save current regs in region 1
    movem.l d1-d4/a0/a1/a4,-(a6)
    * restore old regs from region 2
    lea     regscopy+28,a6
    movem.l (a6),d1-d4/a0/a1/a4
    * now copy region 1 to region 2
    movem.l d1-d4/a0/a1/a4,-(a7)
    lea     regscopy,a6
    movem.l (a6)+,d1-d4/a0/a1/a4
    movem.l d1-d4/a0/a1/a4,(a6)
    movem.l (a7)+,d1-d4/a0/a1/a4
    rts
